{
    "docs": [
        {
            "location": "/", 
            "text": "Erdos\n\n\nErdos\n is a graph library written in Julia. Installation is straightforward:\n\n\n\njulia\n Pkg.add(\nErdos\n)\n\n\n\n\n\nErdos defines two abstract graph types, \nAGraph\n and \nADiGraph\n, from which all concrete undirected and directed graph types are derived.\n\n\nTwo concrete graph types, \nGraph\n and \nNetwork\n, and two digraph types, \nDiGraph\n and \nDiNetwork\n are implemented. In all these types the graph topology is represented internally as an adjacency list for each vertex. \n(Di)Network\ns come with some additional features over \n(Di)Graph\ns:\n\n\n\n\neach edge has a unique index;\n\n\nvertex/edge maps (also called properties) can be stored internally.\n\n\n\n\nAll graphs in \nErdos\n have \n1:n\n indexed vertices, where \nn\n is the number of vertices. Multi-edges are not allowed. Self-edges are experimentally supported. Provided this constraints, new graph types can be easily introduced just defining a few basic methods.\n\n\n\n\nBasic examples\n\n\n\n\nConstructors\n\n\nBuild your first graph using the basic constructors.\n\n\n\njulia\n using Erdos\n\n\n\njulia\n g = CompleteGraph(100)\n\nGraph{Int64}(100, 4950)\n\n\n\njulia\n g = Network(10, 30) # a random graph with 10 vertex and 30 edges\n\nNetwork(10, 30)\n\n\n\njulia\n g = Graph{Int32}(100)\n\nGraph{Int32}(100, 0)\n\n\n\njulia\n g = DiGraph()\n\nDiGraph{Int64}(0, 0)\n\n\n\njulia\n g = erdos_renyi(10,30)\n\nGraph{Int64}(10, 30)\n\n\n\njulia\n g = random_regular_graph(10,3,seed=17)\n\nGraph{Int64}(10, 15).\n\n\n\n\n\nThe default graph and digraph types are \nGraph{Int}\n and \nDiGraph{Int}\n.\n\n\nUse  the \nGraph{Int32}\n type to save memory if working with very large graphs.\n\n\n\n\nQueries\n\n\n\njulia\n g = CompleteBipartiteGraph(5,10)\n\nGraph{Int64}(15, 50)\n\n\n\njulia\n is_bipartite(g)\n\ntrue\n\n\n\njulia\n nv(g) # number of vertices\n\n15\n\n\n\njulia\n ne(g) #number of edges\n\n50\n\n\n\njulia\n has_edge(g,1,2)\n\nfalse\n\n\n\njulia\n has_edge(g,1,6)\n\ntrue\n\n\n\njulia\n degree(g,1)\n\n10\n\n\n\n\n\n\n\nModifiers:\n\n\n\njulia\n g=DiGraph(10)\n\nDiGraph{Int64}(10, 0)\n\n\n\njulia\n add_edge!(g,1,2)\n\ntrue\n\n\n\njulia\n g\n\nDiGraph{Int64}(10, 1)\n\n\n\n# trying to add an edge between non-existen vertices results in a\n\n# (silent) failure\n\njulia\n add_edge!(g,1,11)\n\nfalse\n\n\n\n# has the addition of an already existent edge\n\njulia\n add_edge!(g,1,2)\n\nfalse\n\n\n\njulia\n add_edge!(g,2,1)\n\ntrue\n\n\n\njulia\n rem_edge!(g,2,1)\n\ntrue\n\n\n\n# returns the index of the vertex\n\njulia\n add_vertex!(g)\n\n11\n\n\n\n# vertex removal will cause the switch of the last index\n\n# with the removed one, to keep the indexes continuity.\n\njulia\n rem_vertex!(g,1)\n\ntrue\n\n\n\njulia\n rem_vertex!(g,12)\n\nfalse\n\n\n\n\n\n\n\nIterators\n\n\n\njulia\n g = Graph(10,20) #erdos renyi random graph with 10 vertices and 20 edges\n\nGraph{Int64}(10, 20)\n\n\n\njulia\n numedges = 0;\n\n\n\n# iterate over all edges\n\njulia\n for e in edges(g)\n\n           i, j = src(e), dst(e) # source and destination of an edge\n\n           @assert i \n= j  # default for undirected graphs\n\n           numedge += 1\n\n       end\n\n\n\njulia\n ne(g) == numedge\n\ntrue\n\n\n\njulia\n k=0;\n\n\n\njulia\n for i in neighbors(g,1)\n\n           @assert has_edge(g, 1, i);\n\n           k += 1\n\n       end\n\n\n\njulia\n degree(g, 1) == k\n\ntrue\n\n\n\n\n\n\n\nI/O\n\n\nErdos supports many standard graph formats. Here is an example with Pajek's .net\n\n\nformat:\n\n\n\njulia\n g = DiGraph(10,20)\n\nDiGraph{Int64}(10, 20)\n\n\n\njulia\n writegraph(\ntest.net\n, g)\n\n1\n\n\n\njulia\n h = readgraph(\ntest.net\n)\n\nDiGraph{Int64}(10, 20)\n\n\n\njulia\n g == h\n\ntrue\n\n\n\n\n\n\n\nDatasets\n\n\nA collection of real world graphs is available through \nreadgraph\n:\n\n\n\njulia\n g = readgraph(:karate)\n\nGraph{Int64}(34, 78)\n\n\n\njulia\n g = readgraph(:condmat,Graph{UInt32})\n\nGraph{UInt32}(16726, 47594)\n\n\n\n\n\n\n\nReady to explore\n\n\nRefer to the \ndocumentation\n to explore all the features of Erdos.\n\n\nHere is a comprehensive list of the implemente algorithms. (\nEE\n) denotes algorithms in the companion package \nErdosExtras\n.\n\n\n\n\n\n\ncore functions:\n vertices and edges addition and removal, degree (in/out/all), neighbors (in/out/all)\n\n\n\n\n\n\nmaps\n dictionary like types to store properties associated to vertices and edges\n\n\n\n\n\n\nnetworks\n store vertex/edge/graph properties (maps) inside the graph itself\n\n\n\n\n\n\nconnectivity:\n strongly- and weakly-connected components, bipartite checks, condensation, attracting components, neighborhood, k-core\n\n\n\n\n\n\noperators:\n complement, reverse, reverse!, union, join, intersect, difference, symmetric difference, blkdiag, induced subgraphs, products (cartesian/scalar)\n\n\n\n\n\n\nshortest paths:\n Dijkstra, Dijkstra with predecessors, Bellman-Ford, Floyd-Warshall, A*\n\n\n\n\n\n\ngraph datasets:\n A collection of real world graphs (e.g. Zachary's karate club)\n\n\n\n\n\n\ngraph generators:\n \nnotorious graphs\n, euclidean graphs and random graphs (Erd\u0151s\u2013R\u00e9nyi, Watts-Strogatz, random regular, arbitrary degree sequence, stochastic block model)\n\n\n\n\n\n\nI/O formats:\n \ngraphml\n, \ngml\n, \ngexf\n, \ndot\n, \nnet\n, \ngt\n. For some of these formats vertex/edge/graph properties can be read and written.\n\n\n\n\n\n\ncentrality:\n betweenness, closeness, degree, pagerank, Katz\n\n\n\n\n\n\ntraversal operations:\n cycle detection, BFS and DFS DAGs, BFS and DFS traversals with visitors, DFS topological sort, maximum adjacency / minimum cut, multiple random walks\n\n\n\n\n\n\nflow operations:\n maximum flow, minimum s-t cut\n\n\n\n\n\n\nmatching:\n minim weight matching on arbitrary graphs (\nEE\n), minimum b-matching (\nEE\n)\n\n\n\n\n\n\ntravelling salesman problem:\n a TSP solver based on linear programming (\nEE\n)\n\n\n\n\n\n\ndismantling:\n collective influencer heuristic\n\n\n\n\n\n\nclique enumeration:\n maximal cliques\n\n\n\n\n\n\nlinear algebra / spectral graph theory:\n adjacency matrix, Laplacian matrix, non-backtracking matrix\n\n\n\n\n\n\ncommunity:\n modularity, community detection, core-periphery, clustering coefficients\n\n\n\n\n\n\ndistance within graphs:\n eccentricity, diameter, periphery, radius, center\n\n\n\n\n\n\ndistance between graphs:\n spectral_distance, edit_distance", 
            "title": "Getting Started"
        }, 
        {
            "location": "/#erdos", 
            "text": "Erdos  is a graph library written in Julia. Installation is straightforward:  \njulia  Pkg.add( Erdos )  Erdos defines two abstract graph types,  AGraph  and  ADiGraph , from which all concrete undirected and directed graph types are derived.  Two concrete graph types,  Graph  and  Network , and two digraph types,  DiGraph  and  DiNetwork  are implemented. In all these types the graph topology is represented internally as an adjacency list for each vertex.  (Di)Network s come with some additional features over  (Di)Graph s:   each edge has a unique index;  vertex/edge maps (also called properties) can be stored internally.   All graphs in  Erdos  have  1:n  indexed vertices, where  n  is the number of vertices. Multi-edges are not allowed. Self-edges are experimentally supported. Provided this constraints, new graph types can be easily introduced just defining a few basic methods.", 
            "title": "Erdos"
        }, 
        {
            "location": "/#basic-examples", 
            "text": "", 
            "title": "Basic examples"
        }, 
        {
            "location": "/#constructors", 
            "text": "Build your first graph using the basic constructors.  \njulia  using Erdos\n\n\n\njulia  g = CompleteGraph(100)\n\nGraph{Int64}(100, 4950)\n\n\n\njulia  g = Network(10, 30) # a random graph with 10 vertex and 30 edges\n\nNetwork(10, 30)\n\n\n\njulia  g = Graph{Int32}(100)\n\nGraph{Int32}(100, 0)\n\n\n\njulia  g = DiGraph()\n\nDiGraph{Int64}(0, 0)\n\n\n\njulia  g = erdos_renyi(10,30)\n\nGraph{Int64}(10, 30)\n\n\n\njulia  g = random_regular_graph(10,3,seed=17)\n\nGraph{Int64}(10, 15).  The default graph and digraph types are  Graph{Int}  and  DiGraph{Int} .  Use  the  Graph{Int32}  type to save memory if working with very large graphs.", 
            "title": "Constructors"
        }, 
        {
            "location": "/#queries", 
            "text": "julia  g = CompleteBipartiteGraph(5,10)\n\nGraph{Int64}(15, 50)\n\n\n\njulia  is_bipartite(g)\n\ntrue\n\n\n\njulia  nv(g) # number of vertices\n\n15\n\n\n\njulia  ne(g) #number of edges\n\n50\n\n\n\njulia  has_edge(g,1,2)\n\nfalse\n\n\n\njulia  has_edge(g,1,6)\n\ntrue\n\n\n\njulia  degree(g,1)\n\n10", 
            "title": "Queries"
        }, 
        {
            "location": "/#modifiers", 
            "text": "julia  g=DiGraph(10)\n\nDiGraph{Int64}(10, 0)\n\n\n\njulia  add_edge!(g,1,2)\n\ntrue\n\n\n\njulia  g\n\nDiGraph{Int64}(10, 1)\n\n\n\n# trying to add an edge between non-existen vertices results in a\n\n# (silent) failure\n\njulia  add_edge!(g,1,11)\n\nfalse\n\n\n\n# has the addition of an already existent edge\n\njulia  add_edge!(g,1,2)\n\nfalse\n\n\n\njulia  add_edge!(g,2,1)\n\ntrue\n\n\n\njulia  rem_edge!(g,2,1)\n\ntrue\n\n\n\n# returns the index of the vertex\n\njulia  add_vertex!(g)\n\n11\n\n\n\n# vertex removal will cause the switch of the last index\n\n# with the removed one, to keep the indexes continuity.\n\njulia  rem_vertex!(g,1)\n\ntrue\n\n\n\njulia  rem_vertex!(g,12)\n\nfalse", 
            "title": "Modifiers:"
        }, 
        {
            "location": "/#iterators", 
            "text": "julia  g = Graph(10,20) #erdos renyi random graph with 10 vertices and 20 edges\n\nGraph{Int64}(10, 20)\n\n\n\njulia  numedges = 0;\n\n\n\n# iterate over all edges\n\njulia  for e in edges(g)\n\n           i, j = src(e), dst(e) # source and destination of an edge\n\n           @assert i  = j  # default for undirected graphs\n\n           numedge += 1\n\n       end\n\n\n\njulia  ne(g) == numedge\n\ntrue\n\n\n\njulia  k=0;\n\n\n\njulia  for i in neighbors(g,1)\n\n           @assert has_edge(g, 1, i);\n\n           k += 1\n\n       end\n\n\n\njulia  degree(g, 1) == k\n\ntrue", 
            "title": "Iterators"
        }, 
        {
            "location": "/#io", 
            "text": "Erdos supports many standard graph formats. Here is an example with Pajek's .net  format:  \njulia  g = DiGraph(10,20)\n\nDiGraph{Int64}(10, 20)\n\n\n\njulia  writegraph( test.net , g)\n\n1\n\n\n\njulia  h = readgraph( test.net )\n\nDiGraph{Int64}(10, 20)\n\n\n\njulia  g == h\n\ntrue", 
            "title": "I/O"
        }, 
        {
            "location": "/#datasets", 
            "text": "A collection of real world graphs is available through  readgraph :  \njulia  g = readgraph(:karate)\n\nGraph{Int64}(34, 78)\n\n\n\njulia  g = readgraph(:condmat,Graph{UInt32})\n\nGraph{UInt32}(16726, 47594)", 
            "title": "Datasets"
        }, 
        {
            "location": "/#ready-to-explore", 
            "text": "Refer to the  documentation  to explore all the features of Erdos.  Here is a comprehensive list of the implemente algorithms. ( EE ) denotes algorithms in the companion package  ErdosExtras .    core functions:  vertices and edges addition and removal, degree (in/out/all), neighbors (in/out/all)    maps  dictionary like types to store properties associated to vertices and edges    networks  store vertex/edge/graph properties (maps) inside the graph itself    connectivity:  strongly- and weakly-connected components, bipartite checks, condensation, attracting components, neighborhood, k-core    operators:  complement, reverse, reverse!, union, join, intersect, difference, symmetric difference, blkdiag, induced subgraphs, products (cartesian/scalar)    shortest paths:  Dijkstra, Dijkstra with predecessors, Bellman-Ford, Floyd-Warshall, A*    graph datasets:  A collection of real world graphs (e.g. Zachary's karate club)    graph generators:   notorious graphs , euclidean graphs and random graphs (Erd\u0151s\u2013R\u00e9nyi, Watts-Strogatz, random regular, arbitrary degree sequence, stochastic block model)    I/O formats:   graphml ,  gml ,  gexf ,  dot ,  net ,  gt . For some of these formats vertex/edge/graph properties can be read and written.    centrality:  betweenness, closeness, degree, pagerank, Katz    traversal operations:  cycle detection, BFS and DFS DAGs, BFS and DFS traversals with visitors, DFS topological sort, maximum adjacency / minimum cut, multiple random walks    flow operations:  maximum flow, minimum s-t cut    matching:  minim weight matching on arbitrary graphs ( EE ), minimum b-matching ( EE )    travelling salesman problem:  a TSP solver based on linear programming ( EE )    dismantling:  collective influencer heuristic    clique enumeration:  maximal cliques    linear algebra / spectral graph theory:  adjacency matrix, Laplacian matrix, non-backtracking matrix    community:  modularity, community detection, core-periphery, clustering coefficients    distance within graphs:  eccentricity, diameter, periphery, radius, center    distance between graphs:  spectral_distance, edit_distance", 
            "title": "Ready to explore"
        }, 
        {
            "location": "/graph_types/", 
            "text": "Graph Types and Constructors\n\n\nErdos.jl\n defines a type hierarchy and associated methods for expressing a graph topology and implementing related algorithms. The ready to go graph types are the \nGraph\n type for undirected graphs and the \nDiGraph\n type for directed graphs. Custom types con be defined inheriting from the abstract types \nAGraph\n and \nADiGraph\n. Graph types supporting the internal storages of edge/vertex properties are called \nnetworks\n in Erdos and are documeted \nhere\n\n\n\n\nAbstract Types\n\n\n#\n\n\nErdos.AGraph\n \n \nType\n.\n\n\nabstract type AGraph end\n\n\n\n\nAbstract undirected graph type\n\n\nsource\n\n\n#\n\n\nErdos.ADiGraph\n \n \nType\n.\n\n\nabstract ADiGraph\n\n\n\n\nAbstract directed graph type\n\n\nsource\n\n\n#\n\n\nErdos.AGraphOrDiGraph\n \n \nConstant\n.\n\n\nconst AGraphOrDiGraph = Union{AGraph, ADiGraph}\n\n\n\n\nUnion of \nAGraph\n and \nADiGraph\n.\n\n\nsource\n\n\n#\n\n\nErdos.AEdge\n \n \nType\n.\n\n\nabstract type AEdge end\n\n\n\n\nAn abstract edge type.\n\n\nsource\n\n\n\n\nGraph / DiGraph / Edge\n\n\n#\n\n\nErdos.Graph\n \n \nType\n.\n\n\nmutable struct Graph{T\n:Integer} \n: AGraph\n    ne::Int\n    fadjlist::Vector{Vector{T}}\nend\n\n\n\n\nA simple graph type based on an adjacency list.\n\n\nGraph{T}(n=0)\nGraph(n=0) = Graph{Int}(n)\n\n\n\n\nConstruct a \nGraph\n with \nn\n vertices and no edges.\n\n\nGraph{T}(adjmx::AbstractMatrix; upper=false, selfedges=true)\n\n\n\n\nConstruct a \nGraph{T}\n from the adjacency matrix \nadjmx\n, placing an edge in correspondence to each nonzero element of \nadjmx\n. If \nselfedges=false\n the diagonal elements of \nadjmx\n are ignored. If \nupper=true\n only the upper triangular part of \nadjmx\n is considered.\n\n\nsource\n\n\n#\n\n\nErdos.DiGraph\n \n \nType\n.\n\n\nmutable struct DiGraph{T\n:Integer} \n: ADiGraph\n    ne::Int\n    fadjlist::Vector{Vector{T}}\n    badjlist::Vector{Vector{T}}\nend\n\n\n\n\nA simple digraph type based on two adjacency lists (forward and backward).\n\n\nDiGraph{T}(n=0)\nDiGraph(n=0) = DiGraph{Int}(n)\n\n\n\n\nConstruct a \nDiGraph\n with \nn\n vertices and no edges.\n\n\nDiGraph{T}(adjmx::AbstractMatrix; selfedges=true)\n\n\n\n\nConstruct a \nDiGraph{T}\n from the adjacency matrix \nadjmx\n, placing an edge in correspondence to each nonzero element of \nadjmx\n. If \nselfedges=false\n the diagonal elements of \nadjmx\n are ignored.\n\n\nsource\n\n\n#\n\n\nErdos.Edge\n \n \nType\n.\n\n\nstruct Edge\n    src::Int\n    dst::Int\nend\n\n\n\n\nA type representing an edge between two vertices of a graph.\n\n\nsource\n\n\n\n\nDefining new types\n\n\nIn order to define a custom graph type, e.g. \nMyGraph \n: AGraph\n, some guarantee have to be respected and some methods have to be exposed. Take a look to the files in \nsrc/factory/\n for some examples. Custom edges, e.g. \nMyEdge \n: AEdge\n,  have to expose \nsrc(e)\n and \ndst(e)\n methods.\n\n\nGuarantees\n:\n\n\n\n\nvertices are integers in 1:nv(g)\n\n\n\n\nMandatory methods\n:\n\n\n\n\nbasic constructors: MyGraph(n), MyGraph())\n\n\nnv(g)\n\n\nne(g)\n\n\nout_neighbors(g, v)\n\n\nin_neighbors(g, v) #digraph\n\n\nedge(g, u, v)\n\n\nadd_edge!(g, u, v)\n\n\nrem_edge!(g, u, v)\n\n\nadd_vertex!(g)\n\n\npop_vertex!(g)\n\n\ngraphtype(g)\n\n\ndigraphtype(g)\n\n\nedgetype(g)\n\n\nvertextype(g)\n\n\nswap_vertices!(g, u, v)\n\n\n\n\nSome methods have general fallbacks relying on the more foundamental API described above, but could probably made more efficient knowing the internal implementation of the graph.\n\n\nReccomended overrides\n:\n\n\n\n\nin_adjlist(g) #digraph\n\n\nout_adjlist(g)\n\n\nhas_edge(g, u, v)\n\n\n==(g, h)\n\n\nout_edges(g, u)\n\n\nin_edges(g, u) # digraph\n\n\nrem_edge!(g, e)\n\n\ngraph(dg)\n\n\ndigraph(g)\n\n\nreverse!(g) #digraph\n\n\nunsafe_add_edge!(g, u, v)\n\n\nrebuild!(g)\n\n\nrem_vertex!(g, v)", 
            "title": "Graph Types"
        }, 
        {
            "location": "/graph_types/#graph-types-and-constructors", 
            "text": "Erdos.jl  defines a type hierarchy and associated methods for expressing a graph topology and implementing related algorithms. The ready to go graph types are the  Graph  type for undirected graphs and the  DiGraph  type for directed graphs. Custom types con be defined inheriting from the abstract types  AGraph  and  ADiGraph . Graph types supporting the internal storages of edge/vertex properties are called  networks  in Erdos and are documeted  here", 
            "title": "Graph Types and Constructors"
        }, 
        {
            "location": "/graph_types/#abstract-types", 
            "text": "#  Erdos.AGraph     Type .  abstract type AGraph end  Abstract undirected graph type  source  #  Erdos.ADiGraph     Type .  abstract ADiGraph  Abstract directed graph type  source  #  Erdos.AGraphOrDiGraph     Constant .  const AGraphOrDiGraph = Union{AGraph, ADiGraph}  Union of  AGraph  and  ADiGraph .  source  #  Erdos.AEdge     Type .  abstract type AEdge end  An abstract edge type.  source", 
            "title": "Abstract Types"
        }, 
        {
            "location": "/graph_types/#graph-digraph-edge", 
            "text": "#  Erdos.Graph     Type .  mutable struct Graph{T :Integer}  : AGraph\n    ne::Int\n    fadjlist::Vector{Vector{T}}\nend  A simple graph type based on an adjacency list.  Graph{T}(n=0)\nGraph(n=0) = Graph{Int}(n)  Construct a  Graph  with  n  vertices and no edges.  Graph{T}(adjmx::AbstractMatrix; upper=false, selfedges=true)  Construct a  Graph{T}  from the adjacency matrix  adjmx , placing an edge in correspondence to each nonzero element of  adjmx . If  selfedges=false  the diagonal elements of  adjmx  are ignored. If  upper=true  only the upper triangular part of  adjmx  is considered.  source  #  Erdos.DiGraph     Type .  mutable struct DiGraph{T :Integer}  : ADiGraph\n    ne::Int\n    fadjlist::Vector{Vector{T}}\n    badjlist::Vector{Vector{T}}\nend  A simple digraph type based on two adjacency lists (forward and backward).  DiGraph{T}(n=0)\nDiGraph(n=0) = DiGraph{Int}(n)  Construct a  DiGraph  with  n  vertices and no edges.  DiGraph{T}(adjmx::AbstractMatrix; selfedges=true)  Construct a  DiGraph{T}  from the adjacency matrix  adjmx , placing an edge in correspondence to each nonzero element of  adjmx . If  selfedges=false  the diagonal elements of  adjmx  are ignored.  source  #  Erdos.Edge     Type .  struct Edge\n    src::Int\n    dst::Int\nend  A type representing an edge between two vertices of a graph.  source", 
            "title": "Graph / DiGraph / Edge"
        }, 
        {
            "location": "/graph_types/#defining-new-types", 
            "text": "In order to define a custom graph type, e.g.  MyGraph  : AGraph , some guarantee have to be respected and some methods have to be exposed. Take a look to the files in  src/factory/  for some examples. Custom edges, e.g.  MyEdge  : AEdge ,  have to expose  src(e)  and  dst(e)  methods.  Guarantees :   vertices are integers in 1:nv(g)   Mandatory methods :   basic constructors: MyGraph(n), MyGraph())  nv(g)  ne(g)  out_neighbors(g, v)  in_neighbors(g, v) #digraph  edge(g, u, v)  add_edge!(g, u, v)  rem_edge!(g, u, v)  add_vertex!(g)  pop_vertex!(g)  graphtype(g)  digraphtype(g)  edgetype(g)  vertextype(g)  swap_vertices!(g, u, v)   Some methods have general fallbacks relying on the more foundamental API described above, but could probably made more efficient knowing the internal implementation of the graph.  Reccomended overrides :   in_adjlist(g) #digraph  out_adjlist(g)  has_edge(g, u, v)  ==(g, h)  out_edges(g, u)  in_edges(g, u) # digraph  rem_edge!(g, e)  graph(dg)  digraph(g)  reverse!(g) #digraph  unsafe_add_edge!(g, u, v)  rebuild!(g)  rem_vertex!(g, v)", 
            "title": "Defining new types"
        }, 
        {
            "location": "/core/", 
            "text": "Basic Interface\n\n\nErdos.jl\n defines the following basic  functionalities:\n\n\n#\n\n\nErdos.nv\n \n \nFunction\n.\n\n\nnv(g)\n\n\n\n\nThe number of vertices in \ng\n.\n\n\nsource\n\n\n#\n\n\nErdos.ne\n \n \nFunction\n.\n\n\nne(g)\n\n\n\n\nThe number of edges in \ng\n.\n\n\nTime Complexity: O(1)\n\n\nsource\n\n\n#\n\n\nErdos.add_vertex!\n \n \nFunction\n.\n\n\nadd_vertex!(g)\n\n\n\n\nAdd a new vertex to the graph \ng\n.\n\n\nsource\n\n\n#\n\n\nErdos.add_vertices!\n \n \nFunction\n.\n\n\nadd_vertices!(g, n)\n\n\n\n\nAdd \nn\n new vertices to the graph \ng\n. Returns the final number of vertices.\n\n\nsource\n\n\n#\n\n\nErdos.rem_vertex!\n \n \nFunction\n.\n\n\nrem_vertex!(g, v)\n\n\n\n\nRemove the vertex \nv\n from graph \ng\n. It will change the label of the last vertex of the old graph to \nv\n.\n\n\nSee also \nrem_vertices!\n.\n\n\nsource\n\n\n#\n\n\nErdos.pop_vertex!\n \n \nFunction\n.\n\n\npop_vertex!(g)\n\n\n\n\nRemove the last vertex of \ng\n. Equivalent to rem_vertex!(g, nv(g)).\n\n\nsource\n\n\n#\n\n\nErdos.rem_vertices!\n \n \nFunction\n.\n\n\nrem_vertices!(g, vs)\nrem_vertices!(g, v1, v2, ....)\n\n\n\n\nRemove the vertices in \nvs\n from graph \ng\n.\n\n\nSome vertices of \ng\n may be reindexed during the removal. To keep track of the reindexing, a vertex map is returned, associating vertices with changed indexes to their old indexes.\n\n\nsource\n\n\n#\n\n\nErdos.has_edge\n \n \nFunction\n.\n\n\nhas_edge(g, e)\nhas_edge(g, u, v)\n\n\n\n\nReturns true if the graph \ng\n has an edge \ne\n (from \nu\n to \nv\n).\n\n\nsource\n\n\n#\n\n\nErdos.src\n \n \nFunction\n.\n\n\nsrc(e)\n\n\n\n\nReturns the source of an edge.\n\n\nsource\n\n\n#\n\n\nErdos.dst\n \n \nFunction\n.\n\n\ndst(e)\n\n\n\n\nReturns the destination of an edge.\n\n\nsource\n\n\n#\n\n\nErdos.edge\n \n \nFunction\n.\n\n\nedge(g, u, v)\n\n\n\n\nReturns an edge from 'u' to 'v'. The edge doesn't necessarily exists in \ng\n.\n\n\nsource\n\n\n#\n\n\nErdos.add_edge!\n \n \nFunction\n.\n\n\nadd_edge!(g, e) -\n (ok, new_edge)\n\n\n\n\nAdd to \ng\n the edge \ne\n.\n\n\nadd_edge!(g, u, v) -\n (ok, new_edge)\n\n\n\n\nAdd to \ng\n an edge from \nu\n to \nv\n.\n\n\nok=false\n if add fails (e.g. if vertices are not in the graph or the edge is already present) and \ntrue\n otherwise. \nnew_edge\n is the descriptor of the new edge.\n\n\nsource\n\n\n#\n\n\nErdos.unsafe_add_edge!\n \n \nFunction\n.\n\n\nunsafe_add_edge!(g, u, v)\n\n\n\n\nPossibly faster and unsafer version of \nadd_edge!\n, which doesn't guarantee some graph invariant properties.\n\n\nFor example, some graph types (e.g. \nGraph\n) assume sorted adjacency lists as members. In this case order is not preserved while inserting new edges, resulting in a faster construction of the graph. As a consequence though, some functions such \nhas_edge(g, u, v)\n could give incorrect results.\n\n\nTo restore the correct behaviour, call \nrebuild!\n(g) after the last call to \nunsafe_add_edge!\n.\n\n\nsource\n\n\n#\n\n\nErdos.rebuild!\n \n \nFunction\n.\n\n\nrebuild!(g)\n\n\n\n\nCheck and restore the structure of \ng\n, which could be corrupted by the use of unsafe functions (e. g. \nunsafe_add_edge!\n)\n\n\nsource\n\n\n#\n\n\nErdos.rem_edge!\n \n \nFunction\n.\n\n\nrem_edge!(g, e)\n\n\n\n\nRemove the edge \ne\n.\n\n\nrem_edge!(g, u, v)\n\n\n\n\nRemove the edge from \nu\n to \nv\n.\n\n\nReturns false if edge removal fails (e.g., if the edge does not exist) and true otherwise.\n\n\nsource\n\n\n#\n\n\nErdos.degree\n \n \nFunction\n.\n\n\ndegree(g, v)\n\n\n\n\nReturn the number of edges  from the vertex \nv\n.\n\n\nsource\n\n\n#\n\n\nErdos.in_degree\n \n \nFunction\n.\n\n\nin_degree(g, v)\n\n\n\n\nReturns the number of edges which start at vertex \nv\n.\n\n\nsource\n\n\n#\n\n\nErdos.out_degree\n \n \nFunction\n.\n\n\nout_degree(g, v)\n\n\n\n\nReturns the number of edges which end at vertex \nv\n.\n\n\nsource\n\n\n#\n\n\nErdos.neighbors\n \n \nFunction\n.\n\n\nneighbors(g, v)\n\n\n\n\nReturns a list of all neighbors from vertex \nv\n in \ng\n.\n\n\nFor directed graph, this is equivalent to \nout_neighbors\n(g, v).\n\n\nNOTE: it may return a reference, not a copy. Do not modify result.\n\n\nsource\n\n\n#\n\n\nErdos.in_neighbors\n \n \nFunction\n.\n\n\nin_neighbors(g, v)\n\n\n\n\nReturns an iterable to all neighbors connected to vertex \nv\n by an incoming edge.\n\n\nNOTE: it may return a reference, not a copy. Do not modify result.\n\n\nsource\n\n\n#\n\n\nErdos.out_neighbors\n \n \nFunction\n.\n\n\nout_neighbors(g::AGraphOrDiGraph, v)\n\n\n\n\nReturns an iterable to all neighbors connected to vertex \nv\n by an outgoing edge.\n\n\nNOTE: it may return a reference, not a copy. Do not modify result.\n\n\nsource\n\n\n#\n\n\nErdos.all_neighbors\n \n \nFunction\n.\n\n\nall_neighbors(g, v)\n\n\n\n\nIterates over all distinct in/out neighbors of vertex \nv\n in \ng\n.\n\n\nsource\n\n\n#\n\n\nErdos.edges\n \n \nFunction\n.\n\n\nedges(g, v)\n\n\n\n\nReturns an iterator to the edges in \ng\n coming from vertex \nv\n. \nv == src(e)\n for each returned edge \ne\n.\n\n\nIt is equivalent to \nout_edges\n.\n\n\nFor digraphs, use \nall_edges\n to iterate over both in and out edges.\n\n\nsource\n\n\nedges(g)\n\n\n\n\nReturns an iterator to the edges of a graph \ng\n. The returned iterator is invalidated by changes to \ng\n.\n\n\nsource\n\n\n#\n\n\nErdos.in_edges\n \n \nFunction\n.\n\n\nin_edges(g, v)\n\n\n\n\nReturns an iterator to the edges in \ng\n going to vertex \nv\n. \nv == dst(e)\n for each returned edge \ne\n.\n\n\nsource\n\n\n#\n\n\nErdos.out_edges\n \n \nFunction\n.\n\n\nout_edges(g, v)\n\n\n\n\nReturns an iterator to the edges in \ng\n coming from vertex \nv\n. \nv == src(e)\n for each returned edge \ne\n.\n\n\nsource\n\n\n#\n\n\nErdos.all_edges\n \n \nFunction\n.\n\n\nall_edges(g, v)\n\n\n\n\nIterates over all in and out edges of vertex \nv\n in \ng\n.\n\n\nsource\n\n\n#\n\n\nErdos.swap_vertices!\n \n \nFunction\n.\n\n\nswap_vertices!(g, u, v)\n\n\n\n\nSwap the labels of vertices \nu\n and \nv\n. In the new graph all old neighbors of vertex \nu\n will be neighbors of \nv\n and viceversa.\n\n\nsource\n\n\n#\n\n\nErdos.has_vertex\n \n \nFunction\n.\n\n\nhas_vertex(g, v)\n\n\n\n\nReturn true if \nv\n is a vertex of \ng\n.\n\n\nsource\n\n\n#\n\n\nErdos.is_directed\n \n \nFunction\n.\n\n\nis_directed(g)\n\n\n\n\nCheck if \ng\n a graph with directed edges.\n\n\nsource\n\n\n#\n\n\nBase.reverse\n \n \nFunction\n.\n\n\nreverse(e)\n\n\n\n\nReturns an edge with swapped \nsrc(e)\n and \ndst(e)\n.\n\n\nsource\n\n\nreverse(g::ADiGraph)\n\n\n\n\nProduces a graph where all edges are reversed from the original.\n\n\nsource\n\n\n#\n\n\nBase.reverse!\n \n \nFunction\n.\n\n\nreverse!(g::DiGraph)\n\n\n\n\nIn-place reverse (modifies the original graph).\n\n\nsource\n\n\n#\n\n\nErdos.adjacency_list\n \n \nFunction\n.\n\n\nadjacency_list(g::AGraph)\nadjacency_list(g::ADiGraph, dir=:out)\n\n\n\n\nReturns the adjacency list \na\n of a graph (a vector of vector of ints). The \ni\n-th element of the adjacency list is a vector containing the neighbors of \ni\n in \ng\n.\n\n\nFor directed graphs a second optional argument can be specified (\n:out\n or \n:in\n). The neighbors in the returned adjacency list are considered accordingly as those related through outgoing or incoming edges.\n\n\nThe elements of  \na[i]\n have the same order as in the iterator \n(out_/in_)neighbors(g,i)\n.\n\n\nAttention\n: For some graph types it returns a reference, not a copy, therefore the returned object should not be modified.\n\n\nsource\n\n\n#\n\n\nErdos.clean_vertex!\n \n \nFunction\n.\n\n\nclean_vertex!(g, v)\n\n\n\n\nRemove all incident edges on vertex \nv\n in \ng\n.\n\n\nsource\n\n\n#\n\n\nErdos.density\n \n \nFunction\n.\n\n\ndensity(g)\n\n\n\n\nDensity is defined as the ratio of the number of actual edges to the number of possible edges. This is $|v| |v-1|$ for directed graphs and $(|v| |v-1|) / 2$ for undirected graphs.\n\n\nsource\n\n\n#\n\n\nErdos.vertices\n \n \nFunction\n.\n\n\nvertices(g)\n\n\n\n\nReturns an iterator to the vertices of a graph (i.e. 1:nv(g))\n\n\nsource\n\n\n#\n\n\nErdos.has_self_loops\n \n \nFunction\n.\n\n\nhas_self_loops(g)\n\n\n\n\nReturns true if \ng\n has any self loops.\n\n\nsource\n\n\n#\n\n\nErdos.num_self_loops\n \n \nFunction\n.\n\n\nnum_self_loops(g)\n\n\n\n\nReturns the number of self loops in \ng\n.\n\n\nsource\n\n\n#\n\n\nErdos.is_graphical\n \n \nFunction\n.\n\n\nis_graphical(degs::Vector{Int})\n\n\n\n\nCheck whether the degree sequence \ndegs\n is graphical, according to \nErd\u00f6s-Gallai condition\n.\n\n\nTime complexity: O(length(degs)^2)\n\n\nsource\n\n\n#\n\n\nErdos.graph\n \n \nFunction\n.\n\n\ngraph{G\n:AGraph}(n, edgelist::Vector{Tuple{Int,Int}},\n    G = Graph)\n\n\n\n\nBuild a graph with \nn\n vertices, of type \nG\n, and given \nedgelist\n.\n\n\nsource\n\n\ngraph(s::Symbol, G = Graph)\n\n\n\n\nCreates a notorious graph \ns\n of type \nG\n. Admissible values for \ns\n are:\n\n\n\n\n\n\n\n\ns\n\n\ngraph type\n\n\n\n\n\n\n\n\n\n\n:bull\n\n\nA \nbull graph\n.\n\n\n\n\n\n\n:chvatal\n\n\nA \nChv\u00e1tal graph\n.\n\n\n\n\n\n\n:cubical\n\n\nA \nPlatonic cubical graph\n.\n\n\n\n\n\n\n:desargues\n\n\nA \nDesarguesgraph\n.\n\n\n\n\n\n\n:diamond\n\n\nA \ndiamond graph\n.\n\n\n\n\n\n\n:dodecahedral\n\n\nA \nPlatonic dodecahedral  graph\n.\n\n\n\n\n\n\n:frucht\n\n\nA \nFrucht graph\n.\n\n\n\n\n\n\n:heawood\n\n\nA \nHeawood graph\n.\n\n\n\n\n\n\n:house\n\n\nA graph mimicing the classic outline of a house.\n\n\n\n\n\n\n:housex\n\n\nA house graph, with two edges crossing the bottom square.\n\n\n\n\n\n\n:icosahedral\n\n\nA \nPlatonic icosahedral   graph\n.\n\n\n\n\n\n\n:krackhardtkite\n\n\nA \nKrackhardt-Kite social network  graph\n.\n\n\n\n\n\n\n:moebiuskantor\n\n\nA \nM\u00f6bius-Kantor graph\n.\n\n\n\n\n\n\n:octahedral\n\n\nA \nPlatonic octahedral graph\n.\n\n\n\n\n\n\n:pappus\n\n\nA \nPappus graph\n.\n\n\n\n\n\n\n:petersen\n\n\nA \nPetersen graph\n.\n\n\n\n\n\n\n:sedgewickmaze\n\n\nA simple maze graph used in Sedgewick's \nAlgorithms in C++: Graph  Algorithms (3rd ed.)\n\n\n\n\n\n\n:tetrahedral\n\n\nA \nPlatonic tetrahedral  graph\n.\n\n\n\n\n\n\n:truncatedcube\n\n\nA skeleton of the \ntruncated cube graph\n.\n\n\n\n\n\n\n:truncatedtetrahedron\n\n\nA skeleton of the \ntruncated tetrahedron  graph\n.\n\n\n\n\n\n\n:tutte\n\n\nA \nTutte graph\n.\n\n\n\n\n\n\n\n\nA collection of real world graphs is available through the \nreadgraph\n function.\n\n\nsource\n\n\n#\n\n\nErdos.digraph\n \n \nFunction\n.\n\n\ndigraph{G\n:AGraph}(n, edgelist::Vector{Tuple{Int,Int}},\n    G = Graph)\n\n\n\n\nBuild a digraph with \nn\n vertices, type \nG\n, and given \nedgelist\n.\n\n\nsource\n\n\ndigraph(s::Symbol, G = DiGraph)\n\n\n\n\nCreates a notorious digraph \ns\n of type \nG\n. Admissible values for \ns\n are:\n\n\n\n\n\n\n\n\ns\n\n\ngraph type\n\n\n\n\n\n\n\n\n\n\n:truncatedtetrahedron\n\n\nA skeleton of the \ntruncated tetrahedron digraph\n.\n\n\n\n\n\n\n\n\nsource\n\n\n#\n\n\nErdos.edgetype\n \n \nFunction\n.\n\n\nedgetype(g)\nedgetype(G)\n\n\n\n\nReturns the type of edges of graph \ng\n (or graph type \nG\n), i. e. the element type returned of the iterator \nedges(g)\n.\n\n\nsource\n\n\n#\n\n\nErdos.vertextype\n \n \nFunction\n.\n\n\nvertextype(g)\nvertextype(G)\n\n\n\n\nReturns the integer type of vertices of graph \ng\n (or graph type \nG\n).\n\n\nsource\n\n\n#\n\n\nErdos.graphtype\n \n \nFunction\n.\n\n\ngraphtype{G\n:AGraphOrDiGraph}(::Type{G})\n\n\n\n\nThe graph type corresponding to \nG\n. If \nG\n:AGraph\n returns \nG\n, if \nG\n:ADiGraph\n returns a type \nH\n:AGraph\n.\n\n\nsource\n\n\n#\n\n\nErdos.digraphtype\n \n \nFunction\n.\n\n\ndigraphtype{G\n:AGraphOrDiGraph}(::Type{G})\n\n\n\n\nThe digraph type corresponding to \nG\n. If \nG\n:ADiGraph\n returns \nG\n, if \nG\n:AGraph\n returns a type \nH\n:ADiGraph\n.\n\n\nsource", 
            "title": "Basic Interface"
        }, 
        {
            "location": "/core/#basic-interface", 
            "text": "Erdos.jl  defines the following basic  functionalities:  #  Erdos.nv     Function .  nv(g)  The number of vertices in  g .  source  #  Erdos.ne     Function .  ne(g)  The number of edges in  g .  Time Complexity: O(1)  source  #  Erdos.add_vertex!     Function .  add_vertex!(g)  Add a new vertex to the graph  g .  source  #  Erdos.add_vertices!     Function .  add_vertices!(g, n)  Add  n  new vertices to the graph  g . Returns the final number of vertices.  source  #  Erdos.rem_vertex!     Function .  rem_vertex!(g, v)  Remove the vertex  v  from graph  g . It will change the label of the last vertex of the old graph to  v .  See also  rem_vertices! .  source  #  Erdos.pop_vertex!     Function .  pop_vertex!(g)  Remove the last vertex of  g . Equivalent to rem_vertex!(g, nv(g)).  source  #  Erdos.rem_vertices!     Function .  rem_vertices!(g, vs)\nrem_vertices!(g, v1, v2, ....)  Remove the vertices in  vs  from graph  g .  Some vertices of  g  may be reindexed during the removal. To keep track of the reindexing, a vertex map is returned, associating vertices with changed indexes to their old indexes.  source  #  Erdos.has_edge     Function .  has_edge(g, e)\nhas_edge(g, u, v)  Returns true if the graph  g  has an edge  e  (from  u  to  v ).  source  #  Erdos.src     Function .  src(e)  Returns the source of an edge.  source  #  Erdos.dst     Function .  dst(e)  Returns the destination of an edge.  source  #  Erdos.edge     Function .  edge(g, u, v)  Returns an edge from 'u' to 'v'. The edge doesn't necessarily exists in  g .  source  #  Erdos.add_edge!     Function .  add_edge!(g, e) -  (ok, new_edge)  Add to  g  the edge  e .  add_edge!(g, u, v) -  (ok, new_edge)  Add to  g  an edge from  u  to  v .  ok=false  if add fails (e.g. if vertices are not in the graph or the edge is already present) and  true  otherwise.  new_edge  is the descriptor of the new edge.  source  #  Erdos.unsafe_add_edge!     Function .  unsafe_add_edge!(g, u, v)  Possibly faster and unsafer version of  add_edge! , which doesn't guarantee some graph invariant properties.  For example, some graph types (e.g.  Graph ) assume sorted adjacency lists as members. In this case order is not preserved while inserting new edges, resulting in a faster construction of the graph. As a consequence though, some functions such  has_edge(g, u, v)  could give incorrect results.  To restore the correct behaviour, call  rebuild! (g) after the last call to  unsafe_add_edge! .  source  #  Erdos.rebuild!     Function .  rebuild!(g)  Check and restore the structure of  g , which could be corrupted by the use of unsafe functions (e. g.  unsafe_add_edge! )  source  #  Erdos.rem_edge!     Function .  rem_edge!(g, e)  Remove the edge  e .  rem_edge!(g, u, v)  Remove the edge from  u  to  v .  Returns false if edge removal fails (e.g., if the edge does not exist) and true otherwise.  source  #  Erdos.degree     Function .  degree(g, v)  Return the number of edges  from the vertex  v .  source  #  Erdos.in_degree     Function .  in_degree(g, v)  Returns the number of edges which start at vertex  v .  source  #  Erdos.out_degree     Function .  out_degree(g, v)  Returns the number of edges which end at vertex  v .  source  #  Erdos.neighbors     Function .  neighbors(g, v)  Returns a list of all neighbors from vertex  v  in  g .  For directed graph, this is equivalent to  out_neighbors (g, v).  NOTE: it may return a reference, not a copy. Do not modify result.  source  #  Erdos.in_neighbors     Function .  in_neighbors(g, v)  Returns an iterable to all neighbors connected to vertex  v  by an incoming edge.  NOTE: it may return a reference, not a copy. Do not modify result.  source  #  Erdos.out_neighbors     Function .  out_neighbors(g::AGraphOrDiGraph, v)  Returns an iterable to all neighbors connected to vertex  v  by an outgoing edge.  NOTE: it may return a reference, not a copy. Do not modify result.  source  #  Erdos.all_neighbors     Function .  all_neighbors(g, v)  Iterates over all distinct in/out neighbors of vertex  v  in  g .  source  #  Erdos.edges     Function .  edges(g, v)  Returns an iterator to the edges in  g  coming from vertex  v .  v == src(e)  for each returned edge  e .  It is equivalent to  out_edges .  For digraphs, use  all_edges  to iterate over both in and out edges.  source  edges(g)  Returns an iterator to the edges of a graph  g . The returned iterator is invalidated by changes to  g .  source  #  Erdos.in_edges     Function .  in_edges(g, v)  Returns an iterator to the edges in  g  going to vertex  v .  v == dst(e)  for each returned edge  e .  source  #  Erdos.out_edges     Function .  out_edges(g, v)  Returns an iterator to the edges in  g  coming from vertex  v .  v == src(e)  for each returned edge  e .  source  #  Erdos.all_edges     Function .  all_edges(g, v)  Iterates over all in and out edges of vertex  v  in  g .  source  #  Erdos.swap_vertices!     Function .  swap_vertices!(g, u, v)  Swap the labels of vertices  u  and  v . In the new graph all old neighbors of vertex  u  will be neighbors of  v  and viceversa.  source  #  Erdos.has_vertex     Function .  has_vertex(g, v)  Return true if  v  is a vertex of  g .  source  #  Erdos.is_directed     Function .  is_directed(g)  Check if  g  a graph with directed edges.  source  #  Base.reverse     Function .  reverse(e)  Returns an edge with swapped  src(e)  and  dst(e) .  source  reverse(g::ADiGraph)  Produces a graph where all edges are reversed from the original.  source  #  Base.reverse!     Function .  reverse!(g::DiGraph)  In-place reverse (modifies the original graph).  source  #  Erdos.adjacency_list     Function .  adjacency_list(g::AGraph)\nadjacency_list(g::ADiGraph, dir=:out)  Returns the adjacency list  a  of a graph (a vector of vector of ints). The  i -th element of the adjacency list is a vector containing the neighbors of  i  in  g .  For directed graphs a second optional argument can be specified ( :out  or  :in ). The neighbors in the returned adjacency list are considered accordingly as those related through outgoing or incoming edges.  The elements of   a[i]  have the same order as in the iterator  (out_/in_)neighbors(g,i) .  Attention : For some graph types it returns a reference, not a copy, therefore the returned object should not be modified.  source  #  Erdos.clean_vertex!     Function .  clean_vertex!(g, v)  Remove all incident edges on vertex  v  in  g .  source  #  Erdos.density     Function .  density(g)  Density is defined as the ratio of the number of actual edges to the number of possible edges. This is $|v| |v-1|$ for directed graphs and $(|v| |v-1|) / 2$ for undirected graphs.  source  #  Erdos.vertices     Function .  vertices(g)  Returns an iterator to the vertices of a graph (i.e. 1:nv(g))  source  #  Erdos.has_self_loops     Function .  has_self_loops(g)  Returns true if  g  has any self loops.  source  #  Erdos.num_self_loops     Function .  num_self_loops(g)  Returns the number of self loops in  g .  source  #  Erdos.is_graphical     Function .  is_graphical(degs::Vector{Int})  Check whether the degree sequence  degs  is graphical, according to  Erd\u00f6s-Gallai condition .  Time complexity: O(length(degs)^2)  source  #  Erdos.graph     Function .  graph{G :AGraph}(n, edgelist::Vector{Tuple{Int,Int}},\n    G = Graph)  Build a graph with  n  vertices, of type  G , and given  edgelist .  source  graph(s::Symbol, G = Graph)  Creates a notorious graph  s  of type  G . Admissible values for  s  are:     s  graph type      :bull  A  bull graph .    :chvatal  A  Chv\u00e1tal graph .    :cubical  A  Platonic cubical graph .    :desargues  A  Desarguesgraph .    :diamond  A  diamond graph .    :dodecahedral  A  Platonic dodecahedral  graph .    :frucht  A  Frucht graph .    :heawood  A  Heawood graph .    :house  A graph mimicing the classic outline of a house.    :housex  A house graph, with two edges crossing the bottom square.    :icosahedral  A  Platonic icosahedral   graph .    :krackhardtkite  A  Krackhardt-Kite social network  graph .    :moebiuskantor  A  M\u00f6bius-Kantor graph .    :octahedral  A  Platonic octahedral graph .    :pappus  A  Pappus graph .    :petersen  A  Petersen graph .    :sedgewickmaze  A simple maze graph used in Sedgewick's  Algorithms in C++: Graph  Algorithms (3rd ed.)    :tetrahedral  A  Platonic tetrahedral  graph .    :truncatedcube  A skeleton of the  truncated cube graph .    :truncatedtetrahedron  A skeleton of the  truncated tetrahedron  graph .    :tutte  A  Tutte graph .     A collection of real world graphs is available through the  readgraph  function.  source  #  Erdos.digraph     Function .  digraph{G :AGraph}(n, edgelist::Vector{Tuple{Int,Int}},\n    G = Graph)  Build a digraph with  n  vertices, type  G , and given  edgelist .  source  digraph(s::Symbol, G = DiGraph)  Creates a notorious digraph  s  of type  G . Admissible values for  s  are:     s  graph type      :truncatedtetrahedron  A skeleton of the  truncated tetrahedron digraph .     source  #  Erdos.edgetype     Function .  edgetype(g)\nedgetype(G)  Returns the type of edges of graph  g  (or graph type  G ), i. e. the element type returned of the iterator  edges(g) .  source  #  Erdos.vertextype     Function .  vertextype(g)\nvertextype(G)  Returns the integer type of vertices of graph  g  (or graph type  G ).  source  #  Erdos.graphtype     Function .  graphtype{G :AGraphOrDiGraph}(::Type{G})  The graph type corresponding to  G . If  G :AGraph  returns  G , if  G :ADiGraph  returns a type  H :AGraph .  source  #  Erdos.digraphtype     Function .  digraphtype{G :AGraphOrDiGraph}(::Type{G})  The digraph type corresponding to  G . If  G :ADiGraph  returns  G , if  G :AGraph  returns a type  H :ADiGraph .  source", 
            "title": "Basic Interface"
        }, 
        {
            "location": "/maps/", 
            "text": "Edge and Vertex Maps\n\n\nArbitrary values can be associated to a graph's vertices and edges, and handed over to method's that necessitate them, thanks to the edge maps and vertex maps interfaces. Also, edge and vector maps can be internally stored in \nnetwork types\n and accessed through the \nproperty interface\n.\n\n\n\n\nEdge Maps\n\n\n#\n\n\nErdos.ConstEdgeMap\n \n \nType\n.\n\n\nstruct ConstEdgeMap{T} \n: SimpleEdgeMap{T}\n    val::T\nend\n\n\n\n\nA type representing a constant vector map. Any attempt to change the internal value, e.g. \nemap[u,v] = 4\n, will fail silently.\n\n\nsource\n\n\n#\n\n\nErdos.EdgeMap\n \n \nType\n.\n\n\nmutable struct EdgeMap{G \n: AGraphOrDiGraph, T, D} \n: AEdgeMap{T}\n    g::G\n    vtype::Type{T}\n    data::D\nend\n\n\n\n\nType implementing an edge map. The underlying container \ndata\n can be a dictionary, a matrix or a vector (for graphs with indexed edges).\n\n\nEdgeMap{T}(g, ::Type{T})\n\n\n\n\nReturns a map that associates values of type \nT\n to the vertices of  graph \ng\n. The underlying storage structures is chosen accordingly.\n\n\nEdgeMap(g, data)\n\n\n\n\nConstruct a EdgeMap with \ndata\n as underlying storage. The storage type can be a matrix or an associative \nedg =\n val\n type or a vector for graph with indexed edges.\n\n\nEdgeMap(g, f)\n\n\n\n\nConstruct an edge map with value \nf(e)\n for each \ne\n in \nedges(g)\n.\n\n\nsource\n\n\n#\n\n\nErdos.edgemap2adjlist\n \n \nMethod\n.\n\n\nedgemap2adjlist(emap)\n\n\n\n\nReturns a vector of vectors containing the values of the edge map \nemap\n on graph \ng\n following the same ordering of \nadjacency_list\n(g)\n.\n\n\nsource\n\n\n\n\nVertex Maps\n\n\nAny \nAbstractVector{T}\n or \nDict{Int,T}\n can be used as a vertex map.\n\n\n#\n\n\nErdos.ConstVertexMap\n \n \nType\n.\n\n\nstruct ConstVertexMap{T} \n: AVertexMap{T}\n    val::T\nend\n\n\n\n\nA type representing a constant vector map. Any attempt to change the internal value, e.g. \nvm[1] = 4\n, will fail silently.\n\n\nsource\n\n\n#\n\n\nErdos.VertexMap\n \n \nType\n.\n\n\nmutable struct VertexMap{G \n: AGraphOrDiGraph, T, D} \n: AVertexMap{T}\n    g::G\n    vtype::Type{T}\n    data::D\nend\n\n\n\n\nType implementing an edge map. The underlying container \ndata\n can be a dictionary or a vector.\n\n\nVertexMap{T}(g, ::Type{T})\n\n\n\n\nReturns a map that associates values of type \nT\n to the vertices of  graph \ng\n. The underlying storage structures is chosen accordingly.\n\n\nVertexMap(g, data)\n\n\n\n\nConstruct a VertexMap with \ndata\n as underlying storage.\n\n\nVertexMap(g, f)\n\n\n\n\nConstruct a vertex map with value \nf(u)\n for each \nu=1:nv(g)\n.\n\n\nsource\n\n\n\n\nPropertyStore\n\n\n#\n\n\nErdos.PropertyStore\n \n \nType\n.\n\n\nmutable struct PropertyStore\n    gmaps::Dict{String, Any}\n    emaps::Dict{String,AEdgeMap}\n    vmaps::Dict{String,AVertexMap}\nend\n\n\n\n\nA type storing properties associated to networks.\n\n\nsource", 
            "title": "Edge And Vertex Maps"
        }, 
        {
            "location": "/maps/#edge-and-vertex-maps", 
            "text": "Arbitrary values can be associated to a graph's vertices and edges, and handed over to method's that necessitate them, thanks to the edge maps and vertex maps interfaces. Also, edge and vector maps can be internally stored in  network types  and accessed through the  property interface .", 
            "title": "Edge and Vertex Maps"
        }, 
        {
            "location": "/maps/#edge-maps", 
            "text": "#  Erdos.ConstEdgeMap     Type .  struct ConstEdgeMap{T}  : SimpleEdgeMap{T}\n    val::T\nend  A type representing a constant vector map. Any attempt to change the internal value, e.g.  emap[u,v] = 4 , will fail silently.  source  #  Erdos.EdgeMap     Type .  mutable struct EdgeMap{G  : AGraphOrDiGraph, T, D}  : AEdgeMap{T}\n    g::G\n    vtype::Type{T}\n    data::D\nend  Type implementing an edge map. The underlying container  data  can be a dictionary, a matrix or a vector (for graphs with indexed edges).  EdgeMap{T}(g, ::Type{T})  Returns a map that associates values of type  T  to the vertices of  graph  g . The underlying storage structures is chosen accordingly.  EdgeMap(g, data)  Construct a EdgeMap with  data  as underlying storage. The storage type can be a matrix or an associative  edg =  val  type or a vector for graph with indexed edges.  EdgeMap(g, f)  Construct an edge map with value  f(e)  for each  e  in  edges(g) .  source  #  Erdos.edgemap2adjlist     Method .  edgemap2adjlist(emap)  Returns a vector of vectors containing the values of the edge map  emap  on graph  g  following the same ordering of  adjacency_list (g) .  source", 
            "title": "Edge Maps"
        }, 
        {
            "location": "/maps/#vertex-maps", 
            "text": "Any  AbstractVector{T}  or  Dict{Int,T}  can be used as a vertex map.  #  Erdos.ConstVertexMap     Type .  struct ConstVertexMap{T}  : AVertexMap{T}\n    val::T\nend  A type representing a constant vector map. Any attempt to change the internal value, e.g.  vm[1] = 4 , will fail silently.  source  #  Erdos.VertexMap     Type .  mutable struct VertexMap{G  : AGraphOrDiGraph, T, D}  : AVertexMap{T}\n    g::G\n    vtype::Type{T}\n    data::D\nend  Type implementing an edge map. The underlying container  data  can be a dictionary or a vector.  VertexMap{T}(g, ::Type{T})  Returns a map that associates values of type  T  to the vertices of  graph  g . The underlying storage structures is chosen accordingly.  VertexMap(g, data)  Construct a VertexMap with  data  as underlying storage.  VertexMap(g, f)  Construct a vertex map with value  f(u)  for each  u=1:nv(g) .  source", 
            "title": "Vertex Maps"
        }, 
        {
            "location": "/maps/#propertystore", 
            "text": "#  Erdos.PropertyStore     Type .  mutable struct PropertyStore\n    gmaps::Dict{String, Any}\n    emaps::Dict{String,AEdgeMap}\n    vmaps::Dict{String,AVertexMap}\nend  A type storing properties associated to networks.  source", 
            "title": "PropertyStore"
        }, 
        {
            "location": "/network_types/", 
            "text": "Network Types and Interface\n\n\nNetworks in \nErdos.jl\n are graphs with additional ability to store properties associated to vertices, edges and the graph itself. The ready to go network types are the \nNetwork\n and \nDiNetwork\n types. Custom types con be defined inheriting from \nANetwork\n and \nADiNetwork\n abstract types.\n\n\n\n\nAbstract Types\n\n\n#\n\n\nErdos.ANetwork\n \n \nType\n.\n\n\nabstract type ANetwork \n: AGraph end\n\n\n\n\nAn abstract graph with the additional possibility to attach properties to vertices and edges.\n\n\nsource\n\n\n#\n\n\nErdos.ADiNetwork\n \n \nType\n.\n\n\nabstract type ADiNetwork \n: ADiGraph end\n\n\n\n\nAn abstract directed graph with the additional possibility to attach properties to vertices and edges.\n\n\nsource\n\n\n#\n\n\nErdos.AIndexedEdge\n \n \nType\n.\n\n\nabstract type AIndexedEdge \n: AEdge end\n\n\n\n\nEdge types with unique indexes, accessed by \nidx\n\n\nsource\n\n\n\n\nNetwork / DiNetwork / IndexedEdge\n\n\n#\n\n\nErdos.Network\n \n \nType\n.\n\n\nmutable struct Network \n: ANetwork\n    ne::Int\n    edge_index_range::Int\n    out_edges::Vector{Vector{Pair{Int,Int}}}  #unordered adjlist\n    epos::Vector{Pair{Int,Int}}    # position of the edge in out_edges\n    free_indexes::Vector{Int}       # indexes of deleted edges to be used up\n                                    # for new edges to avoid very large\n                                    # indexes, and unnecessary property map\n                                    # memory used\n    props::PropertyStore\nend\n\n\n\n\nA type representing a directed graph with indexed edges.\n\n\nNetwork(n=0)\n\n\n\n\nConstruct a \nNetwork\n with \nn\n vertices and no edges.\n\n\nNetwork(adjmx::AbstractMatrix; selfedges=true, upper=false)\n\n\n\n\nConstruct a \nNetwork\n from the adjacency matrix \nadjmx\n, placing an edge in correspondence to each nonzero element of \nadjmx\n. If \nselfedges=false\n the diagonal elements of \nadjmx\n are ignored. If \nupper=true\n only the upper triangular part of \nadjmx\n is considered.\n\n\nsource\n\n\n#\n\n\nErdos.DiNetwork\n \n \nType\n.\n\n\nmutable struct DiNetwork \n: ADiNetwork\n    ne::Int\n    edge_index_range::Int\n    out_edges::Vector{Vector{Pair{Int,Int}}}  #unordered out_adjlist\n    in_edges::Vector{Vector{Pair{Int,Int}}}  #unordered in_adjlist\n\n    epos::Vector{Pair{Int,Int}}    # position of the edge in out_edges\n                                    # the first in the pair is the vertex\n                                    # with lower index\n\n    free_indexes::Vector{Int}       # indexes of deleted edges to be used up\n                                    # for new edges to avoid very large\n                                    # indexes, and unnecessary property map\n                                    # memory use\n    props::PropertyStore\nend\n\n\n\n\nA type representing an directed graph with indexed edges.\n\n\nDiNetwork(n=0)\n\n\n\n\nConstruct a \nDiNetwork\n with \nn\n vertices and no edges.\n\n\nDiNetwork(adjmx::AbstractMatrix; selfedges=true)\n\n\n\n\nConstruct a \nDiNetwork\n from the adjacency matrix \nadjmx\n. If \nselfedges=false\n the diagonal elements of \nadjmx\n are ignored.\n\n\nsource\n\n\n#\n\n\nErdos.IndexedEdge\n \n \nType\n.\n\n\nstruct IndexedEdge \n: AIndexedEdge\n    src::Int\n    dst::Int\n    idx::Int\nend\n\n\n\n\nAn indexed edge type\n\n\nIndexedEdge(u, v) = IndexedEdge(u,v,-1)\n\n\n\n\nCreates an edge with invalid index.\n\n\nsource\n\n\n\n\nDefining new network types\n\n\nIn order to define a custom network type, e.g. \nMyNet \n: ANetwork\n, the corresponding methods in the preceding paragraph have to be implemented. This is automatically done for custom network types having a \nprops::PropertyStore\n member. Take a look to \nsrc/factory/net.jl\n and \nsrc/maps/property_store.jl\n for an example.", 
            "title": "Network Types"
        }, 
        {
            "location": "/network_types/#network-types-and-interface", 
            "text": "Networks in  Erdos.jl  are graphs with additional ability to store properties associated to vertices, edges and the graph itself. The ready to go network types are the  Network  and  DiNetwork  types. Custom types con be defined inheriting from  ANetwork  and  ADiNetwork  abstract types.", 
            "title": "Network Types and Interface"
        }, 
        {
            "location": "/network_types/#abstract-types", 
            "text": "#  Erdos.ANetwork     Type .  abstract type ANetwork  : AGraph end  An abstract graph with the additional possibility to attach properties to vertices and edges.  source  #  Erdos.ADiNetwork     Type .  abstract type ADiNetwork  : ADiGraph end  An abstract directed graph with the additional possibility to attach properties to vertices and edges.  source  #  Erdos.AIndexedEdge     Type .  abstract type AIndexedEdge  : AEdge end  Edge types with unique indexes, accessed by  idx  source", 
            "title": "Abstract Types"
        }, 
        {
            "location": "/network_types/#network-dinetwork-indexededge", 
            "text": "#  Erdos.Network     Type .  mutable struct Network  : ANetwork\n    ne::Int\n    edge_index_range::Int\n    out_edges::Vector{Vector{Pair{Int,Int}}}  #unordered adjlist\n    epos::Vector{Pair{Int,Int}}    # position of the edge in out_edges\n    free_indexes::Vector{Int}       # indexes of deleted edges to be used up\n                                    # for new edges to avoid very large\n                                    # indexes, and unnecessary property map\n                                    # memory used\n    props::PropertyStore\nend  A type representing a directed graph with indexed edges.  Network(n=0)  Construct a  Network  with  n  vertices and no edges.  Network(adjmx::AbstractMatrix; selfedges=true, upper=false)  Construct a  Network  from the adjacency matrix  adjmx , placing an edge in correspondence to each nonzero element of  adjmx . If  selfedges=false  the diagonal elements of  adjmx  are ignored. If  upper=true  only the upper triangular part of  adjmx  is considered.  source  #  Erdos.DiNetwork     Type .  mutable struct DiNetwork  : ADiNetwork\n    ne::Int\n    edge_index_range::Int\n    out_edges::Vector{Vector{Pair{Int,Int}}}  #unordered out_adjlist\n    in_edges::Vector{Vector{Pair{Int,Int}}}  #unordered in_adjlist\n\n    epos::Vector{Pair{Int,Int}}    # position of the edge in out_edges\n                                    # the first in the pair is the vertex\n                                    # with lower index\n\n    free_indexes::Vector{Int}       # indexes of deleted edges to be used up\n                                    # for new edges to avoid very large\n                                    # indexes, and unnecessary property map\n                                    # memory use\n    props::PropertyStore\nend  A type representing an directed graph with indexed edges.  DiNetwork(n=0)  Construct a  DiNetwork  with  n  vertices and no edges.  DiNetwork(adjmx::AbstractMatrix; selfedges=true)  Construct a  DiNetwork  from the adjacency matrix  adjmx . If  selfedges=false  the diagonal elements of  adjmx  are ignored.  source  #  Erdos.IndexedEdge     Type .  struct IndexedEdge  : AIndexedEdge\n    src::Int\n    dst::Int\n    idx::Int\nend  An indexed edge type  IndexedEdge(u, v) = IndexedEdge(u,v,-1)  Creates an edge with invalid index.  source", 
            "title": "Network / DiNetwork / IndexedEdge"
        }, 
        {
            "location": "/network_types/#defining-new-network-types", 
            "text": "In order to define a custom network type, e.g.  MyNet  : ANetwork , the corresponding methods in the preceding paragraph have to be implemented. This is automatically done for custom network types having a  props::PropertyStore  member. Take a look to  src/factory/net.jl  and  src/maps/property_store.jl  for an example.", 
            "title": "Defining new network types"
        }, 
        {
            "location": "/network_interface/", 
            "text": "Network Types and Interface\n\n\nNetworks in \nErdos\n are graphs with additional ability to store internally properties associated to vertices, edges and the graph itself. Edge and vertex properties are nothing else than edge and vertex maps with a name associated to them. \nErdos\n defines some interface methods (and their convenient short form equivalent) to work with networks and properties.\n\n\n\n\nProperty Interface\n\n\n#\n\n\nErdos.add_edge_property!\n \n \nMethod\n.\n\n\nadd_edge_property!(g, name, T)\nadd_edge_property!(g, name, emap)\n\n\n\n\nAdd the edge property  \nname\n to \ng\n.\n\n\nIf a type \nT\n is given as an input, an edge map with valtype \nT\n is created and stored into \ng\n.\n\n\nAs an alternative, an existing edge map \nemap\n can be stored into \ng\n.\n\n\neprop!\n is the short form of this function.\n\n\nExample\n\n\ng = random_regular_graph(10, 3, Network)\n\nadd_edge_property!(g, \nweight\n, Float64)\n# or equivalently\neprop!(g, \nweight\n, Float64)\n\n\n\n\nsource\n\n\n#\n\n\nErdos.add_vertex_property!\n \n \nMethod\n.\n\n\nadd_vertex_property!(g, name, T)\nadd_vertex_property!(g, name, vmap)\n\n\n\n\nAdd the vertex property  \nname\n to \ng\n.\n\n\nIf a type \nT\n is given as an input, a vertex map with valtype \nT\n is created and stored into \ng\n.\n\n\nAs an alternative, an existing vertex map \nvmap\n can be stored into \ng\n.\n\n\nvprop!\n is the short form of this function.\n\n\nsource\n\n\n#\n\n\nErdos.edge_property\n \n \nMethod\n.\n\n\nedge_property(g, name)\n\n\n\n\nReturn an edge map corresponding to property \nname\n of edges in \ng\n.\n\n\nedge_property(g)\n\n\n\n\nReturns a dictionary with elements \nproperty_name =\n edge_map\n.\n\n\nedge_property(g, e)\n\n\n\n\nReturns a dictionary of the form \nname =\n val\n containing all the properties associated to edge \ne\n.\n\n\neprop\n is the short form of this function.\n\n\nsource\n\n\n#\n\n\nErdos.eprop\n \n \nFunction\n.\n\n\nSee \nedge_property\n\n\nsource\n\n\n#\n\n\nErdos.eprop!\n \n \nFunction\n.\n\n\nSee \nadd_edge_property!\n\n\nsource\n\n\n#\n\n\nErdos.gprop\n \n \nFunction\n.\n\n\nSee \ngraph_property\n\n\nsource\n\n\n#\n\n\nErdos.gprop!\n \n \nFunction\n.\n\n\nSee \nset_graph_property!\n\n\nsource\n\n\n#\n\n\nErdos.graph_property\n \n \nMethod\n.\n\n\ngraph_property(g, name)\n\n\n\n\nReturn the property \nname\n of \ng\n.\n\n\ngraph_property(g)\n\n\n\n\nReturns a dictionary with elements \nproperty_name =\n property_value\n\n\ngprop\n is the short form of this function.\n\n\nsource\n\n\n#\n\n\nErdos.has_edge_property\n \n \nMethod\n.\n\n\nhas_edge_property(g, name)\nhas_edge_property(g, name, e)\n\n\n\n\nCheck if network  \ng\n has an edge property named \nname\n. The second method checks also if edge \ne\n has an assigned value for that property.\n\n\nhas_eprop\n is the short form of this function.\n\n\nsource\n\n\n#\n\n\nErdos.has_eprop\n \n \nFunction\n.\n\n\nSee \nhas_edge_property\n\n\nsource\n\n\n#\n\n\nErdos.has_gprop\n \n \nFunction\n.\n\n\nSee \nhas_graph_property\n\n\nsource\n\n\n#\n\n\nErdos.has_graph_property\n \n \nMethod\n.\n\n\nhas_graph_property(g, name)\n\n\n\n\nCheck if network  \ng\n has a graph property named \nname\n.\n\n\nhas_gprop\n is the short form of this function.\n\n\nsource\n\n\n#\n\n\nErdos.has_vertex_property\n \n \nMethod\n.\n\n\nhas_vertex_property(g, name, v)\n\n\n\n\nCheck if network  \ng\n has a vertex property named \nname\n. The second method checks also if vertex \nv\n has an assigned value for that property.\n\n\nhas_vprop\n is the short form of this function.\n\n\nsource\n\n\n#\n\n\nErdos.has_vprop\n \n \nFunction\n.\n\n\nSee \nhas_vertex_property\n\n\nsource\n\n\n#\n\n\nErdos.idx\n \n \nMethod\n.\n\n\nidx(e::AIndexedEdge)\n\n\n\n\nReturns the index of edge \ne\n.\n\n\nsource\n\n\n#\n\n\nErdos.rem_edge_property!\n \n \nMethod\n.\n\n\nrem_edge_property!(g, name)\n\n\n\n\nRemove the edge property  \nname\n from \ng\n.\n\n\nrem_eprop!\n is the short form of this function.\n\n\nsource\n\n\n#\n\n\nErdos.rem_eprop!\n \n \nFunction\n.\n\n\nSee \nrem_edge_property!\n\n\nsource\n\n\n#\n\n\nErdos.rem_gprop!\n \n \nFunction\n.\n\n\nSee \nrem_graph_property!\n\n\nsource\n\n\n#\n\n\nErdos.rem_graph_property!\n \n \nMethod\n.\n\n\nrem_graph_property!(g, name)\n\n\n\n\nRemove the property \nname\n from \ng\n.\n\n\nrem_gprop!\n is the short form of this function.\n\n\nsource\n\n\n#\n\n\nErdos.rem_vertex_property!\n \n \nMethod\n.\n\n\nrem_vertex_property!(g, name)\n\n\n\n\nRemove the vertex property  \nname\n from \ng\n.\n\n\nrem_vprop!\n is the short form of this function.\n\n\nsource\n\n\n#\n\n\nErdos.rem_vprop!\n \n \nFunction\n.\n\n\nSee \nrem_vertex_property!\n\n\nsource\n\n\n#\n\n\nErdos.set_graph_property!\n \n \nMethod\n.\n\n\nset_graph_property!(g, name, x)\n\n\n\n\nSet the property \nname\n to value \nx\n to \ng\n. Creates the property if it doesn't exist. \ngprop!\n can be conveniently used as a short form of this function.\n\n\nExample\n\n\ng = Network(10, 20)\nset_graph_property!(g, \nlabel\n, \nMy Network\n)\n# or equivalently\ngprop!(g, \nlabel\n, \nMy Network\n)\n\n\n\n\nsource\n\n\n#\n\n\nErdos.vertex_property\n \n \nMethod\n.\n\n\nvertex_property(g, name)\n\n\n\n\nReturn an vertex map corresponding to property \nname\n of vertices in \ng\n.\n\n\nvertex_property(g)\n\n\n\n\nReturns a dictionary with elements \nproperty_name =\n vertex_map\n.\n\n\nvertex_property(g, v)\n\n\n\n\nReturns a dictionary of the form \nname =\n val\n containing all the properties associated to vertex \nv\n.\n\n\nsource\n\n\n#\n\n\nErdos.vprop\n \n \nFunction\n.\n\n\nSee \nvertex_property\n\n\nsource\n\n\n#\n\n\nErdos.vprop!\n \n \nFunction\n.\n\n\nSee \nadd_vertex_property!\n\n\nsource\n\n\n\n\nDefining new network types\n\n\nIn order to define a custom network type, e.g. \nMyNet \n: ANetwork\n, the corresponding \ninterface methods\n  have to be implemented. This is automatically done for custom network types having a \nprops::PropertyStore\n member. Take a look to \nsrc/factory/net.jl\n and \nsrc/maps/property_store.jl\n for an example.", 
            "title": "Property Interface for Networks"
        }, 
        {
            "location": "/network_interface/#network-types-and-interface", 
            "text": "Networks in  Erdos  are graphs with additional ability to store internally properties associated to vertices, edges and the graph itself. Edge and vertex properties are nothing else than edge and vertex maps with a name associated to them.  Erdos  defines some interface methods (and their convenient short form equivalent) to work with networks and properties.", 
            "title": "Network Types and Interface"
        }, 
        {
            "location": "/network_interface/#property-interface", 
            "text": "#  Erdos.add_edge_property!     Method .  add_edge_property!(g, name, T)\nadd_edge_property!(g, name, emap)  Add the edge property   name  to  g .  If a type  T  is given as an input, an edge map with valtype  T  is created and stored into  g .  As an alternative, an existing edge map  emap  can be stored into  g .  eprop!  is the short form of this function.  Example  g = random_regular_graph(10, 3, Network)\n\nadd_edge_property!(g,  weight , Float64)\n# or equivalently\neprop!(g,  weight , Float64)  source  #  Erdos.add_vertex_property!     Method .  add_vertex_property!(g, name, T)\nadd_vertex_property!(g, name, vmap)  Add the vertex property   name  to  g .  If a type  T  is given as an input, a vertex map with valtype  T  is created and stored into  g .  As an alternative, an existing vertex map  vmap  can be stored into  g .  vprop!  is the short form of this function.  source  #  Erdos.edge_property     Method .  edge_property(g, name)  Return an edge map corresponding to property  name  of edges in  g .  edge_property(g)  Returns a dictionary with elements  property_name =  edge_map .  edge_property(g, e)  Returns a dictionary of the form  name =  val  containing all the properties associated to edge  e .  eprop  is the short form of this function.  source  #  Erdos.eprop     Function .  See  edge_property  source  #  Erdos.eprop!     Function .  See  add_edge_property!  source  #  Erdos.gprop     Function .  See  graph_property  source  #  Erdos.gprop!     Function .  See  set_graph_property!  source  #  Erdos.graph_property     Method .  graph_property(g, name)  Return the property  name  of  g .  graph_property(g)  Returns a dictionary with elements  property_name =  property_value  gprop  is the short form of this function.  source  #  Erdos.has_edge_property     Method .  has_edge_property(g, name)\nhas_edge_property(g, name, e)  Check if network   g  has an edge property named  name . The second method checks also if edge  e  has an assigned value for that property.  has_eprop  is the short form of this function.  source  #  Erdos.has_eprop     Function .  See  has_edge_property  source  #  Erdos.has_gprop     Function .  See  has_graph_property  source  #  Erdos.has_graph_property     Method .  has_graph_property(g, name)  Check if network   g  has a graph property named  name .  has_gprop  is the short form of this function.  source  #  Erdos.has_vertex_property     Method .  has_vertex_property(g, name, v)  Check if network   g  has a vertex property named  name . The second method checks also if vertex  v  has an assigned value for that property.  has_vprop  is the short form of this function.  source  #  Erdos.has_vprop     Function .  See  has_vertex_property  source  #  Erdos.idx     Method .  idx(e::AIndexedEdge)  Returns the index of edge  e .  source  #  Erdos.rem_edge_property!     Method .  rem_edge_property!(g, name)  Remove the edge property   name  from  g .  rem_eprop!  is the short form of this function.  source  #  Erdos.rem_eprop!     Function .  See  rem_edge_property!  source  #  Erdos.rem_gprop!     Function .  See  rem_graph_property!  source  #  Erdos.rem_graph_property!     Method .  rem_graph_property!(g, name)  Remove the property  name  from  g .  rem_gprop!  is the short form of this function.  source  #  Erdos.rem_vertex_property!     Method .  rem_vertex_property!(g, name)  Remove the vertex property   name  from  g .  rem_vprop!  is the short form of this function.  source  #  Erdos.rem_vprop!     Function .  See  rem_vertex_property!  source  #  Erdos.set_graph_property!     Method .  set_graph_property!(g, name, x)  Set the property  name  to value  x  to  g . Creates the property if it doesn't exist.  gprop!  can be conveniently used as a short form of this function.  Example  g = Network(10, 20)\nset_graph_property!(g,  label ,  My Network )\n# or equivalently\ngprop!(g,  label ,  My Network )  source  #  Erdos.vertex_property     Method .  vertex_property(g, name)  Return an vertex map corresponding to property  name  of vertices in  g .  vertex_property(g)  Returns a dictionary with elements  property_name =  vertex_map .  vertex_property(g, v)  Returns a dictionary of the form  name =  val  containing all the properties associated to vertex  v .  source  #  Erdos.vprop     Function .  See  vertex_property  source  #  Erdos.vprop!     Function .  See  add_vertex_property!  source", 
            "title": "Property Interface"
        }, 
        {
            "location": "/network_interface/#defining-new-network-types", 
            "text": "In order to define a custom network type, e.g.  MyNet  : ANetwork , the corresponding  interface methods   have to be implemented. This is automatically done for custom network types having a  props::PropertyStore  member. Take a look to  src/factory/net.jl  and  src/maps/property_store.jl  for an example.", 
            "title": "Defining new network types"
        }, 
        {
            "location": "/operators/", 
            "text": "Operators\n\n\nErdos.jl\n implements the following graph operators:\n\n\n\n\nBase.SparseArrays.blkdiag\n\n\nBase.intersect\n\n\nBase.join\n\n\nBase.union\n\n\nErdos.cartesian_product\n\n\nErdos.complement\n\n\nErdos.complete\n\n\nErdos.complete!\n\n\nErdos.contract!\n\n\nErdos.crosspath\n\n\nErdos.difference\n\n\nErdos.egonet\n\n\nErdos.subgraph\n\n\nErdos.subnetwork\n\n\nErdos.symmetric_difference\n\n\nErdos.tensor_product\n\n\n\n\n#\n\n\nBase.SparseArrays.blkdiag\n \n \nMethod\n.\n\n\nblkdiag(g, h)\n\n\n\n\nProduces a graph with $|V(g)| + |V(h)|$ vertices and $|E(g)| + |E(h)|$ edges.\n\n\nPut simply, the vertices and edges from graph \nh\n are appended to graph \ng\n.\n\n\nsource\n\n\n#\n\n\nBase.intersect\n \n \nMethod\n.\n\n\nintersect(g, h)\n\n\n\n\nProduces a graph with edges that are only in both graph \ng\n and graph \nh\n.\n\n\nNote that this function may produce a graph with 0-degree vertices.\n\n\nsource\n\n\n#\n\n\nBase.join\n \n \nMethod\n.\n\n\njoin(g, h)\n\n\n\n\nMerges graphs \ng\n and \nh\n using \nblkdiag\n and then adds all the edges between  the vertices in \ng\n and those in \nh\n.\n\n\nsource\n\n\n#\n\n\nBase.union\n \n \nMethod\n.\n\n\nunion(g, h)\n\n\n\n\nMerges graphs \ng\n and \nh\n by taking the set union of all vertices and edges.\n\n\nsource\n\n\n#\n\n\nErdos.cartesian_product\n \n \nMethod\n.\n\n\ncartesian_product(g, h)\n\n\n\n\nReturns the (cartesian product)[https://en.wikipedia.org/wiki/Cartesian_product_of_graphs] of \ng\n and \nh\n\n\nsource\n\n\n#\n\n\nErdos.complement\n \n \nMethod\n.\n\n\ncomplement(g)\n\n\n\n\nProduces the \ngraph complement\n of a graph.\n\n\nsource\n\n\n#\n\n\nErdos.complete!\n \n \nMethod\n.\n\n\ncomplete!(g::ADiGraph)\n\n\n\n\nFor each edge \n(u, v)\n in \ng\n, adds to \ng\n its reverse, i.e. \n(v, u)\n.\n\n\nsource\n\n\n#\n\n\nErdos.complete\n \n \nMethod\n.\n\n\ncomplete(g::ADiGraph)\n\n\n\n\nReturns a digraph containing both the edges \n(u, v)\n of \ng\n and their reverse \n(v, u)\n. See also \ncomplete!\n.\n\n\nsource\n\n\n#\n\n\nErdos.contract!\n \n \nMethod\n.\n\n\ncontract!(g, vs)\ncontract!(g, v1, v2, ....)\n\n\n\n\nMerge the vertices in \nvs\n into a unique vertex.\n\n\nsource\n\n\n#\n\n\nErdos.crosspath\n \n \nMethod\n.\n\n\ncrosspath(g::AGraph, n::Integer)\n\n\n\n\nReplicate \nn\n times \ng\n and connect each vertex with its copies in a path.\n\n\nsource\n\n\n#\n\n\nErdos.difference\n \n \nMethod\n.\n\n\ndifference(g, h)\n\n\n\n\nProduces a graph with edges in graph \ng\n that are not in graph \nh\n.\n\n\nNote that this function may produce a graph with 0-degree vertices.\n\n\nsource\n\n\n#\n\n\nErdos.egonet\n \n \nMethod\n.\n\n\negonet(g, v::Int, d::Int; dir=:out)\n\n\n\n\nReturns the subgraph of \ng\n induced by the neighbors of \nv\n up to distance \nd\n. If \ng\n is a \nDiGraph\n the \ndir\n optional argument specifies the edge direction the edge direction with respect to \nv\n (i.e. \n:in\n or \n:out\n) to be considered. This is equivalent to \nsubgraph\n(g, neighborhood(g, v, d, dir=dir))[1].\n\n\nsource\n\n\n#\n\n\nErdos.subgraph\n \n \nMethod\n.\n\n\nsubgraph(g, vlist) -\n sg, vlist\nsubgraph(g, elist) -\n sg, vlist\n\n\n\n\nReturns the subgraph of \ng\n induced by the vertices in  \nvlist\n or by the edges in \nelist\n, along with \nvlist\n itself (a newly created vector for the second method).\n\n\nThe returned graph has \nlength(vlist)\n vertices, with the new vertex \ni\n corresponding to the vertex of the original graph in the \ni\n-th position of \nvlist\n.\n\n\nFor easy subgraph creation also \ng[vlist]\n or \ng[elist]\n can be used.\n\n\nIf \ng\n is a network, vector and edge properties won't be converved \nsg\n. You can preserve properties using the \nsubnetwork\n method.\n\n\nUsage Examples:\n\n\ng = CompleteGraph(10)\nsg, vlist = subgraph(g, 5:8)\n@assert g[5:8] == sg\n@assert nv(sg) == 4\n@assert ne(sg) == 6\n@assert vm[4] == 8\n\nsg, vlist = subgraph(g, [2,8,3,4])\n@asssert sg == g[[2,8,3,4]]\n\nelist = [Edge(1,2), Edge(3,4), Edge(4,8)]\nsg, vlist = subgraph(g, elist)\n@asssert sg == g[elist]\n\n\n\n\nsource\n\n\n#\n\n\nErdos.subnetwork\n \n \nMethod\n.\n\n\nsubnetwork(g, vlist) -\n sg, vlist\nsubnetwork(g, elist) -\n sg, vlist\n\n\n\n\nEquivalent to \nsubgraph\n but preserves vertex and edge properties when \ng\n is a network.\n\n\nsource\n\n\n#\n\n\nErdos.symmetric_difference\n \n \nMethod\n.\n\n\nsymmetric_difference(g, h)\n\n\n\n\nProduces a graph with edges from graph \ng\n that do not exist in graph \nh\n, and vice versa.\n\n\nNote that this function may produce a graph with 0-degree vertices.\n\n\nsource\n\n\n#\n\n\nErdos.tensor_product\n \n \nMethod\n.\n\n\ntensor_product(g, h)\n\n\n\n\nReturns the (tensor product)[https://en.wikipedia.org/wiki/Tensor_product_of_graphs] of \ng\n and \nh\n\n\nsource", 
            "title": "Operators"
        }, 
        {
            "location": "/operators/#operators", 
            "text": "Erdos.jl  implements the following graph operators:   Base.SparseArrays.blkdiag  Base.intersect  Base.join  Base.union  Erdos.cartesian_product  Erdos.complement  Erdos.complete  Erdos.complete!  Erdos.contract!  Erdos.crosspath  Erdos.difference  Erdos.egonet  Erdos.subgraph  Erdos.subnetwork  Erdos.symmetric_difference  Erdos.tensor_product   #  Base.SparseArrays.blkdiag     Method .  blkdiag(g, h)  Produces a graph with $|V(g)| + |V(h)|$ vertices and $|E(g)| + |E(h)|$ edges.  Put simply, the vertices and edges from graph  h  are appended to graph  g .  source  #  Base.intersect     Method .  intersect(g, h)  Produces a graph with edges that are only in both graph  g  and graph  h .  Note that this function may produce a graph with 0-degree vertices.  source  #  Base.join     Method .  join(g, h)  Merges graphs  g  and  h  using  blkdiag  and then adds all the edges between  the vertices in  g  and those in  h .  source  #  Base.union     Method .  union(g, h)  Merges graphs  g  and  h  by taking the set union of all vertices and edges.  source  #  Erdos.cartesian_product     Method .  cartesian_product(g, h)  Returns the (cartesian product)[https://en.wikipedia.org/wiki/Cartesian_product_of_graphs] of  g  and  h  source  #  Erdos.complement     Method .  complement(g)  Produces the  graph complement  of a graph.  source  #  Erdos.complete!     Method .  complete!(g::ADiGraph)  For each edge  (u, v)  in  g , adds to  g  its reverse, i.e.  (v, u) .  source  #  Erdos.complete     Method .  complete(g::ADiGraph)  Returns a digraph containing both the edges  (u, v)  of  g  and their reverse  (v, u) . See also  complete! .  source  #  Erdos.contract!     Method .  contract!(g, vs)\ncontract!(g, v1, v2, ....)  Merge the vertices in  vs  into a unique vertex.  source  #  Erdos.crosspath     Method .  crosspath(g::AGraph, n::Integer)  Replicate  n  times  g  and connect each vertex with its copies in a path.  source  #  Erdos.difference     Method .  difference(g, h)  Produces a graph with edges in graph  g  that are not in graph  h .  Note that this function may produce a graph with 0-degree vertices.  source  #  Erdos.egonet     Method .  egonet(g, v::Int, d::Int; dir=:out)  Returns the subgraph of  g  induced by the neighbors of  v  up to distance  d . If  g  is a  DiGraph  the  dir  optional argument specifies the edge direction the edge direction with respect to  v  (i.e.  :in  or  :out ) to be considered. This is equivalent to  subgraph (g, neighborhood(g, v, d, dir=dir))[1].  source  #  Erdos.subgraph     Method .  subgraph(g, vlist) -  sg, vlist\nsubgraph(g, elist) -  sg, vlist  Returns the subgraph of  g  induced by the vertices in   vlist  or by the edges in  elist , along with  vlist  itself (a newly created vector for the second method).  The returned graph has  length(vlist)  vertices, with the new vertex  i  corresponding to the vertex of the original graph in the  i -th position of  vlist .  For easy subgraph creation also  g[vlist]  or  g[elist]  can be used.  If  g  is a network, vector and edge properties won't be converved  sg . You can preserve properties using the  subnetwork  method.  Usage Examples:  g = CompleteGraph(10)\nsg, vlist = subgraph(g, 5:8)\n@assert g[5:8] == sg\n@assert nv(sg) == 4\n@assert ne(sg) == 6\n@assert vm[4] == 8\n\nsg, vlist = subgraph(g, [2,8,3,4])\n@asssert sg == g[[2,8,3,4]]\n\nelist = [Edge(1,2), Edge(3,4), Edge(4,8)]\nsg, vlist = subgraph(g, elist)\n@asssert sg == g[elist]  source  #  Erdos.subnetwork     Method .  subnetwork(g, vlist) -  sg, vlist\nsubnetwork(g, elist) -  sg, vlist  Equivalent to  subgraph  but preserves vertex and edge properties when  g  is a network.  source  #  Erdos.symmetric_difference     Method .  symmetric_difference(g, h)  Produces a graph with edges from graph  g  that do not exist in graph  h , and vice versa.  Note that this function may produce a graph with 0-degree vertices.  source  #  Erdos.tensor_product     Method .  tensor_product(g, h)  Returns the (tensor product)[https://en.wikipedia.org/wiki/Tensor_product_of_graphs] of  g  and  h  source", 
            "title": "Operators"
        }, 
        {
            "location": "/traversals/", 
            "text": "Path and Traversal\n\n\nErdos.jl\n provides several traversal and shortest-path algorithms, along with various utility functions. Where appropriate, edge distances may be passed in as a matrix of real number values.\n\n\nEdge distances for most traversals may be passed in as a sparse or dense matrix of  values, indexed by \n[src,dst]\n vertices. That is, \ndistmx[2,4] = 2.5\n assigns the distance \n2.5\n to the (directed) edge connecting vertex 2 and vertex 4. Note that also for undirected graphs \ndistmx[4,2]\n has to be set.\n\n\nAny graph traversal  will traverse an edge only if it is present in the graph. When a distance matrix is passed in,\n\n\n\n\ndistance values for undefined edges will be ignored, and\n\n\nany unassigned values (in sparse distance matrices), for edges that are present in the graph, will be assumed to take the default value of 1.0.\n\n\nany zero values (in sparse/dense distance matrices), for edges that are present in the graph, will instead have an implicit edge cost of 1.0.\n\n\n\n\n\n\nGraph Traversal\n\n\nGraph traversal\n refers to a process that traverses vertices of a graph following certain order (starting from user-input sources). This package implements three traversal schemes:\n\n\n\n\nBreadthFirst\n,\n\n\nDepthFirst\n, and\n\n\nMaximumAdjacency\n.\n\n\n\n\n\n\n\n#\n\n\nErdos.BreadthFirst\n \n \nType\n.\n\n\nConventions in Breadth First Search and Depth First Search\n VertexColorMap :\n\n\n\n\ncolor == 0    =\n unseen\n\n\ncolor \n 0     =\n examined but not closed\n\n\ncolor \n 0     =\n examined and closed\n\n\n\n\nEdgeColorMap :\n\n\n\n\ncolor == 0    =\n unseen\n\n\ncolor == 1     =\n examined\n\n\n\n\nsource\n\n\n#\n\n\nErdos.bfs_tree\n \n \nMethod\n.\n\n\nbfs_tree(g, s)\n\n\n\n\nProvides a breadth-first traversal of the graph \ng\n starting with source vertex \ns\n, and returns a directed acyclic graph of vertices in the order they were discovered.\n\n\nsource\n\n\n#\n\n\nErdos.bipartite_map\n \n \nMethod\n.\n\n\nbipartite_map(g)\n\n\n\n\nIf the graph is bipartite returns a vector \nc\n  of size \nnv(g)\n containing the assignment of each vertex to one of the two sets (\nc[i] == 1\n or \nc[i]==2\n). If \ng\n is not bipartite returns an empty vector.\n\n\nsource\n\n\n#\n\n\nErdos.gdistances!\n \n \nMethod\n.\n\n\ngdistances!(g, source, dists) -\n dists\n\n\n\n\nFills \ndists\n with the geodesic distances of vertices in  \ng\n from vertex/vertices \nsource\n. \ndists\n can be either a vector or a dictionary.\n\n\nsource\n\n\n#\n\n\nErdos.gdistances\n \n \nMethod\n.\n\n\ngdistances(g, source) -\n dists\n\n\n\n\nReturns a vector filled with the geodesic distances of vertices in  \ng\n from vertex/vertices \nsource\n. For vertices in disconnected components the default distance is -1.\n\n\nsource\n\n\n#\n\n\nErdos.is_bipartite\n \n \nMethod\n.\n\n\nis_bipartite(g)\nis_bipartite(g, v)\n\n\n\n\nWill return \ntrue\n if graph \ng\n is \nbipartite\n. If a node \nv\n is specified, only the connected component to which it belongs is considered.\n\n\nsource\n\n\n#\n\n\nErdos.DepthFirst\n \n \nType\n.\n\n\nConventions in Breadth First Search and Depth First Search\n VertexColorMap :\n\n\n\n\ncolor == 0    =\n unseen\n\n\ncolor \n 0     =\n examined but not closed\n\n\ncolor \n 0     =\n examined and closed\n\n\n\n\nEdgeColorMap :\n\n\n\n\ncolor == 0    =\n unseen\n\n\ncolor == 1     =\n examined\n\n\n\n\nsource\n\n\n#\n\n\nErdos.dfs_tree\n \n \nMethod\n.\n\n\ndfs_tree(g, s)\n\n\n\n\nProvides a depth-first traversal of the graph \ng\n starting with source vertex \ns\n, and returns a directed acyclic graph of vertices in the order they were discovered.\n\n\nsource\n\n\n#\n\n\nErdos.has_cycles\n \n \nMethod\n.\n\n\nhas_cycles(g)\n\n\n\n\nTests whether a graph contains a simple cycle through depth-first search. See also \nis_tree\n.\n\n\nsource\n\n\n#\n\n\nErdos.is_tree\n \n \nMethod\n.\n\n\nis_tree(g)\n\n\n\n\nCheck whether \ng\n is a tree. Return \nfalse\n whenever \nhas_cycles\n returns \ntrue\n and viceversa.\n\n\nsource\n\n\n#\n\n\nErdos.maximum_adjacency_visit\n \n \nFunction\n.\n\n\nmaximum_adjacency_visit(\n    g,\n    distmx::AEdgeMap=ConstEdgeMap(g,1);\n    log::Bool=false,\n    io::IO=STDOUT\n)\n\n\n\n\nReturns the vertices in \ng\n traversed by maximum adjacency search. An optional \ndistmx\n edge map may be specified; if omitted, edge distances are assumed to be 1. If \nlog\n (default \nfalse\n) is \ntrue\n, visitor events will be printed to \nio\n, which defaults to \nSTDOUT\n; otherwise, no event information will be displayed.\n\n\nsource\n\n\n#\n\n\nErdos.minimum_cut\n \n \nMethod\n.\n\n\nminimum_cut(g, dist_edge map=ConstEdgeMap(g,1))\n\n\n\n\nFinds the \ncut\n of minimum total weight.\n\n\nReturns a tuple \n(f, cut, labels)\n, where \nf\n is the weight of the cut, \ncut\n is a vector of the edges in the cut, and \nlabels\n gives a partitioning of the vertices in two sets, according to the cut. An optional \ndist_matrix\n edge map maybe specified; if omitted, edge distances are assumed to be 1.\n\n\nsource\n\n\n\n\nRandom walks\n\n\nErdos\n includes uniform random walks and self avoiding walks:\n\n\n#\n\n\nErdos.nonbacktracking_randomwalk\n \n \nMethod\n.\n\n\nnonbacktracking_randomwalk(g, s, niter)\n\n\n\n\nPerforms a non-backtracking random walk on graph \ng\n starting at vertex \ns\n and continuing for a maximum of \nniter\n steps. Returns a vector of vertices visited in order.\n\n\nsource\n\n\n#\n\n\nErdos.randomwalk\n \n \nMethod\n.\n\n\nrandomwalk(g, s, niter)\n\n\n\n\nPerforms a random walk on graph \ng\n starting at vertex \ns\n and continuing for a maximum of \nniter\n steps. Returns a vector of vertices visited in order.\n\n\nsource\n\n\n#\n\n\nErdos.self_avoiding_randomwalk\n \n \nMethod\n.\n\n\nself_avoiding_randomwalk(g, s, niter)\n\n\n\n\nPerforms a \nself-avoiding walk\n on graph \ng\n starting at vertex \ns\n and continuing for a maximum of \nniter\n steps. Returns a vector of vertices visited in order.\n\n\nsource\n\n\n\n\nConnectivity / Bipartiteness\n\n\nGraph connectivity\n functions are defined on both undirected and directed graphs:\n\n\n#\n\n\nErdos.attracting_components\n \n \nMethod\n.\n\n\nattracting_components(g::ADiGraph)\n\n\n\n\nReturns a vector of vectors of integers representing lists of attracting components in \ng\n. The attracting components are a subset of the strongly connected components in which the components do not have any leaving edges.\n\n\nsource\n\n\n#\n\n\nErdos.condensation\n \n \nMethod\n.\n\n\ncondensation(g::ADiGraph)\n\n\n\n\nReturns the condensation graph associated with \ng\n. The condensation \nh\n of a graph \ng\n is the directed graph where every node in \nh\n represents a strongly connected component in \ng\n, and the presence of an edge between between nodes in \nh\n indicates that there is at least one edge between the associated strongly connected components in \ng\n. The node numbering in \nh\n corresponds to the ordering of the components output from \nstrongly_connected_components\n.\n\n\nsource\n\n\n#\n\n\nErdos.connected_components\n \n \nMethod\n.\n\n\nconnected_components(g::AGraph)\n\n\n\n\nReturns the \nconnected components\n of \ng\n as a vector of components, each represented by a vector of vertices belonging to the component.\n\n\nSee also \nweakly_connected_components\n and \nstrongly_connected_components\n for directed graphs.\n\n\nsource\n\n\n#\n\n\nErdos.is_connected\n \n \nMethod\n.\n\n\nis_connected(g)\n\n\n\n\nReturns \ntrue\n if \ng\n is connected. For DiGraphs, this is equivalent to a test of weak connectivity.\n\n\nsource\n\n\n#\n\n\nErdos.is_strongly_connected\n \n \nMethod\n.\n\n\nis_strongly_connected(g::ADiGraph)\n\n\n\n\nReturns \ntrue\n if \ng\n is strongly connected.\n\n\nSee also \nstrongly_connected_components\n\n\nsource\n\n\n#\n\n\nErdos.is_weakly_connected\n \n \nMethod\n.\n\n\nis_weakly_connected(g::ADiGraph)\n\n\n\n\nReturns \ntrue\n if the undirected graph \ng\n is weakly connected.\n\n\nSee also \nweakly_connected_components\n.\n\n\nsource\n\n\n#\n\n\nErdos.neighborhood\n \n \nMethod\n.\n\n\nneighborhood(g, v, d; dir=:out)\n\n\n\n\nReturns a vector of the vertices in \ng\n at distance less or equal to \nd\n from \nv\n. If \ng\n is a \nDiGraph\n the \ndir\n optional argument specifies the edge direction the edge direction with respect to \nv\n (i.e. \n:in\n or \n:out\n) to be considered.\n\n\nsource\n\n\n#\n\n\nErdos.period\n \n \nMethod\n.\n\n\nperiod(g::ADiGraph)\n\n\n\n\nComputes the common period for all nodes in a strongly connected graph.\n\n\nsource\n\n\n#\n\n\nErdos.strongly_connected_components\n \n \nMethod\n.\n\n\nstrongly_connected_components(g::ADiGraph)\n\n\n\n\nComputes the strongly connected components of a directed graph.\n\n\nsource\n\n\n#\n\n\nErdos.weakly_connected_components\n \n \nMethod\n.\n\n\nweakly_connected_components(g::ADiGraph)\n\n\n\n\nReturns the weakly connected components of undirected graph \ng\n. It is equivalent to the connected components of the corresponding undirected graph, i.e. \nconnected_components(graph(g))\n.\n\n\nsource", 
            "title": "Traversals"
        }, 
        {
            "location": "/traversals/#path-and-traversal", 
            "text": "Erdos.jl  provides several traversal and shortest-path algorithms, along with various utility functions. Where appropriate, edge distances may be passed in as a matrix of real number values.  Edge distances for most traversals may be passed in as a sparse or dense matrix of  values, indexed by  [src,dst]  vertices. That is,  distmx[2,4] = 2.5  assigns the distance  2.5  to the (directed) edge connecting vertex 2 and vertex 4. Note that also for undirected graphs  distmx[4,2]  has to be set.  Any graph traversal  will traverse an edge only if it is present in the graph. When a distance matrix is passed in,   distance values for undefined edges will be ignored, and  any unassigned values (in sparse distance matrices), for edges that are present in the graph, will be assumed to take the default value of 1.0.  any zero values (in sparse/dense distance matrices), for edges that are present in the graph, will instead have an implicit edge cost of 1.0.", 
            "title": "Path and Traversal"
        }, 
        {
            "location": "/traversals/#graph-traversal", 
            "text": "Graph traversal  refers to a process that traverses vertices of a graph following certain order (starting from user-input sources). This package implements three traversal schemes:   BreadthFirst ,  DepthFirst , and  MaximumAdjacency .    #  Erdos.BreadthFirst     Type .  Conventions in Breadth First Search and Depth First Search  VertexColorMap :   color == 0    =  unseen  color   0     =  examined but not closed  color   0     =  examined and closed   EdgeColorMap :   color == 0    =  unseen  color == 1     =  examined   source  #  Erdos.bfs_tree     Method .  bfs_tree(g, s)  Provides a breadth-first traversal of the graph  g  starting with source vertex  s , and returns a directed acyclic graph of vertices in the order they were discovered.  source  #  Erdos.bipartite_map     Method .  bipartite_map(g)  If the graph is bipartite returns a vector  c   of size  nv(g)  containing the assignment of each vertex to one of the two sets ( c[i] == 1  or  c[i]==2 ). If  g  is not bipartite returns an empty vector.  source  #  Erdos.gdistances!     Method .  gdistances!(g, source, dists) -  dists  Fills  dists  with the geodesic distances of vertices in   g  from vertex/vertices  source .  dists  can be either a vector or a dictionary.  source  #  Erdos.gdistances     Method .  gdistances(g, source) -  dists  Returns a vector filled with the geodesic distances of vertices in   g  from vertex/vertices  source . For vertices in disconnected components the default distance is -1.  source  #  Erdos.is_bipartite     Method .  is_bipartite(g)\nis_bipartite(g, v)  Will return  true  if graph  g  is  bipartite . If a node  v  is specified, only the connected component to which it belongs is considered.  source  #  Erdos.DepthFirst     Type .  Conventions in Breadth First Search and Depth First Search  VertexColorMap :   color == 0    =  unseen  color   0     =  examined but not closed  color   0     =  examined and closed   EdgeColorMap :   color == 0    =  unseen  color == 1     =  examined   source  #  Erdos.dfs_tree     Method .  dfs_tree(g, s)  Provides a depth-first traversal of the graph  g  starting with source vertex  s , and returns a directed acyclic graph of vertices in the order they were discovered.  source  #  Erdos.has_cycles     Method .  has_cycles(g)  Tests whether a graph contains a simple cycle through depth-first search. See also  is_tree .  source  #  Erdos.is_tree     Method .  is_tree(g)  Check whether  g  is a tree. Return  false  whenever  has_cycles  returns  true  and viceversa.  source  #  Erdos.maximum_adjacency_visit     Function .  maximum_adjacency_visit(\n    g,\n    distmx::AEdgeMap=ConstEdgeMap(g,1);\n    log::Bool=false,\n    io::IO=STDOUT\n)  Returns the vertices in  g  traversed by maximum adjacency search. An optional  distmx  edge map may be specified; if omitted, edge distances are assumed to be 1. If  log  (default  false ) is  true , visitor events will be printed to  io , which defaults to  STDOUT ; otherwise, no event information will be displayed.  source  #  Erdos.minimum_cut     Method .  minimum_cut(g, dist_edge map=ConstEdgeMap(g,1))  Finds the  cut  of minimum total weight.  Returns a tuple  (f, cut, labels) , where  f  is the weight of the cut,  cut  is a vector of the edges in the cut, and  labels  gives a partitioning of the vertices in two sets, according to the cut. An optional  dist_matrix  edge map maybe specified; if omitted, edge distances are assumed to be 1.  source", 
            "title": "Graph Traversal"
        }, 
        {
            "location": "/traversals/#random-walks", 
            "text": "Erdos  includes uniform random walks and self avoiding walks:  #  Erdos.nonbacktracking_randomwalk     Method .  nonbacktracking_randomwalk(g, s, niter)  Performs a non-backtracking random walk on graph  g  starting at vertex  s  and continuing for a maximum of  niter  steps. Returns a vector of vertices visited in order.  source  #  Erdos.randomwalk     Method .  randomwalk(g, s, niter)  Performs a random walk on graph  g  starting at vertex  s  and continuing for a maximum of  niter  steps. Returns a vector of vertices visited in order.  source  #  Erdos.self_avoiding_randomwalk     Method .  self_avoiding_randomwalk(g, s, niter)  Performs a  self-avoiding walk  on graph  g  starting at vertex  s  and continuing for a maximum of  niter  steps. Returns a vector of vertices visited in order.  source", 
            "title": "Random walks"
        }, 
        {
            "location": "/traversals/#connectivity-bipartiteness", 
            "text": "Graph connectivity  functions are defined on both undirected and directed graphs:  #  Erdos.attracting_components     Method .  attracting_components(g::ADiGraph)  Returns a vector of vectors of integers representing lists of attracting components in  g . The attracting components are a subset of the strongly connected components in which the components do not have any leaving edges.  source  #  Erdos.condensation     Method .  condensation(g::ADiGraph)  Returns the condensation graph associated with  g . The condensation  h  of a graph  g  is the directed graph where every node in  h  represents a strongly connected component in  g , and the presence of an edge between between nodes in  h  indicates that there is at least one edge between the associated strongly connected components in  g . The node numbering in  h  corresponds to the ordering of the components output from  strongly_connected_components .  source  #  Erdos.connected_components     Method .  connected_components(g::AGraph)  Returns the  connected components  of  g  as a vector of components, each represented by a vector of vertices belonging to the component.  See also  weakly_connected_components  and  strongly_connected_components  for directed graphs.  source  #  Erdos.is_connected     Method .  is_connected(g)  Returns  true  if  g  is connected. For DiGraphs, this is equivalent to a test of weak connectivity.  source  #  Erdos.is_strongly_connected     Method .  is_strongly_connected(g::ADiGraph)  Returns  true  if  g  is strongly connected.  See also  strongly_connected_components  source  #  Erdos.is_weakly_connected     Method .  is_weakly_connected(g::ADiGraph)  Returns  true  if the undirected graph  g  is weakly connected.  See also  weakly_connected_components .  source  #  Erdos.neighborhood     Method .  neighborhood(g, v, d; dir=:out)  Returns a vector of the vertices in  g  at distance less or equal to  d  from  v . If  g  is a  DiGraph  the  dir  optional argument specifies the edge direction the edge direction with respect to  v  (i.e.  :in  or  :out ) to be considered.  source  #  Erdos.period     Method .  period(g::ADiGraph)  Computes the common period for all nodes in a strongly connected graph.  source  #  Erdos.strongly_connected_components     Method .  strongly_connected_components(g::ADiGraph)  Computes the strongly connected components of a directed graph.  source  #  Erdos.weakly_connected_components     Method .  weakly_connected_components(g::ADiGraph)  Returns the weakly connected components of undirected graph  g . It is equivalent to the connected components of the corresponding undirected graph, i.e.  connected_components(graph(g)) .  source", 
            "title": "Connectivity / Bipartiteness"
        }, 
        {
            "location": "/distance/", 
            "text": "Distance\n\n\nErdos.jl\n includes the following distance measurements:\n\n\n#\n\n\nErdos.center\n \n \nMethod\n.\n\n\ncenter(g, distmx=ConstEdgeMap(g,1))\ncenter(all_ecc)\n\n\n\n\nReturns the set of all vertices whose eccentricity is equal to the graph's radius (that is, the set of vertices with the smallest eccentricity).\n\n\nEventually a vector \nall_ecc\n contain the eccentricity of each node can be passed as argument.\n\n\nSee \neccentricities\n.\n\n\nsource\n\n\n#\n\n\nErdos.diameter\n \n \nFunction\n.\n\n\ndiameter(g, distmx=ConstEdgeMap(g,1))\n\n\n\n\nReturns the maximum distance between any two vertices in \ng\n. Distances  between two adjacent nodes are given by \ndistmx\n.\n\n\nSee also \neccentricities\n, \nradius\n.\n\n\nsource\n\n\n#\n\n\nErdos.eccentricities\n \n \nFunction\n.\n\n\neccentricities(g, distmx=ConstEdgeMap(g,1))\neccentricities(g, vs, distmx=ConstEdgeMap(g,1))\n\n\n\n\nReturns \n[eccentricity(g,v,distmx) for v in vs]\n. When \nvs\n it is not supplied, considers all node in the graph.\n\n\nSee also \neccentricity\n.\n\n\nNote: the eccentricity vector returned by \neccentricity\n may be eventually used as input in some eccentricity related measures (\nperiphery\n, \ncenter\n).\n\n\nsource\n\n\n#\n\n\nErdos.eccentricity\n \n \nFunction\n.\n\n\neccentricity(g, v, distmx=ConstEdgeMap(g,1))\n\n\n\n\nCalculates the eccentricity[ies] of a vertex \nv\n, An optional matrix of edge distances may be supplied.\n\n\nThe eccentricity of a vertex is the maximum shortest-path distance between it and all other vertices in the graph.\n\n\nsource\n\n\n#\n\n\nErdos.periphery\n \n \nMethod\n.\n\n\nperiphery(g, distmx=ConstEdgeMap(g,1))\nperiphery(all_ecc)\n\n\n\n\nReturns the set of all vertices whose eccentricity is equal to the graph's diameter (that is, the set of vertices with the largest eccentricity).\n\n\nEventually a vector \nall_ecc\n contain the eccentricity of each node can be passed as argument.\n\n\nSee \neccentricities\n.\n\n\nsource\n\n\n#\n\n\nErdos.radius\n \n \nFunction\n.\n\n\nradius(g, distmx=ConstEdgeMap(g,1))\n\n\n\n\nReturns the minimum distance between any two vertices in \ng\n. Distances  between two adjacent nodes are given by \ndistmx\n.\n\n\nSee \neccentricities\n, \ndiameter\n.\n\n\nsource\n\n\n#\n\n\nErdos.BoundedMinkowskiCost\n \n \nMethod\n.\n\n\nSimilar to MinkowskiCost, but ensures costs smaller than 2\u03c4.\n\n\nsource\n\n\n#\n\n\nErdos.MinkowskiCost\n \n \nMethod\n.\n\n\nFor labels \u03bc\u2081 on the vertices of graph G\u2081 and labels \u03bc\u2082 on the vertices of graph G\u2082, compute the p-norm cost of substituting vertex u \u2208 G\u2081 by vertex v \u2208 G\u2082.\n\n\nsource\n\n\n#\n\n\nErdos.edit_distance\n \n \nMethod\n.\n\n\nedit_distance(G\u2081, G\u2082;\n       insert_cost::Function=v-\n1.0,\n       delete_cost::Function=u-\n1.0,\n       subst_cost::Function=(u,v)-\n0.5,\n       heuristic::Function=DefaultEditHeuristic)\n\n\n\n\nComputes the edit distance between graphs G\u2081 and G\u2082.\n\n\nReturns the minimum edit cost and edit path to transform graph G\u2081 into graph G\u2082. An edit path consists of a sequence of pairs of vertices (u,v) \u2208 [0,|G\u2081|] \u00d7 [0,|G\u2082|] representing vertex operations:\n\n\n\n\n(0,v): insertion of vertex v \u2208 G\u2082\n\n\n(u,0): deletion of vertex u \u2208 G\u2081\n\n\n(u\n0,v\n0): substitution of vertex u \u2208 G\u2081 by vertex v \u2208 G\u2082\n\n\n\n\nBy default, the algorithm uses constant operation costs. The user can provide classical Minkowski costs computed from vertex labels \u03bc\u2081 (for G\u2081) and \u03bc\u2082 (for G\u2082) in order to further guide the search, for example:\n\n\nedit_distance(G\u2081, G\u2082, subst_cost=MinkowskiCost(\u03bc\u2081, \u03bc\u2082))\n\n\n\n\nA custom heuristic can be provided to the A* search in case the default heuristic is not satisfactory. Performance tips: \u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013-\n\n\n\n\nGiven two graphs $|G\u2081| \n |G\u2082|$, \nedit_distance(G\u2081, G\u2082)\n is faster to\n\n\n\n\ncompute than \nedit_distance(G\u2082, G\u2081)\n. Consider swapping the arguments if involved costs are \nsymmetric\n.\n\n\n\n\nThe use of simple Minkowski costs can improve performance considerably.\n\n\nExploit vertex attributes when designing operation costs.\n\n\n\n\nFor further details, please refer to:\n\n\nRIESEN, K., 2015. Structural Pattern Recognition with Graph Edit Distance: Approximation Algorithms and Applications. (Chapter 2)\n\n\nAuthor: J\u00falio Hoffimann Mendes (juliohm@stanford.edu)\n\n\nsource", 
            "title": "Distance"
        }, 
        {
            "location": "/distance/#distance", 
            "text": "Erdos.jl  includes the following distance measurements:  #  Erdos.center     Method .  center(g, distmx=ConstEdgeMap(g,1))\ncenter(all_ecc)  Returns the set of all vertices whose eccentricity is equal to the graph's radius (that is, the set of vertices with the smallest eccentricity).  Eventually a vector  all_ecc  contain the eccentricity of each node can be passed as argument.  See  eccentricities .  source  #  Erdos.diameter     Function .  diameter(g, distmx=ConstEdgeMap(g,1))  Returns the maximum distance between any two vertices in  g . Distances  between two adjacent nodes are given by  distmx .  See also  eccentricities ,  radius .  source  #  Erdos.eccentricities     Function .  eccentricities(g, distmx=ConstEdgeMap(g,1))\neccentricities(g, vs, distmx=ConstEdgeMap(g,1))  Returns  [eccentricity(g,v,distmx) for v in vs] . When  vs  it is not supplied, considers all node in the graph.  See also  eccentricity .  Note: the eccentricity vector returned by  eccentricity  may be eventually used as input in some eccentricity related measures ( periphery ,  center ).  source  #  Erdos.eccentricity     Function .  eccentricity(g, v, distmx=ConstEdgeMap(g,1))  Calculates the eccentricity[ies] of a vertex  v , An optional matrix of edge distances may be supplied.  The eccentricity of a vertex is the maximum shortest-path distance between it and all other vertices in the graph.  source  #  Erdos.periphery     Method .  periphery(g, distmx=ConstEdgeMap(g,1))\nperiphery(all_ecc)  Returns the set of all vertices whose eccentricity is equal to the graph's diameter (that is, the set of vertices with the largest eccentricity).  Eventually a vector  all_ecc  contain the eccentricity of each node can be passed as argument.  See  eccentricities .  source  #  Erdos.radius     Function .  radius(g, distmx=ConstEdgeMap(g,1))  Returns the minimum distance between any two vertices in  g . Distances  between two adjacent nodes are given by  distmx .  See  eccentricities ,  diameter .  source  #  Erdos.BoundedMinkowskiCost     Method .  Similar to MinkowskiCost, but ensures costs smaller than 2\u03c4.  source  #  Erdos.MinkowskiCost     Method .  For labels \u03bc\u2081 on the vertices of graph G\u2081 and labels \u03bc\u2082 on the vertices of graph G\u2082, compute the p-norm cost of substituting vertex u \u2208 G\u2081 by vertex v \u2208 G\u2082.  source  #  Erdos.edit_distance     Method .  edit_distance(G\u2081, G\u2082;\n       insert_cost::Function=v- 1.0,\n       delete_cost::Function=u- 1.0,\n       subst_cost::Function=(u,v)- 0.5,\n       heuristic::Function=DefaultEditHeuristic)  Computes the edit distance between graphs G\u2081 and G\u2082.  Returns the minimum edit cost and edit path to transform graph G\u2081 into graph G\u2082. An edit path consists of a sequence of pairs of vertices (u,v) \u2208 [0,|G\u2081|] \u00d7 [0,|G\u2082|] representing vertex operations:   (0,v): insertion of vertex v \u2208 G\u2082  (u,0): deletion of vertex u \u2208 G\u2081  (u 0,v 0): substitution of vertex u \u2208 G\u2081 by vertex v \u2208 G\u2082   By default, the algorithm uses constant operation costs. The user can provide classical Minkowski costs computed from vertex labels \u03bc\u2081 (for G\u2081) and \u03bc\u2082 (for G\u2082) in order to further guide the search, for example:  edit_distance(G\u2081, G\u2082, subst_cost=MinkowskiCost(\u03bc\u2081, \u03bc\u2082))  A custom heuristic can be provided to the A* search in case the default heuristic is not satisfactory. Performance tips: \u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013-   Given two graphs $|G\u2081|   |G\u2082|$,  edit_distance(G\u2081, G\u2082)  is faster to   compute than  edit_distance(G\u2082, G\u2081) . Consider swapping the arguments if involved costs are  symmetric .   The use of simple Minkowski costs can improve performance considerably.  Exploit vertex attributes when designing operation costs.   For further details, please refer to:  RIESEN, K., 2015. Structural Pattern Recognition with Graph Edit Distance: Approximation Algorithms and Applications. (Chapter 2)  Author: J\u00falio Hoffimann Mendes (juliohm@stanford.edu)  source", 
            "title": "Distance"
        }, 
        {
            "location": "/shortestpaths/", 
            "text": "Shortest-Path Algorithms\n\n\nErdos\n implements several classical algorithms for finding the shortest paths between one or more vertex and any other vertex in the graphs. For all algorithms the following holds:\n\n\n\n\nthe distance from a vertex to itself is always \n0\n;\n\n\nthe distance between two vertices with no connecting paths is always \nInf\n.\n\n\n\n\nThe \nshortest_paths\n method provides easy access to the default algorithm.\n\n\n#\n\n\nErdos.shortest_paths\n \n \nFunction\n.\n\n\nshortest_paths(g, x...; kws...)\n\n\n\n\nComputes shortest paths using Dijkstra's algorithm. See \ndijkstra_shortest_paths\n.\n\n\nsource\n\n\n#\n\n\nErdos.a_star\n \n \nFunction\n.\n\n\na_star(g, s, t, distmx=ConstEdgeMap(g,1), heuristic = n-\n0)\n\n\n\n\nComputes the shortest path between vertices \ns\n and \nt\n using the \nA* search algorithm\n. An optional heuristic function and edge distance matrix may be supplied. Returns an empty path if there are no such paths.\n\n\nsource\n\n\n#\n\n\nErdos.dijkstra_shortest_paths\n \n \nFunction\n.\n\n\ndijkstra_shortest_paths(g, s, distmx=ConstEdgeMap(g,1); allpaths=false)\ndijkstra_shortest_paths(g, sources, distmx=ConstEdgeMap(g,1); allpaths=false)\n\n\n\n\nPerforms \nDijkstra's algorithm\n on a graph, computing shortest distances between a source vertex \ns\n (or a vector \nsources\n)  and all other veritces. Returns a \nDijkstraState\n that contains various traversal information.\n\n\nWith \nallpaths=true\n, returns a \nDijkstraState\n that keeps track of all predecessors of a given vertex.\n\n\nsource\n\n\n#\n\n\nErdos.bellman_ford_shortest_paths\n \n \nFunction\n.\n\n\nbellman_ford_shortest_paths(g, s, distmx=ConstEdgeMap(g,1))\nbellman_ford_shortest_paths(g, sources, distmx=ConstEdgeMap(g,1))\n\n\n\n\nUses the \nBellman-Ford algorithm\n to compute shortest paths of all vertices of a \ng\n from a source vertex \ns\n (or a set of source vertices \nsources\n). Returns a \nBellmanFordState\n with relevant traversal information.\n\n\nsource\n\n\n#\n\n\nErdos.floyd_warshall_shortest_paths\n \n \nFunction\n.\n\n\nfloyd_warshall_shortest_paths(g, distmx=ConstEdgeMap(g,1))\n\n\n\n\nUses the \nFloyd-Warshall algorithm\n to compute shortest paths between all pairs of vertices in graph \ng\n. Returns a \nFloydWarshallState\n with relevant traversal information, each is a vertex-indexed vector of vectors containing the metric for each vertex in the graph.\n\n\nNote that this algorithm may return a large amount of data (it will allocate on the order of $O(nv^2)$).\n\n\nsource\n\n\n\n\nPath discovery / enumeration\n\n\n#\n\n\nErdos.enumerate_paths\n \n \nFunction\n.\n\n\nenumerate_paths(state::AbstractPathState)\nenumerate_paths(state::AbstractPathState, dest)\n\n\n\n\nGiven a path state \nstate\n of type \nAbstractPathState\n (see below), returns a vector (indexed by vertex) of the paths between the source vertex used to compute the path state and a destination vertex \nv\n, a set of destination vertices \nvs\n, or the entire graph. For multiple destination vertices, each path is represented by a vector of vertices on the path between the source and the destination. Nonexistent paths will be indicated by an empty vector. For single destinations, the path is represented by a single vector of vertices, and will be length 0 if the path does not exist.\n\n\nFor Floyd-Warshall path states, please note that the output is a bit different, since this algorithm calculates all shortest paths for all pairs of vertices: \nenumerate_paths(state)\n will return a vector (indexed by source vertex) of vectors (indexed by destination vertex) of paths. \nenumerate_paths(state, v)\n will return a vector (indexed by destination vertex) of paths from source \nv\n to all other vertices. In addition, \nenumerate_paths(state, v, d)\n will return a vector representing the path from vertex \nv\n to vertex \nd\n.\n\n\nsource\n\n\nFor Floyd-Warshall path states, please note that the output is a bit different, since this algorithm calculates all shortest paths for all pairs of vertices: \nenumerate_paths(state)\n will return a vector (indexed by source vertex) of vectors (indexed by destination vertex) of paths. \nenumerate_paths(state, v)\n will return a vector (indexed by destination vertex) of paths from source \nv\n to all other vertices. In addition, \nenumerate_paths(state, v, d)\n will return a vector representing the path from vertex \nv\n to vertex \nd\n.\n\n\n\n\nPath States\n\n\nThe \nfloyd_warshall_shortest_paths\n, \nbellman_ford_shortest_paths\n, \ndijkstra_shortest_paths\n, and \ndijkstra_predecessor_and_distance\n functions return a state that contains various information about the graph learned during traversal. The three state types have the following common information, accessible via the type:\n\n\n.dists\n Holds a vector of distances computed, indexed by source vertex.\n\n\n.parents\n Holds a vector of parents of each source vertex. The parent of a source vertex is always \n0\n.\n\n\nIn addition, the \ndijkstra_predecessor_and_distance\n function stores the following information:\n\n\n.predecessors\n Holds a vector, indexed by vertex, of all the predecessors discovered during shortest-path calculations. This keeps track of all parents when there are multiple shortest paths available from the source.\n\n\n.pathcounts\n Holds a vector, indexed by vertex, of the path counts discovered during traversal. This equals the length of each subvector in the \n.predecessors\n output above.", 
            "title": "Shortest Paths"
        }, 
        {
            "location": "/shortestpaths/#shortest-path-algorithms", 
            "text": "Erdos  implements several classical algorithms for finding the shortest paths between one or more vertex and any other vertex in the graphs. For all algorithms the following holds:   the distance from a vertex to itself is always  0 ;  the distance between two vertices with no connecting paths is always  Inf .   The  shortest_paths  method provides easy access to the default algorithm.  #  Erdos.shortest_paths     Function .  shortest_paths(g, x...; kws...)  Computes shortest paths using Dijkstra's algorithm. See  dijkstra_shortest_paths .  source  #  Erdos.a_star     Function .  a_star(g, s, t, distmx=ConstEdgeMap(g,1), heuristic = n- 0)  Computes the shortest path between vertices  s  and  t  using the  A* search algorithm . An optional heuristic function and edge distance matrix may be supplied. Returns an empty path if there are no such paths.  source  #  Erdos.dijkstra_shortest_paths     Function .  dijkstra_shortest_paths(g, s, distmx=ConstEdgeMap(g,1); allpaths=false)\ndijkstra_shortest_paths(g, sources, distmx=ConstEdgeMap(g,1); allpaths=false)  Performs  Dijkstra's algorithm  on a graph, computing shortest distances between a source vertex  s  (or a vector  sources )  and all other veritces. Returns a  DijkstraState  that contains various traversal information.  With  allpaths=true , returns a  DijkstraState  that keeps track of all predecessors of a given vertex.  source  #  Erdos.bellman_ford_shortest_paths     Function .  bellman_ford_shortest_paths(g, s, distmx=ConstEdgeMap(g,1))\nbellman_ford_shortest_paths(g, sources, distmx=ConstEdgeMap(g,1))  Uses the  Bellman-Ford algorithm  to compute shortest paths of all vertices of a  g  from a source vertex  s  (or a set of source vertices  sources ). Returns a  BellmanFordState  with relevant traversal information.  source  #  Erdos.floyd_warshall_shortest_paths     Function .  floyd_warshall_shortest_paths(g, distmx=ConstEdgeMap(g,1))  Uses the  Floyd-Warshall algorithm  to compute shortest paths between all pairs of vertices in graph  g . Returns a  FloydWarshallState  with relevant traversal information, each is a vertex-indexed vector of vectors containing the metric for each vertex in the graph.  Note that this algorithm may return a large amount of data (it will allocate on the order of $O(nv^2)$).  source", 
            "title": "Shortest-Path Algorithms"
        }, 
        {
            "location": "/shortestpaths/#path-discovery-enumeration", 
            "text": "#  Erdos.enumerate_paths     Function .  enumerate_paths(state::AbstractPathState)\nenumerate_paths(state::AbstractPathState, dest)  Given a path state  state  of type  AbstractPathState  (see below), returns a vector (indexed by vertex) of the paths between the source vertex used to compute the path state and a destination vertex  v , a set of destination vertices  vs , or the entire graph. For multiple destination vertices, each path is represented by a vector of vertices on the path between the source and the destination. Nonexistent paths will be indicated by an empty vector. For single destinations, the path is represented by a single vector of vertices, and will be length 0 if the path does not exist.  For Floyd-Warshall path states, please note that the output is a bit different, since this algorithm calculates all shortest paths for all pairs of vertices:  enumerate_paths(state)  will return a vector (indexed by source vertex) of vectors (indexed by destination vertex) of paths.  enumerate_paths(state, v)  will return a vector (indexed by destination vertex) of paths from source  v  to all other vertices. In addition,  enumerate_paths(state, v, d)  will return a vector representing the path from vertex  v  to vertex  d .  source  For Floyd-Warshall path states, please note that the output is a bit different, since this algorithm calculates all shortest paths for all pairs of vertices:  enumerate_paths(state)  will return a vector (indexed by source vertex) of vectors (indexed by destination vertex) of paths.  enumerate_paths(state, v)  will return a vector (indexed by destination vertex) of paths from source  v  to all other vertices. In addition,  enumerate_paths(state, v, d)  will return a vector representing the path from vertex  v  to vertex  d .", 
            "title": "Path discovery / enumeration"
        }, 
        {
            "location": "/shortestpaths/#path-states", 
            "text": "The  floyd_warshall_shortest_paths ,  bellman_ford_shortest_paths ,  dijkstra_shortest_paths , and  dijkstra_predecessor_and_distance  functions return a state that contains various information about the graph learned during traversal. The three state types have the following common information, accessible via the type:  .dists  Holds a vector of distances computed, indexed by source vertex.  .parents  Holds a vector of parents of each source vertex. The parent of a source vertex is always  0 .  In addition, the  dijkstra_predecessor_and_distance  function stores the following information:  .predecessors  Holds a vector, indexed by vertex, of all the predecessors discovered during shortest-path calculations. This keeps track of all parents when there are multiple shortest paths available from the source.  .pathcounts  Holds a vector, indexed by vertex, of the path counts discovered during traversal. This equals the length of each subvector in the  .predecessors  output above.", 
            "title": "Path States"
        }, 
        {
            "location": "/linalg/", 
            "text": "Linear Algebra\n\n\nErdos.jl\n provides the following matrix operations on both directed and undirected graphs:\n\n\n#\n\n\nErdos.adjacency_matrix\n \n \nFunction\n.\n\n\nadjacency_matrix(g, dir=:out, T::DataType=Int)\n\n\n\n\nReturns a sparse boolean adjacency matrix for a graph, indexed by \n[u, v]\n vertices. \ntrue\n values indicate an edge between \nu\n and \nv\n. Users may specify a direction (\n:in\n, \n:out\n, or \n:all\n are currently supported; \n:out\n is default for both directed and undirected graphs) and a data type for the matrix (defaults to \nInt\n).\n\n\nsource\n\n\n#\n\n\nErdos.incidence_matrix\n \n \nFunction\n.\n\n\nincidence_matrix(g::AGraphOrDiGraph, T::DataType=Int; oriented=false)\n\n\n\n\nReturns a sparse node-arc incidence matrix for a graph, indexed by \n[v, i]\n, where \ni\n is in \n1:ne(g)\n, indexing an edge \ne\n. For directed graphs, a value of \n-1\n indicates that \nsrc(e) == v\n, while a value of \n1\n indicates that \ndst(e) == v\n. Otherwise, the value is \n0\n.\n\n\nFor undirected graphs, both entries are \n1\n if \noriented=false\n, otherwise \n[v, i] -\n -1\n and \n[u, i] -\n 1\n if \nv \n u\n.\n\n\nsource\n\n\n#\n\n\nErdos.laplacian_matrix\n \n \nFunction\n.\n\n\nlaplacian_matrix(g, dir::Symbol=:out, T::DataType=Int)\n\n\n\n\nReturns a sparse \nLaplacian matrix\n for a graph \ng\n, indexed by \n[u, v]\n vertices. \ndir\n has to be \n:in, :out\n or \n:all\n.\n\n\nsource\n\n\n#\n\n\nErdos.spectral_distance\n \n \nMethod\n.\n\n\nspectral_distance(G\u2081, G\u2082 [, k])\n\n\n\n\nCompute the spectral distance between undirected n-vertex graphs G\u2081 and G\u2082 using the top k \u2264 n greatest eigenvalues. If k is ommitted, uses full spectrum.\n\n\nFor further details, please refer to:\n\n\nJOVANOVIC, I.; STANIC, Z., 2014. Spectral Distances of Graphs Based on their Different Matrix Representations\n\n\nsource\n\n\n#\n\n\nErdos.Nonbacktracking\n \n \nType\n.\n\n\nmutable struct Nonbacktracking{G, E}\n    g::G\n    edgeidmap::Dict{E,Int}\n    m::Int\nend\n\n\n\n\nA compact representation of the nonbacktracking operator\n\n\ng: the underlying graph\nedgeidmap: the association between oriented edges and index into the NBT matrix\n\n\n\n\nThe Nonbacktracking operator can be used for community detection. This representation is compact in that it uses only ne(g) additional storage and provides an implicit representation of the matrix \nB_g\n defined below.\n\n\nGiven two oriented edges \ni-\nj\n and \nk-\nl\n in \ng\n, the non-backtraking matrix \nB\n is defined as\n\n\nB[i-\nj, k-\nl] = \u03b4(j,k)* (1 - \u03b4(i,l))\n\n\n\n\nThis type is in the style of GraphMatrices.jl and supports the necessary operations for computed eigenvectors and conducting linear solves.\n\n\nAdditionally the \ncontraction!(vertexspace, nbt, edgespace)\n method takes vectors represented in the domain of \nB\n and represents them in the domain of the adjacency matrix of \ng\n.\n\n\nsource\n\n\n#\n\n\nErdos.nonbacktracking_matrix\n \n \nMethod\n.\n\n\nnonbacktracking_matrix(g)\n\n\n\n\nGiven two oriented edges \ni-\nj\n and \nk-\nl\n in \ng\n, the non-backtraking matrix \nB\n is defined as\n\n\nB[i-\nj, k-\nl] = \u03b4(j,k)* (1 - \u03b4(i,l))\n\n\n\n\nReturns a matrix \nB\n, and an edgemap storing the oriented edges' positions in \nB\n.\n\n\nsource", 
            "title": "Linear Algebra"
        }, 
        {
            "location": "/linalg/#linear-algebra", 
            "text": "Erdos.jl  provides the following matrix operations on both directed and undirected graphs:  #  Erdos.adjacency_matrix     Function .  adjacency_matrix(g, dir=:out, T::DataType=Int)  Returns a sparse boolean adjacency matrix for a graph, indexed by  [u, v]  vertices.  true  values indicate an edge between  u  and  v . Users may specify a direction ( :in ,  :out , or  :all  are currently supported;  :out  is default for both directed and undirected graphs) and a data type for the matrix (defaults to  Int ).  source  #  Erdos.incidence_matrix     Function .  incidence_matrix(g::AGraphOrDiGraph, T::DataType=Int; oriented=false)  Returns a sparse node-arc incidence matrix for a graph, indexed by  [v, i] , where  i  is in  1:ne(g) , indexing an edge  e . For directed graphs, a value of  -1  indicates that  src(e) == v , while a value of  1  indicates that  dst(e) == v . Otherwise, the value is  0 .  For undirected graphs, both entries are  1  if  oriented=false , otherwise  [v, i] -  -1  and  [u, i] -  1  if  v   u .  source  #  Erdos.laplacian_matrix     Function .  laplacian_matrix(g, dir::Symbol=:out, T::DataType=Int)  Returns a sparse  Laplacian matrix  for a graph  g , indexed by  [u, v]  vertices.  dir  has to be  :in, :out  or  :all .  source  #  Erdos.spectral_distance     Method .  spectral_distance(G\u2081, G\u2082 [, k])  Compute the spectral distance between undirected n-vertex graphs G\u2081 and G\u2082 using the top k \u2264 n greatest eigenvalues. If k is ommitted, uses full spectrum.  For further details, please refer to:  JOVANOVIC, I.; STANIC, Z., 2014. Spectral Distances of Graphs Based on their Different Matrix Representations  source  #  Erdos.Nonbacktracking     Type .  mutable struct Nonbacktracking{G, E}\n    g::G\n    edgeidmap::Dict{E,Int}\n    m::Int\nend  A compact representation of the nonbacktracking operator  g: the underlying graph\nedgeidmap: the association between oriented edges and index into the NBT matrix  The Nonbacktracking operator can be used for community detection. This representation is compact in that it uses only ne(g) additional storage and provides an implicit representation of the matrix  B_g  defined below.  Given two oriented edges  i- j  and  k- l  in  g , the non-backtraking matrix  B  is defined as  B[i- j, k- l] = \u03b4(j,k)* (1 - \u03b4(i,l))  This type is in the style of GraphMatrices.jl and supports the necessary operations for computed eigenvectors and conducting linear solves.  Additionally the  contraction!(vertexspace, nbt, edgespace)  method takes vectors represented in the domain of  B  and represents them in the domain of the adjacency matrix of  g .  source  #  Erdos.nonbacktracking_matrix     Method .  nonbacktracking_matrix(g)  Given two oriented edges  i- j  and  k- l  in  g , the non-backtraking matrix  B  is defined as  B[i- j, k- l] = \u03b4(j,k)* (1 - \u03b4(i,l))  Returns a matrix  B , and an edgemap storing the oriented edges' positions in  B .  source", 
            "title": "Linear Algebra"
        }, 
        {
            "location": "/persistence/", 
            "text": "Reading and writing Graphs\n\n\nGraphs may be written to I/O streams and files using the \nwritegraph\n function and read with the \nreadgraph\n function. Currently supported common graph formats are \nGraphML\n, \nGML\n, \nGexf\n, \nDOT\n, \nPajek .net\n, \ngraph-tool gt\n. If fast I/O and small memory footprint is a priority, use the \n.gt\n binary format.\n\n\n\n\nExamples\n\n\nwritegraph(\nmygraph.gml\n, g) #format is inferred by the name\nwritegraph(\nmygraph.graphml\n, g)\n\ng = readgraph(\nmygraph.dot\n)\ng = readgraph(\nmygraph.net\n)\n\n\n\n\n#\n\n\nErdos.readgraph\n \n \nMethod\n.\n\n\nreadgraph(filename, G=Graph)\nreadgraph(filename, t, G=Graph; compressed=false)\n\n\n\n\nReads a graph from  \nfilename\n in the format \nt\n. Returns a graph of type \nG\n or the corresponding digraph/graph type. Compressed files can eventually be read.\n\n\nSupported formats are \n:gml, :dot, :graphml, :gexf, :net, :gt\n.\n\n\nIf no format is provided, it will be inferred from \nfilename\n.\n\n\nreadgraph(s::Symbol, G=Graph)\n\n\n\n\nRead a graph identified by \ns\n from Erdos datasets collection (e.g. \ns=:karate\n). They are stored in the \ngt\n binary format in the \ndatasets\n directory of the package. For a list of available graph refer to the documentation.\n\n\nsource\n\n\n#\n\n\nErdos.readnetwork\n \n \nMethod\n.\n\n\nreadnetwork(filename, G=Graph)\nreadnetwork(filename, t, G=Graph; compressed=false)\n\n\n\n\nReads a graph from  \nfilename\n in the format \nt\n. Returns a graph of type \nG\n or the corresponding digraph/graph type. Compressed files can eventually be read.\n\n\nSupported formats are \n:gml, :dot, :graphml, :gexf, :net, :gt\n.\n\n\nIf no format is provided, it will be inferred from \nfilename\n.\n\n\nreadnetwork(s::Symbol, G=Graph)\n\n\n\n\nRead a graph identified by \ns\n from Erdos datasets collection (e.g. \ns=:karate\n). They are stored in the \ngt\n binary format in the \ndatasets\n directory of the package. For a list of available graph refer to the documentation.\n\n\nsource\n\n\n#\n\n\nErdos.writegraph\n \n \nMethod\n.\n\n\nwritegraph(file, g)\nwritegraph(file, g, t; compress=false)\n\n\n\n\nSave a graph \ng\n to \nfile\n in the format \nt\n.\n\n\nEventually the resulting file can be compressed in the gzip format.\n\n\nCurrently supported formats are \n:gml, :graphml, :gexf, :dot, :net, :gt\n.\n\n\nIf no format is provided, it will be inferred from \nfile\n along with compression.\n\n\nsource\n\n\n#\n\n\nErdos.writenetwork\n \n \nMethod\n.\n\n\nwritenetwork(file, g)\nwritenetwork(file, g, t; compress=false)\n\n\n\n\nSave a graph \ng\n to \nfile\n in the format \nt\n.\n\n\nEventually the resulting file can be compressed in the gzip format.\n\n\nCurrently supported formats are \n:gml, :graphml, :gexf, :dot, :net, :gt\n.\n\n\nIf no format is provided, it will be inferred from \nfile\n along with compression.\n\n\nsource", 
            "title": "Reading / Writing Graphs"
        }, 
        {
            "location": "/persistence/#reading-and-writing-graphs", 
            "text": "Graphs may be written to I/O streams and files using the  writegraph  function and read with the  readgraph  function. Currently supported common graph formats are  GraphML ,  GML ,  Gexf ,  DOT ,  Pajek .net ,  graph-tool gt . If fast I/O and small memory footprint is a priority, use the  .gt  binary format.", 
            "title": "Reading and writing Graphs"
        }, 
        {
            "location": "/persistence/#examples", 
            "text": "writegraph( mygraph.gml , g) #format is inferred by the name\nwritegraph( mygraph.graphml , g)\n\ng = readgraph( mygraph.dot )\ng = readgraph( mygraph.net )  #  Erdos.readgraph     Method .  readgraph(filename, G=Graph)\nreadgraph(filename, t, G=Graph; compressed=false)  Reads a graph from   filename  in the format  t . Returns a graph of type  G  or the corresponding digraph/graph type. Compressed files can eventually be read.  Supported formats are  :gml, :dot, :graphml, :gexf, :net, :gt .  If no format is provided, it will be inferred from  filename .  readgraph(s::Symbol, G=Graph)  Read a graph identified by  s  from Erdos datasets collection (e.g.  s=:karate ). They are stored in the  gt  binary format in the  datasets  directory of the package. For a list of available graph refer to the documentation.  source  #  Erdos.readnetwork     Method .  readnetwork(filename, G=Graph)\nreadnetwork(filename, t, G=Graph; compressed=false)  Reads a graph from   filename  in the format  t . Returns a graph of type  G  or the corresponding digraph/graph type. Compressed files can eventually be read.  Supported formats are  :gml, :dot, :graphml, :gexf, :net, :gt .  If no format is provided, it will be inferred from  filename .  readnetwork(s::Symbol, G=Graph)  Read a graph identified by  s  from Erdos datasets collection (e.g.  s=:karate ). They are stored in the  gt  binary format in the  datasets  directory of the package. For a list of available graph refer to the documentation.  source  #  Erdos.writegraph     Method .  writegraph(file, g)\nwritegraph(file, g, t; compress=false)  Save a graph  g  to  file  in the format  t .  Eventually the resulting file can be compressed in the gzip format.  Currently supported formats are  :gml, :graphml, :gexf, :dot, :net, :gt .  If no format is provided, it will be inferred from  file  along with compression.  source  #  Erdos.writenetwork     Method .  writenetwork(file, g)\nwritenetwork(file, g, t; compress=false)  Save a graph  g  to  file  in the format  t .  Eventually the resulting file can be compressed in the gzip format.  Currently supported formats are  :gml, :graphml, :gexf, :dot, :net, :gt .  If no format is provided, it will be inferred from  file  along with compression.  source", 
            "title": "Examples"
        }, 
        {
            "location": "/datasets/", 
            "text": "Graphs Datasets\n\n\nThe \ndatasets folder\n contains real world graphs in the graph-tool format \n.gt\n, mostly collected by Tiago de Paula Peixoto. They are released under the GPLv3 license,\n\n\nThey can be read with\n\n\nreadgraph(s, G=Graph)\n\n\n\n\nwhere \ns\n is any of the symbols below and \nG\n is a (di)graph type. Here is a complete list of the graphs in the form\n\n\ns        |      N        |    E         |   directed | ....description....\n\n\n\n\n:adjnoun        |      112    |      425    |      false |      Word adjacencies: adjacency network of common  adjectives and nouns in the novel David Copperfield by Charles Dickens. Please cite M. E. J. Newman, Phys. Rev. E 74, 036104 (2006). Retrieved from \nMark Newman's website\n.\n\n\n:as22july06     |     22963   |     48436   |     false  |    Internet: a symmetrized snapshot of the structure of the Internet at the level of autonomous systems, reconstructed from BGP tables posted by the \nUniversity of Oregon Route Views Project\n. This snapshot was created by Mark Newman from data for July 22, 2006 and is not previously published. Retrieved from \nMark Newman's website\n.\n\n\n:astroph        |     16706   |     121251  |     false  |    Astrophysics collaborations: weighted network of coauthorships between scientists posting preprints on the Astrophysics E-Print Archive between Jan 1, 1995 and December 31, 1999. Please cite M. E. J. Newman, Proc. Natl. Acad. Sci. USA 98, 404-409 (2001). Retrieved from \nMark Newman's website\n.\n\n\n:celegansneural |      297    |      2359   |      true  |     Neural network: A directed, weighted network representing the neural network of C. Elegans. Data compiled by D. Watts and S. Strogatz and made available on the web \nhere\n. Please cite D. J. Watts and S. H. Strogatz, Nature 393, 440-442 (1998). Original experimental data taken from J. G. White, E. Southgate, J. N. Thompson, and S. Brenner, Phil. Trans. R. Soc. London 314, 1-340 (1986). Retrieved from \nMark Newman's website\n\n\n:condmat        |     16726   |     47594   |     false  |    Condensed matter collaborations 1999: weighted network of coauthorships between scientists posting preprints on the Condensed Matter E-Print Archive between Jan 1, 1995 and December 31, 1999. Please cite M. E. J. Newman, The structure of scientific collaboration networks, Proc. Natl. Acad. Sci. USA 98, 404-409 (2001). Retrieved from \nMark Newman's website\n\n\n:condmat2003    |    31163    |    120029   |    false   |   Condensed matter collaborations 2003: updated network of coauthorships between scientists posting preprints on the Condensed Matter E-Print Archive. This version includes all preprints posted between Jan 1, 1995 and June 30, 2003. The largest component of this network, which contains 27519 scientists, has been used by several authors as a test-bed for community-finding algorithms for large networks; see for example J. Duch and A. Arenas, Phys. Rev. E 72, 027104 (2005). These data can be cited as M. E. J. Newman, Proc. Natl. Acad. Sci. USA 98, 404-409 (2001). Retrieved from \nMark Newman's website\n.\n\n\n:condmat2005    |    40421    |    175693   |    false   |   Condensed matter collaborations 2005: updated network of coauthorships between scientists posting preprints on the Condensed Matter E-Print Archive. This version includes all preprints posted between Jan 1, 1995 and March 31, 2005. Please cite M. E. J. Newman, Proc. Natl. Acad. Sci. USA 98, 404-409 (2001). Retrieved from \nMark Newman's website\n.\n\n\n:dolphins       |      62     |      159    |      false |    Dolphin social network: an undirected social network of frequent associations between 62 dolphins in a community living off Doubtful Sound, New Zealand. Please cite D. Lusseau, K. Schneider, O. J. Boisseau, P. Haase, E. Slooten, and S. M. Dawson, Behavioral Ecology and Sociobiology 54, 396-405 (2003). Retrieved from \nMark Newman's website\n.\n\n\n:emailenron     |     36692   |     183831  |     false  |    Enron email communication network covers all the email communication within a dataset of around half million emails. This data was originally made public, and posted to the web, by the Federal Energy Regulatory Commission during its investigation. Nodes of the network are email addresses and if an address i sent at least one email to address j, the graph contains an undirected edge from i to j. Note that non-Enron email addresses act as sinks and sources in the network as we only observe their communication with the Enron email addresses. The Enron email data was \noriginally released\n by William Cohen at CMU. This version was retrieved from the SNAP database at http://snap.stanford.edu/data/email-Enron.html. Please cite: J. Leskovec, K. Lang, A. Dasgupta, M. Mahoney. Community Structure in Large Networks: Natural Cluster Sizes and the Absence of Large Well-Defined Clusters. Internet Mathematics 6(1) 29\u2013123, 2009,  B. Klimmt, Y. Yang. Introducing the Enron corpus. CEAS conference, 2004.\n\n\n:football       |      115    |      615    |      false |     American College football: network of American football games between Division IA colleges during regular season Fall 2000. Please cite M. Girvan and M. E. J. Newman, Proc. Natl. Acad. Sci. USA 99, 7821-7826 (2002), and T.S. Evans, \"Clique Graphs and Overlapping Communities\", J.Stat.Mech. (2010) P12037 [arXiv:1009.0638]. Retrieved from \nMark Newman's website\n, with corrections by T. S. Evans, available \nhere\n.\n\n\n:hepth          |     8361    |     15751   |     false  |    High-energy theory collaborations: weighted network of coauthorships between scientists posting preprints on the High-Energy Theory E-Print Archive between Jan 1, 1995 and December 31, 1999. Please cite M. E. J. Newman, Proc. Natl. Acad. Sci. USA 98, 404-409 (2001). Retrieved from \nMark Newman's website\n.\n\n\n:karate         |      34     |      78     |      false |     Zachary's karate club: social network of friendships between 34 members of a karate club at a US university in the 1970s. Please cite W. W. Zachary, An information flow model for conflict and fission in small groups, Journal of Anthropological Research 33, 452-473 (1977). Retrieved from \nMark Newman's website\n.\n\n\n:lesmis         |      77     |      254    |      false |     Les Miserables: coappearance network of characters in the novel Les Miserables. Please cite D. E. Knuth, The Stanford GraphBase: A Platform for Combinatorial Computing, Addison-Wesley, Reading, MA (1993). Retrieved from \nMark Newman's website\n.\n\n\n:netscience     |      1589   |      2742   |      false |     Coauthorships in network science: coauthorship network of scientists working on network theory and experiment, as compiled by M. Newman in May 2006. A figure depicting the largest component of this network can be found \nhere\n. These data can be cited as M. E. J. Newman, Phys. Rev. E 74, 036104 (2006). Retrieved from \nMark Newman's website\n.\n\n\n:pgpstrong2009  |    39796    |    301498   |    true    | Strongly connected component of the PGP web of trust circa November 2009. The full data is available at http://key-server.de/dump/. Please cite: Richters O, Peixoto TP (2011) Trust Transitivity in Social Networks. PLoS ONE 6(4): e18384. :doi:\n10.1371/journal.pone.0018384\n.\n\n\n:polblogs       |      1490   |      19090  |      true  |     Political blogs: A directed network of hyperlinks between weblogs on US politics, recorded in 2005 by Adamic and Glance. Please cite L. A. Adamic and N. Glance, \"The political blogosphere and the 2004 US Election\", in Proceedings of the WWW-2005 Workshop on the Weblogging Ecosystem (2005). Retrieved from \nMark Newman's website\n.\n\n\n:polbooks       |      105    |      441    |      false |     Books about US politics: A network of books about US politics published around the time of the 2004 presidential election and sold by the online bookseller Amazon.com. Edges between books represent frequent copurchasing of books by the same buyers. The network was compiled by V. Krebs and is unpublished, but can found on Krebs' \nweb site\n. Retrieved from \nMark Newman's website\n.\n\n\n:power          |      4941   |      6594   |      false |     Power grid: An undirected, unweighted network representing the topology of the Western States Power Grid of the United States. Data compiled by D. Watts and S. Strogatz and made available on the web \nhere\n. Please cite D. J. Watts and S. H. Strogatz, Nature 393, 440-442 (1998). Retrieved from \nMark Newman's website\n.\n\n\n:serengetifoodweb |   161     |     592     |     true   |    Plant and mammal food web from the Serengeti savanna ecosystem in Tanzania. Please cite: Baskerville EB, Dobson AP, Bedford T, Allesina S, Anderson TM, et al. (2011) Spatial Guilds in the Serengeti Food Web Revealed by a Bayesian :doi:\n10.1371/journal.pcbi.1002321\n Group Model. PLoS Comput Biol 7(12): e1002321", 
            "title": "Graph Datasets"
        }, 
        {
            "location": "/datasets/#graphs-datasets", 
            "text": "The  datasets folder  contains real world graphs in the graph-tool format  .gt , mostly collected by Tiago de Paula Peixoto. They are released under the GPLv3 license,  They can be read with  readgraph(s, G=Graph)  where  s  is any of the symbols below and  G  is a (di)graph type. Here is a complete list of the graphs in the form  s        |      N        |    E         |   directed | ....description....   :adjnoun        |      112    |      425    |      false |      Word adjacencies: adjacency network of common  adjectives and nouns in the novel David Copperfield by Charles Dickens. Please cite M. E. J. Newman, Phys. Rev. E 74, 036104 (2006). Retrieved from  Mark Newman's website .  :as22july06     |     22963   |     48436   |     false  |    Internet: a symmetrized snapshot of the structure of the Internet at the level of autonomous systems, reconstructed from BGP tables posted by the  University of Oregon Route Views Project . This snapshot was created by Mark Newman from data for July 22, 2006 and is not previously published. Retrieved from  Mark Newman's website .  :astroph        |     16706   |     121251  |     false  |    Astrophysics collaborations: weighted network of coauthorships between scientists posting preprints on the Astrophysics E-Print Archive between Jan 1, 1995 and December 31, 1999. Please cite M. E. J. Newman, Proc. Natl. Acad. Sci. USA 98, 404-409 (2001). Retrieved from  Mark Newman's website .  :celegansneural |      297    |      2359   |      true  |     Neural network: A directed, weighted network representing the neural network of C. Elegans. Data compiled by D. Watts and S. Strogatz and made available on the web  here . Please cite D. J. Watts and S. H. Strogatz, Nature 393, 440-442 (1998). Original experimental data taken from J. G. White, E. Southgate, J. N. Thompson, and S. Brenner, Phil. Trans. R. Soc. London 314, 1-340 (1986). Retrieved from  Mark Newman's website  :condmat        |     16726   |     47594   |     false  |    Condensed matter collaborations 1999: weighted network of coauthorships between scientists posting preprints on the Condensed Matter E-Print Archive between Jan 1, 1995 and December 31, 1999. Please cite M. E. J. Newman, The structure of scientific collaboration networks, Proc. Natl. Acad. Sci. USA 98, 404-409 (2001). Retrieved from  Mark Newman's website  :condmat2003    |    31163    |    120029   |    false   |   Condensed matter collaborations 2003: updated network of coauthorships between scientists posting preprints on the Condensed Matter E-Print Archive. This version includes all preprints posted between Jan 1, 1995 and June 30, 2003. The largest component of this network, which contains 27519 scientists, has been used by several authors as a test-bed for community-finding algorithms for large networks; see for example J. Duch and A. Arenas, Phys. Rev. E 72, 027104 (2005). These data can be cited as M. E. J. Newman, Proc. Natl. Acad. Sci. USA 98, 404-409 (2001). Retrieved from  Mark Newman's website .  :condmat2005    |    40421    |    175693   |    false   |   Condensed matter collaborations 2005: updated network of coauthorships between scientists posting preprints on the Condensed Matter E-Print Archive. This version includes all preprints posted between Jan 1, 1995 and March 31, 2005. Please cite M. E. J. Newman, Proc. Natl. Acad. Sci. USA 98, 404-409 (2001). Retrieved from  Mark Newman's website .  :dolphins       |      62     |      159    |      false |    Dolphin social network: an undirected social network of frequent associations between 62 dolphins in a community living off Doubtful Sound, New Zealand. Please cite D. Lusseau, K. Schneider, O. J. Boisseau, P. Haase, E. Slooten, and S. M. Dawson, Behavioral Ecology and Sociobiology 54, 396-405 (2003). Retrieved from  Mark Newman's website .  :emailenron     |     36692   |     183831  |     false  |    Enron email communication network covers all the email communication within a dataset of around half million emails. This data was originally made public, and posted to the web, by the Federal Energy Regulatory Commission during its investigation. Nodes of the network are email addresses and if an address i sent at least one email to address j, the graph contains an undirected edge from i to j. Note that non-Enron email addresses act as sinks and sources in the network as we only observe their communication with the Enron email addresses. The Enron email data was  originally released  by William Cohen at CMU. This version was retrieved from the SNAP database at http://snap.stanford.edu/data/email-Enron.html. Please cite: J. Leskovec, K. Lang, A. Dasgupta, M. Mahoney. Community Structure in Large Networks: Natural Cluster Sizes and the Absence of Large Well-Defined Clusters. Internet Mathematics 6(1) 29\u2013123, 2009,  B. Klimmt, Y. Yang. Introducing the Enron corpus. CEAS conference, 2004.  :football       |      115    |      615    |      false |     American College football: network of American football games between Division IA colleges during regular season Fall 2000. Please cite M. Girvan and M. E. J. Newman, Proc. Natl. Acad. Sci. USA 99, 7821-7826 (2002), and T.S. Evans, \"Clique Graphs and Overlapping Communities\", J.Stat.Mech. (2010) P12037 [arXiv:1009.0638]. Retrieved from  Mark Newman's website , with corrections by T. S. Evans, available  here .  :hepth          |     8361    |     15751   |     false  |    High-energy theory collaborations: weighted network of coauthorships between scientists posting preprints on the High-Energy Theory E-Print Archive between Jan 1, 1995 and December 31, 1999. Please cite M. E. J. Newman, Proc. Natl. Acad. Sci. USA 98, 404-409 (2001). Retrieved from  Mark Newman's website .  :karate         |      34     |      78     |      false |     Zachary's karate club: social network of friendships between 34 members of a karate club at a US university in the 1970s. Please cite W. W. Zachary, An information flow model for conflict and fission in small groups, Journal of Anthropological Research 33, 452-473 (1977). Retrieved from  Mark Newman's website .  :lesmis         |      77     |      254    |      false |     Les Miserables: coappearance network of characters in the novel Les Miserables. Please cite D. E. Knuth, The Stanford GraphBase: A Platform for Combinatorial Computing, Addison-Wesley, Reading, MA (1993). Retrieved from  Mark Newman's website .  :netscience     |      1589   |      2742   |      false |     Coauthorships in network science: coauthorship network of scientists working on network theory and experiment, as compiled by M. Newman in May 2006. A figure depicting the largest component of this network can be found  here . These data can be cited as M. E. J. Newman, Phys. Rev. E 74, 036104 (2006). Retrieved from  Mark Newman's website .  :pgpstrong2009  |    39796    |    301498   |    true    | Strongly connected component of the PGP web of trust circa November 2009. The full data is available at http://key-server.de/dump/. Please cite: Richters O, Peixoto TP (2011) Trust Transitivity in Social Networks. PLoS ONE 6(4): e18384. :doi: 10.1371/journal.pone.0018384 .  :polblogs       |      1490   |      19090  |      true  |     Political blogs: A directed network of hyperlinks between weblogs on US politics, recorded in 2005 by Adamic and Glance. Please cite L. A. Adamic and N. Glance, \"The political blogosphere and the 2004 US Election\", in Proceedings of the WWW-2005 Workshop on the Weblogging Ecosystem (2005). Retrieved from  Mark Newman's website .  :polbooks       |      105    |      441    |      false |     Books about US politics: A network of books about US politics published around the time of the 2004 presidential election and sold by the online bookseller Amazon.com. Edges between books represent frequent copurchasing of books by the same buyers. The network was compiled by V. Krebs and is unpublished, but can found on Krebs'  web site . Retrieved from  Mark Newman's website .  :power          |      4941   |      6594   |      false |     Power grid: An undirected, unweighted network representing the topology of the Western States Power Grid of the United States. Data compiled by D. Watts and S. Strogatz and made available on the web  here . Please cite D. J. Watts and S. H. Strogatz, Nature 393, 440-442 (1998). Retrieved from  Mark Newman's website .  :serengetifoodweb |   161     |     592     |     true   |    Plant and mammal food web from the Serengeti savanna ecosystem in Tanzania. Please cite: Baskerville EB, Dobson AP, Bedford T, Allesina S, Anderson TM, et al. (2011) Spatial Guilds in the Serengeti Food Web Revealed by a Bayesian :doi: 10.1371/journal.pcbi.1002321  Group Model. PLoS Comput Biol 7(12): e1002321", 
            "title": "Graphs Datasets"
        }, 
        {
            "location": "/deterministicgraphs/", 
            "text": "Deterministic Graph Generators\n\n\n\n\nStatic Graphs\n\n\nErdos.jl\n implements a collection of classic graph generators:\n\n\n#\n\n\nErdos.BinaryTree\n \n \nMethod\n.\n\n\nBinaryTree(levels, G=Graph)\n\n\n\n\nCreates a binary tree with k-levels vertices are numbered 1:2^levels-1\n\n\nsource\n\n\n#\n\n\nErdos.CliqueGraph\n \n \nMethod\n.\n\n\nCliqueGraph(k, n, G=Graph)\n\n\n\n\nThis function generates a graph with \nn\n \nk\n-cliques connected circularly by \nn\n edges.\n\n\nsource\n\n\n#\n\n\nErdos.CompleteBipartiteGraph\n \n \nMethod\n.\n\n\nCompleteBipartiteGraph(n1, n2, G = Graph)\n\n\n\n\nCreates a complete bipartite graph with \nn1+n2\n vertices. It has edges connecting each pair of vertices in the two sets.\n\n\nsource\n\n\n#\n\n\nErdos.CompleteDiGraph\n \n \nMethod\n.\n\n\nCompleteDiGraph(n, G = DiGraph)\n\n\n\n\nCreates a complete digraph with \nn\n vertices. A complete digraph has edges connecting each pair of vertices (both an ingoing and outgoing edge).\n\n\nsource\n\n\n#\n\n\nErdos.CompleteGraph\n \n \nMethod\n.\n\n\nCompleteGraph(n, G = Graph)\n\n\n\n\nCreates a complete graph of type \nG\n with \nn\n vertices. A complete graph has edges connecting each pair of vertices.\n\n\nsource\n\n\n#\n\n\nErdos.CycleDiGraph\n \n \nMethod\n.\n\n\nCreates a cycle digraph with \nn\n vertices. A cycle digraph is a closed path digraph.\n\n\nsource\n\n\n#\n\n\nErdos.CycleGraph\n \n \nMethod\n.\n\n\nCycleGraph(n, G=Graph)\n\n\n\n\nCreates a cycle graph with \nn\n vertices. A cycle graph is a closed path graph.\n\n\nsource\n\n\n#\n\n\nErdos.DoubleBinaryTree\n \n \nMethod\n.\n\n\nDoubleBinaryTree(levels, G=Graph)\n\n\n\n\nCreate a double complete binary tree with k-levels used as an example for spectral clustering by Guattery and Miller 1998.\n\n\nsource\n\n\n#\n\n\nErdos.Grid\n \n \nMethod\n.\n\n\nGrid(dims::AbstractVector, G=Graph; periodic=false)\n\n\n\n\nCreates a \nd\n-dimensional cubic lattice, with \nd=length(dims)\n and length  \ndims[i]\n in dimension \ni\n. If \nperiodic=true\n the resulting lattice will have periodic boundary condition in each dimension.\n\n\nsource\n\n\n#\n\n\nErdos.PathDiGraph\n \n \nMethod\n.\n\n\nPathDiGraph(n, G = DiGraph)\n\n\n\n\nCreates a path digraph with \nn\n vertices. A path graph connects each successive vertex by a single directed edge.\n\n\nsource\n\n\n#\n\n\nErdos.PathGraph\n \n \nMethod\n.\n\n\nPathGraph(n, G = Graph)\n\n\n\n\nCreates a path graph with \nn\n vertices. A path graph connects each successive vertex by a single edge.\n\n\nsource\n\n\n#\n\n\nErdos.RoachGraph\n \n \nMethod\n.\n\n\nThe Roach Graph from Guattery and Miller 1998\n\n\nsource\n\n\n#\n\n\nErdos.StarDiGraph\n \n \nMethod\n.\n\n\nCreates a star digraph with \nn\n vertices. A star digraph has a central vertex with directed edges to every other vertex.\n\n\nsource\n\n\n#\n\n\nErdos.StarGraph\n \n \nMethod\n.\n\n\nStarGraph(n, G = Graph)\n\n\n\n\nCreates a star graph with \nn\n vertices. A star graph has a central vertex with edges to each other vertex.\n\n\nsource\n\n\n#\n\n\nErdos.WheelDiGraph\n \n \nMethod\n.\n\n\nCreates a wheel digraph with \nn\n vertices. A wheel graph is a star digraph with the outer vertices connected via a closed path graph.\n\n\nsource\n\n\n#\n\n\nErdos.WheelGraph\n \n \nMethod\n.\n\n\nWheelGraph(n, G=Graph)\n\n\n\n\nCreates a wheel graph with \nn\n vertices. A wheel graph is a star graph with the outer vertices connected via a closed path graph.\n\n\nsource\n\n\n\n\nSmall Graphs\n\n\nOther classical graphs can be generated by the following function:\n\n\n#\n\n\nErdos.digraph\n \n \nMethod\n.\n\n\ndigraph{G\n:AGraph}(n, edgelist::Vector{Tuple{Int,Int}},\n    G = Graph)\n\n\n\n\nBuild a digraph with \nn\n vertices, type \nG\n, and given \nedgelist\n.\n\n\nsource\n\n\n#\n\n\nErdos.digraph\n \n \nMethod\n.\n\n\ndigraph(s::Symbol, G = DiGraph)\n\n\n\n\nCreates a notorious digraph \ns\n of type \nG\n. Admissible values for \ns\n are:\n\n\n\n\n\n\n\n\ns\n\n\ngraph type\n\n\n\n\n\n\n\n\n\n\n:truncatedtetrahedron\n\n\nA skeleton of the \ntruncated tetrahedron digraph\n.\n\n\n\n\n\n\n\n\nsource\n\n\n#\n\n\nErdos.graph\n \n \nMethod\n.\n\n\ngraph{G\n:AGraph}(n, edgelist::Vector{Tuple{Int,Int}},\n    G = Graph)\n\n\n\n\nBuild a graph with \nn\n vertices, of type \nG\n, and given \nedgelist\n.\n\n\nsource\n\n\n#\n\n\nErdos.graph\n \n \nMethod\n.\n\n\ngraph(s::Symbol, G = Graph)\n\n\n\n\nCreates a notorious graph \ns\n of type \nG\n. Admissible values for \ns\n are:\n\n\n\n\n\n\n\n\ns\n\n\ngraph type\n\n\n\n\n\n\n\n\n\n\n:bull\n\n\nA \nbull graph\n.\n\n\n\n\n\n\n:chvatal\n\n\nA \nChv\u00e1tal graph\n.\n\n\n\n\n\n\n:cubical\n\n\nA \nPlatonic cubical graph\n.\n\n\n\n\n\n\n:desargues\n\n\nA \nDesarguesgraph\n.\n\n\n\n\n\n\n:diamond\n\n\nA \ndiamond graph\n.\n\n\n\n\n\n\n:dodecahedral\n\n\nA \nPlatonic dodecahedral  graph\n.\n\n\n\n\n\n\n:frucht\n\n\nA \nFrucht graph\n.\n\n\n\n\n\n\n:heawood\n\n\nA \nHeawood graph\n.\n\n\n\n\n\n\n:house\n\n\nA graph mimicing the classic outline of a house.\n\n\n\n\n\n\n:housex\n\n\nA house graph, with two edges crossing the bottom square.\n\n\n\n\n\n\n:icosahedral\n\n\nA \nPlatonic icosahedral   graph\n.\n\n\n\n\n\n\n:krackhardtkite\n\n\nA \nKrackhardt-Kite social network  graph\n.\n\n\n\n\n\n\n:moebiuskantor\n\n\nA \nM\u00f6bius-Kantor graph\n.\n\n\n\n\n\n\n:octahedral\n\n\nA \nPlatonic octahedral graph\n.\n\n\n\n\n\n\n:pappus\n\n\nA \nPappus graph\n.\n\n\n\n\n\n\n:petersen\n\n\nA \nPetersen graph\n.\n\n\n\n\n\n\n:sedgewickmaze\n\n\nA simple maze graph used in Sedgewick's \nAlgorithms in C++: Graph  Algorithms (3rd ed.)\n\n\n\n\n\n\n:tetrahedral\n\n\nA \nPlatonic tetrahedral  graph\n.\n\n\n\n\n\n\n:truncatedcube\n\n\nA skeleton of the \ntruncated cube graph\n.\n\n\n\n\n\n\n:truncatedtetrahedron\n\n\nA skeleton of the \ntruncated tetrahedron  graph\n.\n\n\n\n\n\n\n:tutte\n\n\nA \nTutte graph\n.\n\n\n\n\n\n\n\n\nA collection of real world graphs is available through the \nreadgraph\n function.\n\n\nsource\n\n\n\n\nEuclidean Graphs\n\n\nGeneration of random and static graphs embedded in Euclidean space.\n\n\n#\n\n\nErdos.euclidean_graph\n \n \nMethod\n.\n\n\neuclidean_graph(points::Matrix, G; L=1., p=2., cutoff=Inf, bc=:periodic)\n\n\n\n\nGiven the \nd\u00d7N\n matrix \npoints\n builds an Euclidean graph of \nN\n vertices according to the following procedure.\n\n\nDefining the \nd\n-dimensional vectors \nx[i] = points[:,i]\n, an edge between vertices \ni\n and \nj\n is inserted if \nnorm(x[i]-x[j], p) \n cutoff\n. In case of negative \ncutoff\n instead every edge is inserted. For \np=2\n we have the standard Euclidean distance. Set \nbc=:periodic\n to impose periodic boundary conditions in the box $[0,L]^d$. Set \nbc=:open\n for open boundary condition. In this case the keyword argument \nL\n will be ignored.\n\n\nReturns a graph and Dict containing the distance on each edge.\n\n\nsource", 
            "title": "Deterministic Graphs"
        }, 
        {
            "location": "/deterministicgraphs/#deterministic-graph-generators", 
            "text": "", 
            "title": "Deterministic Graph Generators"
        }, 
        {
            "location": "/deterministicgraphs/#static-graphs", 
            "text": "Erdos.jl  implements a collection of classic graph generators:  #  Erdos.BinaryTree     Method .  BinaryTree(levels, G=Graph)  Creates a binary tree with k-levels vertices are numbered 1:2^levels-1  source  #  Erdos.CliqueGraph     Method .  CliqueGraph(k, n, G=Graph)  This function generates a graph with  n   k -cliques connected circularly by  n  edges.  source  #  Erdos.CompleteBipartiteGraph     Method .  CompleteBipartiteGraph(n1, n2, G = Graph)  Creates a complete bipartite graph with  n1+n2  vertices. It has edges connecting each pair of vertices in the two sets.  source  #  Erdos.CompleteDiGraph     Method .  CompleteDiGraph(n, G = DiGraph)  Creates a complete digraph with  n  vertices. A complete digraph has edges connecting each pair of vertices (both an ingoing and outgoing edge).  source  #  Erdos.CompleteGraph     Method .  CompleteGraph(n, G = Graph)  Creates a complete graph of type  G  with  n  vertices. A complete graph has edges connecting each pair of vertices.  source  #  Erdos.CycleDiGraph     Method .  Creates a cycle digraph with  n  vertices. A cycle digraph is a closed path digraph.  source  #  Erdos.CycleGraph     Method .  CycleGraph(n, G=Graph)  Creates a cycle graph with  n  vertices. A cycle graph is a closed path graph.  source  #  Erdos.DoubleBinaryTree     Method .  DoubleBinaryTree(levels, G=Graph)  Create a double complete binary tree with k-levels used as an example for spectral clustering by Guattery and Miller 1998.  source  #  Erdos.Grid     Method .  Grid(dims::AbstractVector, G=Graph; periodic=false)  Creates a  d -dimensional cubic lattice, with  d=length(dims)  and length   dims[i]  in dimension  i . If  periodic=true  the resulting lattice will have periodic boundary condition in each dimension.  source  #  Erdos.PathDiGraph     Method .  PathDiGraph(n, G = DiGraph)  Creates a path digraph with  n  vertices. A path graph connects each successive vertex by a single directed edge.  source  #  Erdos.PathGraph     Method .  PathGraph(n, G = Graph)  Creates a path graph with  n  vertices. A path graph connects each successive vertex by a single edge.  source  #  Erdos.RoachGraph     Method .  The Roach Graph from Guattery and Miller 1998  source  #  Erdos.StarDiGraph     Method .  Creates a star digraph with  n  vertices. A star digraph has a central vertex with directed edges to every other vertex.  source  #  Erdos.StarGraph     Method .  StarGraph(n, G = Graph)  Creates a star graph with  n  vertices. A star graph has a central vertex with edges to each other vertex.  source  #  Erdos.WheelDiGraph     Method .  Creates a wheel digraph with  n  vertices. A wheel graph is a star digraph with the outer vertices connected via a closed path graph.  source  #  Erdos.WheelGraph     Method .  WheelGraph(n, G=Graph)  Creates a wheel graph with  n  vertices. A wheel graph is a star graph with the outer vertices connected via a closed path graph.  source", 
            "title": "Static Graphs"
        }, 
        {
            "location": "/deterministicgraphs/#small-graphs", 
            "text": "Other classical graphs can be generated by the following function:  #  Erdos.digraph     Method .  digraph{G :AGraph}(n, edgelist::Vector{Tuple{Int,Int}},\n    G = Graph)  Build a digraph with  n  vertices, type  G , and given  edgelist .  source  #  Erdos.digraph     Method .  digraph(s::Symbol, G = DiGraph)  Creates a notorious digraph  s  of type  G . Admissible values for  s  are:     s  graph type      :truncatedtetrahedron  A skeleton of the  truncated tetrahedron digraph .     source  #  Erdos.graph     Method .  graph{G :AGraph}(n, edgelist::Vector{Tuple{Int,Int}},\n    G = Graph)  Build a graph with  n  vertices, of type  G , and given  edgelist .  source  #  Erdos.graph     Method .  graph(s::Symbol, G = Graph)  Creates a notorious graph  s  of type  G . Admissible values for  s  are:     s  graph type      :bull  A  bull graph .    :chvatal  A  Chv\u00e1tal graph .    :cubical  A  Platonic cubical graph .    :desargues  A  Desarguesgraph .    :diamond  A  diamond graph .    :dodecahedral  A  Platonic dodecahedral  graph .    :frucht  A  Frucht graph .    :heawood  A  Heawood graph .    :house  A graph mimicing the classic outline of a house.    :housex  A house graph, with two edges crossing the bottom square.    :icosahedral  A  Platonic icosahedral   graph .    :krackhardtkite  A  Krackhardt-Kite social network  graph .    :moebiuskantor  A  M\u00f6bius-Kantor graph .    :octahedral  A  Platonic octahedral graph .    :pappus  A  Pappus graph .    :petersen  A  Petersen graph .    :sedgewickmaze  A simple maze graph used in Sedgewick's  Algorithms in C++: Graph  Algorithms (3rd ed.)    :tetrahedral  A  Platonic tetrahedral  graph .    :truncatedcube  A skeleton of the  truncated cube graph .    :truncatedtetrahedron  A skeleton of the  truncated tetrahedron  graph .    :tutte  A  Tutte graph .     A collection of real world graphs is available through the  readgraph  function.  source", 
            "title": "Small Graphs"
        }, 
        {
            "location": "/deterministicgraphs/#euclidean-graphs", 
            "text": "Generation of random and static graphs embedded in Euclidean space.  #  Erdos.euclidean_graph     Method .  euclidean_graph(points::Matrix, G; L=1., p=2., cutoff=Inf, bc=:periodic)  Given the  d\u00d7N  matrix  points  builds an Euclidean graph of  N  vertices according to the following procedure.  Defining the  d -dimensional vectors  x[i] = points[:,i] , an edge between vertices  i  and  j  is inserted if  norm(x[i]-x[j], p)   cutoff . In case of negative  cutoff  instead every edge is inserted. For  p=2  we have the standard Euclidean distance. Set  bc=:periodic  to impose periodic boundary conditions in the box $[0,L]^d$. Set  bc=:open  for open boundary condition. In this case the keyword argument  L  will be ignored.  Returns a graph and Dict containing the distance on each edge.  source", 
            "title": "Euclidean Graphs"
        }, 
        {
            "location": "/randomgraphs/", 
            "text": "Random Graphs Generators\n\n\nErdos.jl\n implements some common random graph generators:\n\n\n#\n\n\nErdos.barabasi_albert!\n \n \nMethod\n.\n\n\nbarabasi_albert!(g, n::Int, k::Int; seed::Int = -1)\n\n\n\n\nGrows the graph \ng\n according to \nBarab\u00e1si\u2013Albert\n process into a graph with \nn\n vertices. At each step a new vertex is attached by preferential attachment to \nk\n different vertices already present in the graph.\n\n\nSee also \nbarabasi_albert\n.\n\n\nsource\n\n\n#\n\n\nErdos.barabasi_albert\n \n \nMethod\n.\n\n\nbarabasi_albert(n, k, G=Graph; seed=-1)\nbarabasi_albert(n, n0, k, G=Graph; seed=-1)\n\n\n\n\nCreates a random graph of type \nG\n with \nn\n vertices according to \nBarab\u00e1si\u2013Albert model\n. It is grown by adding new vertices to an initial graph with \nn0\n vertices (\nn0=k\n if not specified). Each new vertex is attached with \nk\n edges to \nk\n different vertices already present in the system by preferential attachment. The initial graph is empty by default.\n\n\nUndirected graphs are created by default. Directed graphs can be created passing a directed graph type as last argument (e.g. \nDiGraph\n).\n\n\nSee also \nbarabasi_albert!\n for growing a given graph.\n\n\nsource\n\n\n#\n\n\nErdos.erdos_renyi\n \n \nMethod\n.\n\n\nerdos_renyi(n::Int, p::Real, G=Graph; seed=-1)\nerdos_renyi(n::Int, m::Int, G=Graph; seed=-1)\n\n\n\n\nCreates an \nErd\u0151s\u2013R\u00e9nyi\n random graph of type \nG\n with \nn\n vertices. Edges are added between pairs of vertices with probability \np\n in the first method. In the second method \nm\n edges are randomly chosen insted.\n\n\nUndirected graphs are created by default. Directed graphs can be created passing a directed graph type as last argument (e.g. \nDiGraph\n)\n\n\nNote also that Erd\u0151s\u2013R\u00e9nyi graphs may be generated quickly using \nerdos_renyi(n, ne)\n or the  \nGraph(nv, ne)\n constructor, which randomly select \nne\n edges among all the potential edges.\n\n\nsource\n\n\n#\n\n\nErdos.random_configuration_model\n \n \nMethod\n.\n\n\nrandom_configuration_model(n::Int, k::Vector{Int}; seed=-1, check_graphical=false)\n\n\n\n\nCreates a random undirected graph according to the \nconfiguraton model\n. It contains \nn\n vertices, the vertex \ni\n having degree \nk[i]\n.\n\n\nDefining \nc = mean(k)\n, it allocates an array of \nnc\n \nInt\ns, and takes approximately $nc^2$ time.\n\n\nIf \ncheck_graphical=true\n makes sure that \nk\n is a graphical sequence (see \nis_graphical\n).\n\n\nsource\n\n\n#\n\n\nErdos.random_regular_digraph\n \n \nMethod\n.\n\n\nrandom_regular_digraph(n::Int, k::Int; dir::Symbol=:out, seed=-1)\n\n\n\n\nCreates a random directed \nregular graph\n with \nn\n vertices, each with degree \nk\n. The degree (in or out) can be specified using \ndir=:in\n or \ndir=:out\n. The default is \ndir=:out\n.\n\n\nFor directed graphs, allocates an $n    imes n$ sparse matrix of boolean as an adjacency matrix and uses that to generate the directed graph.\n\n\nsource\n\n\n#\n\n\nErdos.random_regular_graph\n \n \nMethod\n.\n\n\nrandom_regular_graph(n::Int, k::Int; seed=-1)\n\n\n\n\nCreates a random undirected \nregular graph\n with \nn\n vertices, each with degree \nk\n.\n\n\nFor undirected graphs, allocates an array of \nnk\n \nInt\ns, and takes approximately $nk^2$ time. For $k \n n/2$, generates a graph of degree \nn-k-1\n and returns its complement.\n\n\nsource\n\n\n#\n\n\nErdos.static_fitness_model\n \n \nMethod\n.\n\n\nstatic_fitness_model(m, fitness, G=Graph; seed=-1)\nstatic_fitness_model(m, fitness_out, fitness_in, G=DiGraph; seed=-1)\n\n\n\n\nGenerates a random graph with \nlength(fitness)\n nodes and \nm\n edges, in which the probability of the existence of edge \n(i, j)\n is proportional to \nfitness[i]*fitness[j]\n. Time complexity is O(|V| + |E| log |E|).\n\n\nIn and out fitness have to be supplied for generating directed graphs.\n\n\nReference:\n\n\n\n\nGoh K-I, Kahng B, Kim D: Universal behaviour of load distribution\n\n\n\n\nin scale-free networks. Phys Rev Lett 87(27):278701, 2001.\n\n\nsource\n\n\n#\n\n\nErdos.static_scale_free\n \n \nMethod\n.\n\n\nfunction static_scale_free(n, m, \u03b1, G=Graph;\n        seed=-1, finite_size_correction=true)\n\n\n\n\nGenerates a random graph with \nn\n vertices, \nm\n edges and expected power-law degree distribution with exponent \n\u03b1\n. \nfinite_size_correction\n determines whether to use the finite size correction proposed by Cho et al. This generator calls internally the \nstatic_fitness_model function\n. Time complexity is O(|V| + |E| log |E|).\n\n\nfunction static_scale_free(n, m, \u03b1_out, \u03b1_in, G=DiGraph;\n        seed=-1, finite_size_correction=true)\n\n\n\n\nGenerates a random digraph\n\n\nReferences:\n\n\n\n\nGoh K-I, Kahng B, Kim D: Universal behaviour of load distribution in scale-free networks. Phys Rev Lett 87(27):278701, 2001.\n\n\nChung F and Lu L: Connected components in a random graph with given degree sequences. Annals of Combinatorics 6, 125-145, 2002.\n\n\nCho YS, Kim JS, Park J, Kahng B, Kim D: Percolation transitions in scale-free networks under the Achlioptas process. Phys Rev Lett 103:135702, 2009.\n\n\n\n\nsource\n\n\n#\n\n\nErdos.stochastic_block_model\n \n \nMethod\n.\n\n\nstochastic_block_model(c::Matrix{Float64}, n::Vector{Int}; seed::Int = -1)\nstochastic_block_model(cin::Float64, coff::Float64, n::Vector{Int}; seed::Int = -1)\n\n\n\n\nReturns a Graph generated according to the Stochastic Block Model (SBM).\n\n\nc[a,b]\n : Mean number of neighbors of a vertex in block \na\n belonging to block \nb\n.            Only the upper triangular part is considered, since the lower traingular is            determined by $c[b,a] = c[a,b] * n[a]/n[b]$. \nn[a]\n : Number of vertices in block \na\n\n\nThe second form samples from a SBM with \nc[a,a]=cin\n, and \nc[a,b]=coff\n.\n\n\nFor a dynamic version of the SBM see the \nStochasticBlockModel\n type and related functions.\n\n\nsource\n\n\n#\n\n\nErdos.watts_strogatz\n \n \nMethod\n.\n\n\nwatts_strogatz(n, k, \u03b2, G=Graph; seed=-1)\n\n\n\n\nCreates a \nWatts-Strogatz\n small model random graph with \nn\n vertices, each with degree \nk\n. Edges are randomized per the model based on probability \n\u03b2\n.\n\n\nUndirected graphs are created by default. Directed graphs can be created passing a directed graph type as last argument (e.g. \nDiGraph\n).\n\n\nsource", 
            "title": "Random Graphs"
        }, 
        {
            "location": "/randomgraphs/#random-graphs-generators", 
            "text": "Erdos.jl  implements some common random graph generators:  #  Erdos.barabasi_albert!     Method .  barabasi_albert!(g, n::Int, k::Int; seed::Int = -1)  Grows the graph  g  according to  Barab\u00e1si\u2013Albert  process into a graph with  n  vertices. At each step a new vertex is attached by preferential attachment to  k  different vertices already present in the graph.  See also  barabasi_albert .  source  #  Erdos.barabasi_albert     Method .  barabasi_albert(n, k, G=Graph; seed=-1)\nbarabasi_albert(n, n0, k, G=Graph; seed=-1)  Creates a random graph of type  G  with  n  vertices according to  Barab\u00e1si\u2013Albert model . It is grown by adding new vertices to an initial graph with  n0  vertices ( n0=k  if not specified). Each new vertex is attached with  k  edges to  k  different vertices already present in the system by preferential attachment. The initial graph is empty by default.  Undirected graphs are created by default. Directed graphs can be created passing a directed graph type as last argument (e.g.  DiGraph ).  See also  barabasi_albert!  for growing a given graph.  source  #  Erdos.erdos_renyi     Method .  erdos_renyi(n::Int, p::Real, G=Graph; seed=-1)\nerdos_renyi(n::Int, m::Int, G=Graph; seed=-1)  Creates an  Erd\u0151s\u2013R\u00e9nyi  random graph of type  G  with  n  vertices. Edges are added between pairs of vertices with probability  p  in the first method. In the second method  m  edges are randomly chosen insted.  Undirected graphs are created by default. Directed graphs can be created passing a directed graph type as last argument (e.g.  DiGraph )  Note also that Erd\u0151s\u2013R\u00e9nyi graphs may be generated quickly using  erdos_renyi(n, ne)  or the   Graph(nv, ne)  constructor, which randomly select  ne  edges among all the potential edges.  source  #  Erdos.random_configuration_model     Method .  random_configuration_model(n::Int, k::Vector{Int}; seed=-1, check_graphical=false)  Creates a random undirected graph according to the  configuraton model . It contains  n  vertices, the vertex  i  having degree  k[i] .  Defining  c = mean(k) , it allocates an array of  nc   Int s, and takes approximately $nc^2$ time.  If  check_graphical=true  makes sure that  k  is a graphical sequence (see  is_graphical ).  source  #  Erdos.random_regular_digraph     Method .  random_regular_digraph(n::Int, k::Int; dir::Symbol=:out, seed=-1)  Creates a random directed  regular graph  with  n  vertices, each with degree  k . The degree (in or out) can be specified using  dir=:in  or  dir=:out . The default is  dir=:out .  For directed graphs, allocates an $n    imes n$ sparse matrix of boolean as an adjacency matrix and uses that to generate the directed graph.  source  #  Erdos.random_regular_graph     Method .  random_regular_graph(n::Int, k::Int; seed=-1)  Creates a random undirected  regular graph  with  n  vertices, each with degree  k .  For undirected graphs, allocates an array of  nk   Int s, and takes approximately $nk^2$ time. For $k   n/2$, generates a graph of degree  n-k-1  and returns its complement.  source  #  Erdos.static_fitness_model     Method .  static_fitness_model(m, fitness, G=Graph; seed=-1)\nstatic_fitness_model(m, fitness_out, fitness_in, G=DiGraph; seed=-1)  Generates a random graph with  length(fitness)  nodes and  m  edges, in which the probability of the existence of edge  (i, j)  is proportional to  fitness[i]*fitness[j] . Time complexity is O(|V| + |E| log |E|).  In and out fitness have to be supplied for generating directed graphs.  Reference:   Goh K-I, Kahng B, Kim D: Universal behaviour of load distribution   in scale-free networks. Phys Rev Lett 87(27):278701, 2001.  source  #  Erdos.static_scale_free     Method .  function static_scale_free(n, m, \u03b1, G=Graph;\n        seed=-1, finite_size_correction=true)  Generates a random graph with  n  vertices,  m  edges and expected power-law degree distribution with exponent  \u03b1 .  finite_size_correction  determines whether to use the finite size correction proposed by Cho et al. This generator calls internally the  static_fitness_model function . Time complexity is O(|V| + |E| log |E|).  function static_scale_free(n, m, \u03b1_out, \u03b1_in, G=DiGraph;\n        seed=-1, finite_size_correction=true)  Generates a random digraph  References:   Goh K-I, Kahng B, Kim D: Universal behaviour of load distribution in scale-free networks. Phys Rev Lett 87(27):278701, 2001.  Chung F and Lu L: Connected components in a random graph with given degree sequences. Annals of Combinatorics 6, 125-145, 2002.  Cho YS, Kim JS, Park J, Kahng B, Kim D: Percolation transitions in scale-free networks under the Achlioptas process. Phys Rev Lett 103:135702, 2009.   source  #  Erdos.stochastic_block_model     Method .  stochastic_block_model(c::Matrix{Float64}, n::Vector{Int}; seed::Int = -1)\nstochastic_block_model(cin::Float64, coff::Float64, n::Vector{Int}; seed::Int = -1)  Returns a Graph generated according to the Stochastic Block Model (SBM).  c[a,b]  : Mean number of neighbors of a vertex in block  a  belonging to block  b .            Only the upper triangular part is considered, since the lower traingular is            determined by $c[b,a] = c[a,b] * n[a]/n[b]$.  n[a]  : Number of vertices in block  a  The second form samples from a SBM with  c[a,a]=cin , and  c[a,b]=coff .  For a dynamic version of the SBM see the  StochasticBlockModel  type and related functions.  source  #  Erdos.watts_strogatz     Method .  watts_strogatz(n, k, \u03b2, G=Graph; seed=-1)  Creates a  Watts-Strogatz  small model random graph with  n  vertices, each with degree  k . Edges are randomized per the model based on probability  \u03b2 .  Undirected graphs are created by default. Directed graphs can be created passing a directed graph type as last argument (e.g.  DiGraph ).  source", 
            "title": "Random Graphs Generators"
        }, 
        {
            "location": "/centrality/", 
            "text": "Centrality Measures\n\n\nCentrality measures\n describe the importance of a vertex to the rest of the graph using some set of criteria. Centrality measures implemented in \nErdos.jl\n include the following:\n\n\n\n\nErdos.betweenness_centrality\n\n\nErdos.closeness_centrality\n\n\nErdos.cores\n\n\nErdos.degree_centrality\n\n\nErdos.in_degree_centrality\n\n\nErdos.katz_centrality\n\n\nErdos.kcore\n\n\nErdos.out_degree_centrality\n\n\nErdos.pagerank\n\n\n\n\n#\n\n\nErdos.betweenness_centrality\n \n \nMethod\n.\n\n\nbetweenness_centrality(g; normalize=true, endpoints=false, approx=-1)\n\n\n\n\nCalculates the \nbetweenness centrality\n of the vertices of graph \ng\n.\n\n\nBetweenness centrality for vertex \nv\n is defined as:\n\n\n$$\nbc(v) = \\frac{1}{\\mathcal{N}} \\sum_{s \\neq t \\neq v}\n        \\frac{\\sigma_{st}(v)}{\\sigma_{st}},\n$$\n\n\nwhere $\\sigma \n{st}} \\sigma\n$ is the total number of shortest paths from node \ns\n to node \nt\n and $\\sigma_{st}(v)$ is the number of those paths that pass through \nv\n.\n\n\nIf \nendpoints=true\n, endpoints are included in the shortest path count.\n\n\nIf \nnormalize=true\n, the betweenness values are normalized by the total number of possible distinct paths between all pairs in the graph. For an undirected graph, this number if \n((n-1)*(n-2))/2\n and for a directed graph, \n(n-1)*(n-2)\n where \nn\n is the number of vertices in the graph.\n\n\nIf  an integer argument \napprox \n 0\n is given, returns an approximation of the betweenness centrality of each vertex of the graph involving \napprox\n randomly chosen vertices.\n\n\nReferences\n\n\n[1] Brandes 2001 \n Brandes 2008\n\n\nsource\n\n\n#\n\n\nErdos.closeness_centrality\n \n \nMethod\n.\n\n\nCalculates the \ncloseness centrality\n of the graph \ng\n.\n\n\nsource\n\n\n#\n\n\nErdos.degree_centrality\n \n \nMethod\n.\n\n\nCalculates the \ndegree centrality\n of the graph \ng\n, with optional (default) normalization.\n\n\nsource\n\n\n#\n\n\nErdos.in_degree_centrality\n \n \nMethod\n.\n\n\nCalculates the \ndegree centrality\n of the graph \ng\n, with optional (default) normalization.\n\n\nsource\n\n\n#\n\n\nErdos.out_degree_centrality\n \n \nMethod\n.\n\n\nCalculates the \ndegree centrality\n of the graph \ng\n, with optional (default) normalization.\n\n\nsource\n\n\n#\n\n\nErdos.katz_centrality\n \n \nFunction\n.\n\n\nCalculates the \nKatz centrality\n of the graph \ng\n.\n\n\nsource\n\n\n#\n\n\nErdos.pagerank\n \n \nFunction\n.\n\n\npagerank(g::ADiGraph, \u03b1=0.85, n=100, \u03f5 = 1.0e-6)\n\n\n\n\nCalculates the \nPageRank\n of the graph \ng\n. Can optionally specify a different damping factor (\n\u03b1\n), number of iterations (\nn\n), and convergence threshold (\n\u03f5\n). If convergence is not reached within \nn\n iterations, an error will be returned.\n\n\nsource\n\n\n#\n\n\nErdos.cores\n \n \nMethod\n.\n\n\ncores(g)\n\n\n\n\nReturns a vector \ndeg\n such that if \ndeg[v]=k\n then the vertex \nv\n belongs to the \nk\n-core of \ng\n and not to the \nk+1\n-core.\n\n\nSee also \nkcore\n.\n\n\nsource\n\n\n#\n\n\nErdos.kcore\n \n \nMethod\n.\n\n\nkcore(g, k) -\n (gnew, vmap)\n\n\n\n\nReturns the \nk\n-core  of \ng\n along with a vertex map associating the mutated vertex indexes to the old ones (as in \nrem_vertices!\n).\n\n\nSee also \ncores\n\n\nsource", 
            "title": "Centrality Measures"
        }, 
        {
            "location": "/centrality/#centrality-measures", 
            "text": "Centrality measures  describe the importance of a vertex to the rest of the graph using some set of criteria. Centrality measures implemented in  Erdos.jl  include the following:   Erdos.betweenness_centrality  Erdos.closeness_centrality  Erdos.cores  Erdos.degree_centrality  Erdos.in_degree_centrality  Erdos.katz_centrality  Erdos.kcore  Erdos.out_degree_centrality  Erdos.pagerank   #  Erdos.betweenness_centrality     Method .  betweenness_centrality(g; normalize=true, endpoints=false, approx=-1)  Calculates the  betweenness centrality  of the vertices of graph  g .  Betweenness centrality for vertex  v  is defined as:  $$\nbc(v) = \\frac{1}{\\mathcal{N}} \\sum_{s \\neq t \\neq v}\n        \\frac{\\sigma_{st}(v)}{\\sigma_{st}},\n$$  where $\\sigma  {st}} \\sigma $ is the total number of shortest paths from node  s  to node  t  and $\\sigma_{st}(v)$ is the number of those paths that pass through  v .  If  endpoints=true , endpoints are included in the shortest path count.  If  normalize=true , the betweenness values are normalized by the total number of possible distinct paths between all pairs in the graph. For an undirected graph, this number if  ((n-1)*(n-2))/2  and for a directed graph,  (n-1)*(n-2)  where  n  is the number of vertices in the graph.  If  an integer argument  approx   0  is given, returns an approximation of the betweenness centrality of each vertex of the graph involving  approx  randomly chosen vertices.  References  [1] Brandes 2001   Brandes 2008  source  #  Erdos.closeness_centrality     Method .  Calculates the  closeness centrality  of the graph  g .  source  #  Erdos.degree_centrality     Method .  Calculates the  degree centrality  of the graph  g , with optional (default) normalization.  source  #  Erdos.in_degree_centrality     Method .  Calculates the  degree centrality  of the graph  g , with optional (default) normalization.  source  #  Erdos.out_degree_centrality     Method .  Calculates the  degree centrality  of the graph  g , with optional (default) normalization.  source  #  Erdos.katz_centrality     Function .  Calculates the  Katz centrality  of the graph  g .  source  #  Erdos.pagerank     Function .  pagerank(g::ADiGraph, \u03b1=0.85, n=100, \u03f5 = 1.0e-6)  Calculates the  PageRank  of the graph  g . Can optionally specify a different damping factor ( \u03b1 ), number of iterations ( n ), and convergence threshold ( \u03f5 ). If convergence is not reached within  n  iterations, an error will be returned.  source  #  Erdos.cores     Method .  cores(g)  Returns a vector  deg  such that if  deg[v]=k  then the vertex  v  belongs to the  k -core of  g  and not to the  k+1 -core.  See also  kcore .  source  #  Erdos.kcore     Method .  kcore(g, k) -  (gnew, vmap)  Returns the  k -core  of  g  along with a vertex map associating the mutated vertex indexes to the old ones (as in  rem_vertices! ).  See also  cores  source", 
            "title": "Centrality Measures"
        }, 
        {
            "location": "/community/", 
            "text": "Community Structures\n\n\nErdos.jl\n contains many algorithm to detect and analyze community structures in graphs.\n\n\n#\n\n\nErdos.global_clustering_coefficient\n \n \nMethod\n.\n\n\nglobal_clustering_coefficient(g)\n\n\n\n\nComputes the \nglobal clustering coefficient\n.\n\n\nsource\n\n\n#\n\n\nErdos.local_clustering\n \n \nFunction\n.\n\n\nlocal_clustering(g, vlist = vertices(g))\n\n\n\n\nReturns two vectors, respectively containing  the first and second result of \nlocal_clustering_coefficients(g, v)\n for each \nv\n in \nvlist\n.\n\n\nsource\n\n\n#\n\n\nErdos.local_clustering\n \n \nMethod\n.\n\n\nlocal_clustering(g, v)\n\n\n\n\nReturns a tuple \n(a,b)\n, where \na\n is the number of triangles in the neighborhood of \nv\n and \nb\n is the maximum number of possible triangles. It is related to the local clustering coefficient  by \nr=a/b\n.\n\n\nsource\n\n\n#\n\n\nErdos.local_clustering_coefficient\n \n \nFunction\n.\n\n\nlocal_clustering_coefficient(g, vlist = vertices(g))\n\n\n\n\nReturns a vector containing  the \nlocal clustering coefficients\n for vertices \nvlist\n.\n\n\nsource\n\n\n#\n\n\nErdos.local_clustering_coefficient\n \n \nMethod\n.\n\n\nlocal_clustering_coefficient(g, v)\n\n\n\n\nComputes the \nlocal clustering coefficient\n for node \nv\n.\n\n\nsource\n\n\n#\n\n\nErdos.triangles\n \n \nFunction\n.\n\n\ntriangles(g, vlist = vertices(g))\n\n\n\n\nReturns a vector containing the number of triangles for vertices \nvlist\n.\n\n\nsource\n\n\n#\n\n\nErdos.triangles\n \n \nMethod\n.\n\n\ntriangles(g, v)\n\n\n\n\nReturns the number of triangles in the neighborhood for node \nv\n.\n\n\nsource\n\n\n#\n\n\nErdos.core_periphery_deg\n \n \nMethod\n.\n\n\ncore_periphery_deg(g)\n\n\n\n\nA simple degree-based core-periphery detection algorithm (see \nLip\n). Returns the vertex assignments (1 for core and 2 for periphery).\n\n\nsource\n\n\n#\n\n\nErdos.modularity\n \n \nMethod\n.\n\n\nmodularity(g, c)\n\n\n\n\nComputes Newman's modularity \nQ\n for graph \ng\n given the partitioning \nc\n.\n\n\nsource\n\n\n#\n\n\nErdos.maximal_cliques\n \n \nMethod\n.\n\n\nFinds all maximal cliques of an undirected graph.\n\n\njulia\n using Erdos\njulia\n g = Graph(3)\njulia\n add_edge!(g, 1, 2)\njulia\n add_edge!(g, 2, 3)\njulia\n maximal_cliques(g)\n2-element Array{Array{Int64,N},1}:\n [2,3]\n [2,1]\n\n\n\n\nsource\n\n\n#\n\n\nErdos.community_detection_bethe\n \n \nFunction\n.\n\n\ncommunity_detection_bethe(g::AGraph, k=-1; kmax=15)\n\n\n\n\nCommunity detection using the spectral properties of the Bethe Hessian matrix associated to \ng\n (see \nSaade et al.\n). \nk\n is the number of communities to detect. If omitted or if \nk \n 1\n the optimal number of communities will be automatically selected. In this case the maximum number of detectable communities is given by \nkmax\n. Returns a vector containing the vertex assignments.\n\n\nsource\n\n\n#\n\n\nErdos.community_detection_nback\n \n \nMethod\n.\n\n\ncommunity_detection_nback(g, k)\n\n\n\n\nCommunity detection using the spectral properties of the non-backtracking matrix of graph \ng\n (see \nKrzakala et al.\n). \nk\n is the number of communities to detect.\n\n\nSee also \ncommunity_detection_bethe\n for a related community ddetection algorithm.\n\n\nReturns a vector with the vertex assignments in the communities.\n\n\nsource\n\n\n#\n\n\nErdos.label_propagation\n \n \nMethod\n.\n\n\nlabel_propagation(g; maxiter=1000)\n\n\n\n\nCommunity detection using the label propagation algorithm (see \nRaghavan et al.\n). \ng\n is the input Graph, \nmaxiter\n is the  maximum number of iterations. Returns a vertex assignments and the convergence history\n\n\nsource\n\n\n#\n\n\nErdos.nonbacktrack_embedding\n \n \nMethod\n.\n\n\nnonbacktrack_embedding(g::AGraph, k::Int)\n\n\n\n\nSpectral embedding of the non-backtracking matrix of \ng\n (see \nKrzakala et al.\n).\n\n\n`g`: imput Graph\n`k`: number of dimensions in which to embed\n\n\n\n\nReturns  a matrix \n\u03d5\n where \n\u03d5[:,i]\n are the coordinates for vertex \ni\n.\n\n\nNote:  does not explicitly construct the \nnonbacktracking_matrix\n. See \nNonbacktracking\n for details.\n\n\nsource", 
            "title": "Community Structures"
        }, 
        {
            "location": "/community/#community-structures", 
            "text": "Erdos.jl  contains many algorithm to detect and analyze community structures in graphs.  #  Erdos.global_clustering_coefficient     Method .  global_clustering_coefficient(g)  Computes the  global clustering coefficient .  source  #  Erdos.local_clustering     Function .  local_clustering(g, vlist = vertices(g))  Returns two vectors, respectively containing  the first and second result of  local_clustering_coefficients(g, v)  for each  v  in  vlist .  source  #  Erdos.local_clustering     Method .  local_clustering(g, v)  Returns a tuple  (a,b) , where  a  is the number of triangles in the neighborhood of  v  and  b  is the maximum number of possible triangles. It is related to the local clustering coefficient  by  r=a/b .  source  #  Erdos.local_clustering_coefficient     Function .  local_clustering_coefficient(g, vlist = vertices(g))  Returns a vector containing  the  local clustering coefficients  for vertices  vlist .  source  #  Erdos.local_clustering_coefficient     Method .  local_clustering_coefficient(g, v)  Computes the  local clustering coefficient  for node  v .  source  #  Erdos.triangles     Function .  triangles(g, vlist = vertices(g))  Returns a vector containing the number of triangles for vertices  vlist .  source  #  Erdos.triangles     Method .  triangles(g, v)  Returns the number of triangles in the neighborhood for node  v .  source  #  Erdos.core_periphery_deg     Method .  core_periphery_deg(g)  A simple degree-based core-periphery detection algorithm (see  Lip ). Returns the vertex assignments (1 for core and 2 for periphery).  source  #  Erdos.modularity     Method .  modularity(g, c)  Computes Newman's modularity  Q  for graph  g  given the partitioning  c .  source  #  Erdos.maximal_cliques     Method .  Finds all maximal cliques of an undirected graph.  julia  using Erdos\njulia  g = Graph(3)\njulia  add_edge!(g, 1, 2)\njulia  add_edge!(g, 2, 3)\njulia  maximal_cliques(g)\n2-element Array{Array{Int64,N},1}:\n [2,3]\n [2,1]  source  #  Erdos.community_detection_bethe     Function .  community_detection_bethe(g::AGraph, k=-1; kmax=15)  Community detection using the spectral properties of the Bethe Hessian matrix associated to  g  (see  Saade et al. ).  k  is the number of communities to detect. If omitted or if  k   1  the optimal number of communities will be automatically selected. In this case the maximum number of detectable communities is given by  kmax . Returns a vector containing the vertex assignments.  source  #  Erdos.community_detection_nback     Method .  community_detection_nback(g, k)  Community detection using the spectral properties of the non-backtracking matrix of graph  g  (see  Krzakala et al. ).  k  is the number of communities to detect.  See also  community_detection_bethe  for a related community ddetection algorithm.  Returns a vector with the vertex assignments in the communities.  source  #  Erdos.label_propagation     Method .  label_propagation(g; maxiter=1000)  Community detection using the label propagation algorithm (see  Raghavan et al. ).  g  is the input Graph,  maxiter  is the  maximum number of iterations. Returns a vertex assignments and the convergence history  source  #  Erdos.nonbacktrack_embedding     Method .  nonbacktrack_embedding(g::AGraph, k::Int)  Spectral embedding of the non-backtracking matrix of  g  (see  Krzakala et al. ).  `g`: imput Graph\n`k`: number of dimensions in which to embed  Returns  a matrix  \u03d5  where  \u03d5[:,i]  are the coordinates for vertex  i .  Note:  does not explicitly construct the  nonbacktracking_matrix . See  Nonbacktracking  for details.  source", 
            "title": "Community Structures"
        }, 
        {
            "location": "/flow/", 
            "text": "Flow and Cut\n\n\nErdos.jl\n provides different algorithms for \nmaximum flow\n and minimum cut computations.\n\n\n#\n\n\nErdos.BoykovKolmogorovAlgorithm\n \n \nType\n.\n\n\nForces the maximum_flow function to use the Boykov-Kolmogorov algorithm.\n\n\nsource\n\n\n#\n\n\nErdos.DinicAlgorithm\n \n \nType\n.\n\n\nForces the maximum_flow function to use Dinic's algorithm.\n\n\nsource\n\n\n#\n\n\nErdos.EdmondsKarpAlgorithm\n \n \nType\n.\n\n\nForces the maximum_flow function to use the Edmonds\u2013Karp algorithm.\n\n\nsource\n\n\n#\n\n\nErdos.PushRelabelAlgorithm\n \n \nType\n.\n\n\nForces the maximum_flow function to use the Push-Relabel algorithm.\n\n\nsource\n\n\n#\n\n\nErdos.maximum_flow\n \n \nMethod\n.\n\n\nmaximum_flow{T\n:Number}(\n                    g::ADiGraph,\n                    source::Int,\n                    target::Int,\n                    capacity_matrix::AbstractMatrix{T} =\n                        DefaultCapacity(g);\n                    algorithm::AbstractFlowAlgorithm  =\n                        PushRelabelAlgorithm(),\n                    restriction::T = zero(T)\n                )\n\n\n\n\nGeneric maximum_flow function. The function defaults to the Push-Relabel (also called Preflow) algorithm. Alternatively, the algorithm to be used can also be specified through a keyword argument. A default capacity of 1 is assumed for each link if no capacity matrix is provided. If the restriction is bigger than 0, it is applied to capacity_matrix.\n\n\nAll algorithms return a tuple with\n\n\n\n\nthe maximum flow\n\n\nthe flow matrix\n\n\nthe labelling associated to the minimum cut\n\n\n\n\nAvailable algorithms are \nDinicAlgorithm\n, \nEdmondsKarpAlgorithm\n, \nBoykovKolmogorovAlgorithm\n and \nPushRelabelAlgorithm\n.\n\n\nTime complexity is O(V\u00b2\u221aE) for the push relabel algorithm.\n\n\nUsage Example:\n\n\n\n# Create a flow-graph and a capacity matrix\ng = DiGraph(8)\nflow_edges = [\n    (1,2,10),(1,3,5),(1,4,15),(2,3,4),(2,5,9),\n    (2,6,15),(3,4,4),(3,6,8),(4,7,16),(5,6,15),\n    (5,8,10),(6,7,15),(6,8,10),(7,3,6),(7,8,10)\n]\ncapacity_matrix = zeros(Int, 8, 8)\nfor e in flow_edges\n    u, v, f = e\n    add_edge!(g, u, v)\n    capacity_matrix[u,v] = f\nend\n\n# Run default maximum_flow without the capacity_matrix (assumes capacity 1. on each edge).\nf, F, labels = maximum_flow(g, 1, 8)\n\n# Run Endmonds-Karp algorithm\nf, F, labels = maximum_flow(g,1,8,capacity_matrix,algorithm=EdmondsKarpAlgorithm())\n\n\n\n\nsource\n\n\n#\n\n\nErdos.minimum_cut\n \n \nMethod\n.\n\n\nminimum_cut(g, s, t, capacity_matrix=DefaultCapacity(); kws...)\n\n\n\n\nFinds the \ns-t cut\n of minimal weight according to the \ncapacities\n matrix on the directed graph \ng\n. The solution is found through a maximal flow algorithm. See \nmaximum_flow\n for the optional arguments.\n\n\nReturns a triple \n(f, cut, labels)\n, where \nf\n is the weight of the cut, \ncut\n is a vector of the edges in the cut, and \nlabels\n gives a partitioning of the vertices in two sets, according to the cut.\n\n\nsource\n\n\n#\n\n\nErdos.ExtendedMultirouteFlowAlgorithm\n \n \nType\n.\n\n\nForces the multiroute_flow function to use the Extended Multiroute Flow algorithm.\n\n\nsource\n\n\n#\n\n\nErdos.KishimotoAlgorithm\n \n \nType\n.\n\n\nForces the multiroute_flow function to use the Kishimoto algorithm.\n\n\nsource\n\n\n#\n\n\nErdos.multiroute_flow\n \n \nMethod\n.\n\n\nThe generic multiroute_flow function will output three kinds of results:\n\n\n\n\nWhen the number of routes is 0 or non-specified, the set of breaking points of\n\n\n\n\nthe multiroute flow is returned.\n\n\n\n\nWhen the input is limited to a set of breaking points and a route value k,\n\n\n\n\nonly the value of the k-route flow is returned\n\n\n\n\nOtherwise, a tuple with 1) the maximum flow and 2) the flow matrix. When the\n\n\n\n\nmax-flow subroutine is the Boykov-Kolmogorov algorithm, the associated mincut is returned as a third output.\n\n\nWhen the input is a network, it requires the following arguments:\n\n\n\n\nflow_graph::ADiGraph                   # the input graph\n\n\nsource::Int                           # the source vertex\n\n\ntarget::Int                           # the target vertex\n\n\ncapacity_matrix::AbstractMatrix{T}  # edge flow capacities with T\n:Real\n\n\nflow_algorithm::AbstractFlowAlgorithm # keyword argument for flow algorithm\n\n\nmrf_algorithm::AbstractFlowAlgorithm  # keyword argument for multiroute flow algorithm\n\n\nroutes::R\n:Real                       # keyword argument for the number of routes\n\n\n\n\nWhen the input is only the set of (breaking) points and the number of route, it requires the following arguments:\n\n\n\n\nbreakingpoints::Vector{Tuple{T, T, Int}},    # vector of breaking points\n\n\nroutes::R\n:Real,                             # number of routes\n\n\n\n\nWhen the input is the set of (breaking) points, the number of routes, and the network descriptors, it requires the following arguments:\n\n\n\n\nbreakingpoints::Vector{Tuple{T1, T1, Int}} # vector of breaking points (T1\n:Real)\n\n\nroutes::R\n:Real                            # number of routes\n\n\nflow_graph::ADiGraph                        # the input graph\n\n\nsource::Int                                # the source vertex\n\n\ntarget::Int                                # the target vertex\n\n\ncapacity_matrix::AbstractMatrix{T2}      # optional edge flow capacities (T2\n:Real)\n\n\nflow_algorithm::AbstractFlowAlgorithm      # keyword argument for algorithm\n\n\n\n\nThe function defaults to the Push-relabel (classical flow) and Kishimoto (multiroute) algorithms. Alternatively, the algorithms to be used can also be specified through  keyword arguments. A default capacity of 1 is assumed for each link if no capacity matrix is provided.\n\n\nThe mrf_algorithm keyword is inforced to Extended Multiroute Flow in the following cases:\n\n\n\n\nThe number of routes is non-integer\n\n\nThe number of routes is 0 or non-specified\n\n\n\n\nUsage Example :\n\n\n(please consult the  max_flow section for options about flow_algorithm and capacity_matrix)\n\n\n\n# Create a flow-graph and a capacity matrix\nflow_graph = DiGraph(8)\nflow_edges = [\n    (1, 2, 10), (1, 3, 5),  (1, 4, 15), (2, 3, 4),  (2, 5, 9),\n    (2, 6, 15), (3, 4, 4),  (3, 6, 8),  (4, 7, 16), (5, 6, 15),\n    (5, 8, 10), (6, 7, 15), (6, 8, 10), (7, 3, 6),  (7, 8, 10)\n]\ncapacity_matrix = zeros(Int, 8, 8)\nfor e in flow_edges\n    u, v, f = e\n    add_edge!(flow_graph, u, v)\n    capacity_matrix[u, v] = f\nend\n\n# Run default multiroute_flow with an integer number of routes = 2\nf, F = multiroute_flow(flow_graph, 1, 8, capacity_matrix, routes = 2)\n\n# Run default multiroute_flow with a noninteger number of routes = 1.5\nf, F = multiroute_flow(flow_graph, 1, 8, capacity_matrix, routes = 1.5)\n\n# Run default multiroute_flow for all the breaking points values\npoints = multiroute_flow(flow_graph, 1, 8, capacity_matrix)\n# Then run multiroute flow algorithm for any positive number of routes\nf, F = multiroute_flow(points, 1.5)\nf = multiroute_flow(points, 1.5, valueonly = true)\n\n# Run multiroute flow algorithm using Boykov-Kolmogorov algorithm as max_flow routine\nf, F, labels = multiroute_flow(flow_graph, 1, 8, capacity_matrix,\n               algorithm = BoykovKolmogorovAlgorithm(), routes = 2)\n\n\n\n\n\nsource", 
            "title": "Flow and Cut"
        }, 
        {
            "location": "/flow/#flow-and-cut", 
            "text": "Erdos.jl  provides different algorithms for  maximum flow  and minimum cut computations.  #  Erdos.BoykovKolmogorovAlgorithm     Type .  Forces the maximum_flow function to use the Boykov-Kolmogorov algorithm.  source  #  Erdos.DinicAlgorithm     Type .  Forces the maximum_flow function to use Dinic's algorithm.  source  #  Erdos.EdmondsKarpAlgorithm     Type .  Forces the maximum_flow function to use the Edmonds\u2013Karp algorithm.  source  #  Erdos.PushRelabelAlgorithm     Type .  Forces the maximum_flow function to use the Push-Relabel algorithm.  source  #  Erdos.maximum_flow     Method .  maximum_flow{T :Number}(\n                    g::ADiGraph,\n                    source::Int,\n                    target::Int,\n                    capacity_matrix::AbstractMatrix{T} =\n                        DefaultCapacity(g);\n                    algorithm::AbstractFlowAlgorithm  =\n                        PushRelabelAlgorithm(),\n                    restriction::T = zero(T)\n                )  Generic maximum_flow function. The function defaults to the Push-Relabel (also called Preflow) algorithm. Alternatively, the algorithm to be used can also be specified through a keyword argument. A default capacity of 1 is assumed for each link if no capacity matrix is provided. If the restriction is bigger than 0, it is applied to capacity_matrix.  All algorithms return a tuple with   the maximum flow  the flow matrix  the labelling associated to the minimum cut   Available algorithms are  DinicAlgorithm ,  EdmondsKarpAlgorithm ,  BoykovKolmogorovAlgorithm  and  PushRelabelAlgorithm .  Time complexity is O(V\u00b2\u221aE) for the push relabel algorithm.  Usage Example:  \n# Create a flow-graph and a capacity matrix\ng = DiGraph(8)\nflow_edges = [\n    (1,2,10),(1,3,5),(1,4,15),(2,3,4),(2,5,9),\n    (2,6,15),(3,4,4),(3,6,8),(4,7,16),(5,6,15),\n    (5,8,10),(6,7,15),(6,8,10),(7,3,6),(7,8,10)\n]\ncapacity_matrix = zeros(Int, 8, 8)\nfor e in flow_edges\n    u, v, f = e\n    add_edge!(g, u, v)\n    capacity_matrix[u,v] = f\nend\n\n# Run default maximum_flow without the capacity_matrix (assumes capacity 1. on each edge).\nf, F, labels = maximum_flow(g, 1, 8)\n\n# Run Endmonds-Karp algorithm\nf, F, labels = maximum_flow(g,1,8,capacity_matrix,algorithm=EdmondsKarpAlgorithm())  source  #  Erdos.minimum_cut     Method .  minimum_cut(g, s, t, capacity_matrix=DefaultCapacity(); kws...)  Finds the  s-t cut  of minimal weight according to the  capacities  matrix on the directed graph  g . The solution is found through a maximal flow algorithm. See  maximum_flow  for the optional arguments.  Returns a triple  (f, cut, labels) , where  f  is the weight of the cut,  cut  is a vector of the edges in the cut, and  labels  gives a partitioning of the vertices in two sets, according to the cut.  source  #  Erdos.ExtendedMultirouteFlowAlgorithm     Type .  Forces the multiroute_flow function to use the Extended Multiroute Flow algorithm.  source  #  Erdos.KishimotoAlgorithm     Type .  Forces the multiroute_flow function to use the Kishimoto algorithm.  source  #  Erdos.multiroute_flow     Method .  The generic multiroute_flow function will output three kinds of results:   When the number of routes is 0 or non-specified, the set of breaking points of   the multiroute flow is returned.   When the input is limited to a set of breaking points and a route value k,   only the value of the k-route flow is returned   Otherwise, a tuple with 1) the maximum flow and 2) the flow matrix. When the   max-flow subroutine is the Boykov-Kolmogorov algorithm, the associated mincut is returned as a third output.  When the input is a network, it requires the following arguments:   flow_graph::ADiGraph                   # the input graph  source::Int                           # the source vertex  target::Int                           # the target vertex  capacity_matrix::AbstractMatrix{T}  # edge flow capacities with T :Real  flow_algorithm::AbstractFlowAlgorithm # keyword argument for flow algorithm  mrf_algorithm::AbstractFlowAlgorithm  # keyword argument for multiroute flow algorithm  routes::R :Real                       # keyword argument for the number of routes   When the input is only the set of (breaking) points and the number of route, it requires the following arguments:   breakingpoints::Vector{Tuple{T, T, Int}},    # vector of breaking points  routes::R :Real,                             # number of routes   When the input is the set of (breaking) points, the number of routes, and the network descriptors, it requires the following arguments:   breakingpoints::Vector{Tuple{T1, T1, Int}} # vector of breaking points (T1 :Real)  routes::R :Real                            # number of routes  flow_graph::ADiGraph                        # the input graph  source::Int                                # the source vertex  target::Int                                # the target vertex  capacity_matrix::AbstractMatrix{T2}      # optional edge flow capacities (T2 :Real)  flow_algorithm::AbstractFlowAlgorithm      # keyword argument for algorithm   The function defaults to the Push-relabel (classical flow) and Kishimoto (multiroute) algorithms. Alternatively, the algorithms to be used can also be specified through  keyword arguments. A default capacity of 1 is assumed for each link if no capacity matrix is provided.  The mrf_algorithm keyword is inforced to Extended Multiroute Flow in the following cases:   The number of routes is non-integer  The number of routes is 0 or non-specified   Usage Example :  (please consult the  max_flow section for options about flow_algorithm and capacity_matrix)  \n# Create a flow-graph and a capacity matrix\nflow_graph = DiGraph(8)\nflow_edges = [\n    (1, 2, 10), (1, 3, 5),  (1, 4, 15), (2, 3, 4),  (2, 5, 9),\n    (2, 6, 15), (3, 4, 4),  (3, 6, 8),  (4, 7, 16), (5, 6, 15),\n    (5, 8, 10), (6, 7, 15), (6, 8, 10), (7, 3, 6),  (7, 8, 10)\n]\ncapacity_matrix = zeros(Int, 8, 8)\nfor e in flow_edges\n    u, v, f = e\n    add_edge!(flow_graph, u, v)\n    capacity_matrix[u, v] = f\nend\n\n# Run default multiroute_flow with an integer number of routes = 2\nf, F = multiroute_flow(flow_graph, 1, 8, capacity_matrix, routes = 2)\n\n# Run default multiroute_flow with a noninteger number of routes = 1.5\nf, F = multiroute_flow(flow_graph, 1, 8, capacity_matrix, routes = 1.5)\n\n# Run default multiroute_flow for all the breaking points values\npoints = multiroute_flow(flow_graph, 1, 8, capacity_matrix)\n# Then run multiroute flow algorithm for any positive number of routes\nf, F = multiroute_flow(points, 1.5)\nf = multiroute_flow(points, 1.5, valueonly = true)\n\n# Run multiroute flow algorithm using Boykov-Kolmogorov algorithm as max_flow routine\nf, F, labels = multiroute_flow(flow_graph, 1, 8, capacity_matrix,\n               algorithm = BoykovKolmogorovAlgorithm(), routes = 2)  source", 
            "title": "Flow and Cut"
        }, 
        {
            "location": "/matching/", 
            "text": "Matching\n\n\nAlgorithms for the \noptimal matching problems\n.  \nErdosExtras\n.  Functionalities moved to  \nErdosExtras.jl\n.", 
            "title": "Matching"
        }, 
        {
            "location": "/matching/#matching", 
            "text": "Algorithms for the  optimal matching problems .   ErdosExtras .  Functionalities moved to   ErdosExtras.jl .", 
            "title": "Matching"
        }, 
        {
            "location": "/dismantling/", 
            "text": "Dismantling\n\n\nAlgorithms for network dismantling and influencer search.\n\n\n#\n\n\nErdos.dismantle_ci\n \n \nMethod\n.\n\n\ndismantle_ci(g::AGraph, l::Integer, nrem; verbose=false)\n\n\n\n\nApplies the Collective Influence (CI) heuristic of Ref. [1]  with distance parameter \nl\n (tipically \nl=3,4\n). Removes a maximum of \nnrem\n vertices from \ng\n, trying to minimize the size of the maximum connected component of the resulting graph. It stops earlier if the maximum CI goes to zero.\n\n\nSet \nverbose\n to \ntrue\n for info printing in each iteration.\n\n\nReturns \n(gnew, vmap, remlist)\n, where \ngnew\n is the reduced graph, \nvmap\n is a vertex map of the vertices of \ngnew\n to the old ones (see also \nrem_vertices!\n) and \nremlist\n contains the removed vertices by removal order.\n\n\nFor more fine grained control see \ndismantle_ci_init\n and \ndismantle_ci_oneiter!\n.\n\n\nUsage\n\n\ng = Graph(100, 1000)\nl=3\nnrem=10\ngnew, vmap, remlist = dismantle_ci(g, l, nrem)\n\n# or equivalently\ngnew, heap, lneigs = dismantle_ci_init(g, l)\n\nfor it=1:nrem\n    irem = dismantle_ci_oneiter!(gnew, heap, lneigs, l)\n    irem \n= 0 \n break\n    push!(remlist, irem)\n    println(\nSize Max Component: \n, maximum(length, connected_components(g)))\nend\nvmap = rem_vertices!(gnew, remlist)\n\n\n\n\n[1] Morone F., Makse H. Influence maximization in complex networks through optimal percolation. Nature (2015)\n\n\nsource\n\n\n#\n\n\nErdos.dismantle_ci_init\n \n \nMethod\n.\n\n\ndismantle_ci_init(g, l)\n\n\n\n\nInitialization part of \ndismantle_ci\n algorithm. Returns \n(gnew, heap, lneigs)\n.\n\n\nsource\n\n\n#\n\n\nErdos.dismantle_ci_oneiter!\n \n \nMethod\n.\n\n\ndismantle_ci_oneiter!(g, heap, lneigs, l)\n\n\n\n\nOne step of \ndismantle_ci\n algorithm. To be called after \ndismantle_ci_init\n Returns the cleaned vertex if any (see \nclean_vertex!\n), -1 otherwise.\n\n\nsource", 
            "title": "Dismantling"
        }, 
        {
            "location": "/dismantling/#dismantling", 
            "text": "Algorithms for network dismantling and influencer search.  #  Erdos.dismantle_ci     Method .  dismantle_ci(g::AGraph, l::Integer, nrem; verbose=false)  Applies the Collective Influence (CI) heuristic of Ref. [1]  with distance parameter  l  (tipically  l=3,4 ). Removes a maximum of  nrem  vertices from  g , trying to minimize the size of the maximum connected component of the resulting graph. It stops earlier if the maximum CI goes to zero.  Set  verbose  to  true  for info printing in each iteration.  Returns  (gnew, vmap, remlist) , where  gnew  is the reduced graph,  vmap  is a vertex map of the vertices of  gnew  to the old ones (see also  rem_vertices! ) and  remlist  contains the removed vertices by removal order.  For more fine grained control see  dismantle_ci_init  and  dismantle_ci_oneiter! .  Usage  g = Graph(100, 1000)\nl=3\nnrem=10\ngnew, vmap, remlist = dismantle_ci(g, l, nrem)\n\n# or equivalently\ngnew, heap, lneigs = dismantle_ci_init(g, l)\n\nfor it=1:nrem\n    irem = dismantle_ci_oneiter!(gnew, heap, lneigs, l)\n    irem  = 0   break\n    push!(remlist, irem)\n    println( Size Max Component:  , maximum(length, connected_components(g)))\nend\nvmap = rem_vertices!(gnew, remlist)  [1] Morone F., Makse H. Influence maximization in complex networks through optimal percolation. Nature (2015)  source  #  Erdos.dismantle_ci_init     Method .  dismantle_ci_init(g, l)  Initialization part of  dismantle_ci  algorithm. Returns  (gnew, heap, lneigs) .  source  #  Erdos.dismantle_ci_oneiter!     Method .  dismantle_ci_oneiter!(g, heap, lneigs, l)  One step of  dismantle_ci  algorithm. To be called after  dismantle_ci_init  Returns the cleaned vertex if any (see  clean_vertex! ), -1 otherwise.  source", 
            "title": "Dismantling"
        }, 
        {
            "location": "/spanningtrees/", 
            "text": "Spanning Trees\n\n\n#\n\n\nErdos.count_spanning_trees\n \n \nMethod\n.\n\n\ncount_spanning_trees(g::AGraph)\n\n\n\n\nReturns the number of spanning trees of \ng\n, computed through \nKirchhoff's theorem\n. The return type is a float, since the number can be very large.\n\n\nsource\n\n\n#\n\n\nErdos.minimum_spanning_tree\n \n \nMethod\n.\n\n\nminimum_spanning_tree{T\n:Real}(\n    g, distmx::AbstractMatrix{T} = ConstEdgeMap(g,1)\n)\n\n\n\n\nPerforms \nKruskal's algorithm\n on a connected, undirected graph \ng\n, having adjacency matrix \ndistmx\n, and computes minimum spanning tree. Returns a \nVector{KruskalHeapEntry}\n, that contains the containing edges and its weights.\n\n\nsource", 
            "title": "Spanning Trees"
        }, 
        {
            "location": "/spanningtrees/#spanning-trees", 
            "text": "#  Erdos.count_spanning_trees     Method .  count_spanning_trees(g::AGraph)  Returns the number of spanning trees of  g , computed through  Kirchhoff's theorem . The return type is a float, since the number can be very large.  source  #  Erdos.minimum_spanning_tree     Method .  minimum_spanning_tree{T :Real}(\n    g, distmx::AbstractMatrix{T} = ConstEdgeMap(g,1)\n)  Performs  Kruskal's algorithm  on a connected, undirected graph  g , having adjacency matrix  distmx , and computes minimum spanning tree. Returns a  Vector{KruskalHeapEntry} , that contains the containing edges and its weights.  source", 
            "title": "Spanning Trees"
        }
    ]
}