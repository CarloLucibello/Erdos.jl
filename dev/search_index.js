var documenterSearchIndex = {"docs":
[{"location":"persistence/#Reading-and-writing-Graphs","page":"Reading / Writing Graphs","title":"Reading and writing Graphs","text":"","category":"section"},{"location":"persistence/","page":"Reading / Writing Graphs","title":"Reading / Writing Graphs","text":"Graphs may be written to I/O streams and files using the writegraph function and read with the readgraph function. Currently supported common graph formats are GraphML, GML, Gexf, DOT, Pajek .net, graph-tool gt. If fast I/O and small memory footprint is a priority, use the .gt binary format.","category":"page"},{"location":"persistence/","page":"Reading / Writing Graphs","title":"Reading / Writing Graphs","text":"For network types, when using appropriate formats (e.g. .gml, .graphml, .gexf) properties of graph, vertices, and edges  will be read/written as well.","category":"page"},{"location":"persistence/#Examples","page":"Reading / Writing Graphs","title":"Examples","text":"","category":"section"},{"location":"persistence/","page":"Reading / Writing Graphs","title":"Reading / Writing Graphs","text":"julia> g = Graph(10, 20)\nGraph{Int64}(10, 20)\n\njulia> writegraph(\"mygraph.gml\", g) #format is inferred from the extension\n1\n\njulia> h = readgraph(\"mygraph.gml\")\nGraph{Int64}(10, 20)\n\njulia> g == h\ntrue\n\njulia> g = Network(10, 20)\nNetwork(10, 20) with [] graph, [] vertex, [] edge properties\n\njulia> gprop!(g, \"A\", rand());\n\njulia> eprop!(g, \"B\", EdgeMap(g, e -> rand()));\n\njulia> vprop!(g, \"C\", VertexMap(g, v -> rand()));\n\njulia> writenetwork(\"mygraph.gml\", g) #format is inferred from the extension\n1\n\njulia> h = readnetwork(\"mygraph.gml\")\nNetwork(10, 20) with [\"A\"] graph, [\"C\"] vertex, [\"B\"] edge properties\n\njulia> g == h\ntrue","category":"page"},{"location":"persistence/#Methods","page":"Reading / Writing Graphs","title":"Methods","text":"","category":"section"},{"location":"persistence/","page":"Reading / Writing Graphs","title":"Reading / Writing Graphs","text":"Modules = [Erdos]\nPages   = [ \"persistence/common.jl\"]\nPrivate = false","category":"page"},{"location":"persistence/#Erdos.readgraph-Union{Tuple{G}, Tuple{String, Symbol}, Tuple{String, Symbol, Type{G}}} where G<:AGraphOrDiGraph","page":"Reading / Writing Graphs","title":"Erdos.readgraph","text":"readgraph(filename, G=Graph)\nreadgraph(filename, t, G=Graph; compressed=false)\n\nReads a graph from  filename in the format t. Returns a graph of type G or the corresponding digraph/graph type. Compressed files can eventually be read.\n\nSupported formats are :gml, :dot, :graphml, :gexf, :net, :gt.\n\nIf no format is provided, it will be inferred from filename.\n\nreadgraph(s::Symbol, G=Graph)\n\nRead a graph identified by s from Erdos datasets collection (e.g. s=:karate). They are stored in the gt binary format in the datasets directory of the package. For a list of available graph refer to the documentation.\n\n\n\n\n\n","category":"method"},{"location":"persistence/#Erdos.readnetwork-Union{Tuple{G}, Tuple{String, Symbol}, Tuple{String, Symbol, Type{G}}} where G<:ANetOrDiNet","page":"Reading / Writing Graphs","title":"Erdos.readnetwork","text":"readnetwork(filename, G=Network)\nreadnetwork(filename, t, G=Network; compressed=false)\n\nRead a network from  filename in the format t.  Returns a network of type G (or the corresponding directed/undirected type if needed). Compressed files can eventually be read.\n\nSupported formats are :gml, :dot, :graphml, :gexf, :net, :gt. When possible, graph, edge, and vertex properties will be read as well.\n\nIf no format is provided, it will be inferred from the filename.\n\nreadnetwork(s::Symbol, G=Network)\n\nRead a network identified by s from Erdos' datasets collection (e.g. s=:karate). They are stored in the gt binary format in the datasets directory of the package. For a list of available graph refer to the documentation.\n\n\n\n\n\n","category":"method"},{"location":"persistence/#Erdos.writegraph-Tuple{IO, AGraphOrDiGraph, Symbol}","page":"Reading / Writing Graphs","title":"Erdos.writegraph","text":"writegraph(file, g)\nwritegraph(file, g, t; compress=false)\n\nSave a graph g to file in the format t.\n\nEventually the resulting file can be compressed in the gzip format.\n\nCurrently supported formats are :gml, :graphml, :gexf, :dot, :net, :gt.\n\nIf no format is provided, it will be inferred from file along with compression.\n\n\n\n\n\n","category":"method"},{"location":"persistence/#Erdos.writenetwork-Tuple{IO, ANetOrDiNet, Symbol}","page":"Reading / Writing Graphs","title":"Erdos.writenetwork","text":"writenetwork(file, g)\nwritenetwork(file, g, t; compress=false)\n\nSave a network g to file in the format t.\n\nEventually the resulting file can be compressed in the gzip format.\n\nCurrently supported formats are :gml, :graphml, :gexf, :dot, :net, :gt. When possible, graph, edge, and vertex properties will be written as well.\n\nIf no format is provided, it will be inferred from file along with compression.\n\n\n\n\n\n","category":"method"},{"location":"linalg/#Linear-Algebra","page":"Linear Algebra","title":"Linear Algebra","text":"","category":"section"},{"location":"linalg/","page":"Linear Algebra","title":"Linear Algebra","text":"Erdos.jl provides the following matrix operations on both directed and undirected graphs:","category":"page"},{"location":"linalg/","page":"Linear Algebra","title":"Linear Algebra","text":"Modules = [Erdos]\nPages   = [ \"linalg/spectral.jl\",\n            \"linalg/nonbacktracking.jl\"]\nPrivate = false","category":"page"},{"location":"linalg/#Erdos.adjacency_matrix","page":"Linear Algebra","title":"Erdos.adjacency_matrix","text":"adjacency_matrix(g, dir=:out, T::DataType=Int)\n\nReturns a sparse boolean adjacency matrix for a graph, indexed by [u, v] vertices. true values indicate an edge between u and v. Users may specify a direction (:in, :out, or :all are currently supported; :out is default for both directed and undirected graphs) and a data type for the matrix (defaults to Int).\n\n\n\n\n\n","category":"function"},{"location":"linalg/#Erdos.incidence_matrix","page":"Linear Algebra","title":"Erdos.incidence_matrix","text":"incidence_matrix(g::AGraphOrDiGraph, T::DataType=Int; oriented=false)\n\nReturns a sparse node-arc incidence matrix for a graph, indexed by [v, i], where i is in 1:ne(g), indexing an edge e. For directed graphs, a value of -1 indicates that src(e) == v, while a value of 1 indicates that dst(e) == v. Otherwise, the value is 0.\n\nFor undirected graphs, both entries are 1 if oriented=false, otherwise [v, i] -> -1 and [u, i] -> 1 if v < u.\n\n\n\n\n\n","category":"function"},{"location":"linalg/#Erdos.laplacian_matrix","page":"Linear Algebra","title":"Erdos.laplacian_matrix","text":"laplacian_matrix(g, dir::Symbol=:out, T::DataType=Int)\n\nReturns a sparse Laplacian matrix for a graph g, indexed by [u, v] vertices. dir has to be :in, :out or :all.\n\n\n\n\n\n","category":"function"},{"location":"linalg/#Erdos.spectral_distance-Tuple{AGraph, AGraph, Integer}","page":"Linear Algebra","title":"Erdos.spectral_distance","text":"spectral_distance(G₁, G₂ [, k])\n\nCompute the spectral distance between undirected n-vertex graphs G₁ and G₂ using the top k ≤ n greatest eigenvalues. If k is ommitted, uses full spectrum.\n\nFor further details, please refer to:\n\nJOVANOVIC, I.; STANIC, Z., 2014. Spectral Distances of Graphs Based on their Different Matrix Representations\n\n\n\n\n\n","category":"method"},{"location":"linalg/#Erdos.nonbacktracking_matrix-Tuple{AGraph}","page":"Linear Algebra","title":"Erdos.nonbacktracking_matrix","text":"nonbacktracking_matrix(g)\n\nReturn a non-backtracking matrix B and an edgemap storing the oriented edges' positions in B. Given two arcs A_i j and A_k l in g the non-backtraking matrixBis defined asB{A{i j}, A{k l}} = δ{j k} * (1 - δ_{i l})``\n\n\n\n\n\n","category":"method"},{"location":"distance/#Distance","page":"Distance","title":"Distance","text":"","category":"section"},{"location":"distance/","page":"Distance","title":"Distance","text":"Erdos.jl includes the following distance measurements:","category":"page"},{"location":"distance/","page":"Distance","title":"Distance","text":"Modules = [Erdos]\nPages   = [ \"distances/distance.jl\",\n            \"distances/edit_distance.jl\"]\nPrivate = false","category":"page"},{"location":"distance/#Erdos.center-Tuple{Vector{T} where T}","page":"Distance","title":"Erdos.center","text":"center(g, distmx=weights(g))\ncenter(all_ecc)\n\nReturns the set of all vertices whose eccentricity is equal to the graph's radius (that is, the set of vertices with the smallest eccentricity).\n\nEventually a vector all_ecc contain the eccentricity of each node can be passed as argument.\n\nSee eccentricities.\n\n\n\n\n\n","category":"method"},{"location":"distance/#Erdos.diameter","page":"Distance","title":"Erdos.diameter","text":"diameter(g, distmx=weights(g))\n\nReturns the maximum distance between any two vertices in g. Distances  between two adjacent nodes are given by distmx.\n\nSee also eccentricities, radius.\n\n\n\n\n\n","category":"function"},{"location":"distance/#Erdos.eccentricities","page":"Distance","title":"Erdos.eccentricities","text":"eccentricities(g, distmx=weights(g))\neccentricities(g, vs, distmx=weights(g))\n\nReturns [eccentricity(g,v,distmx) for v in vs]. When vs it is not supplied, considers all node in the graph.\n\nSee also eccentricity.\n\nNote: the eccentricity vector returned by eccentricity may be eventually used as input in some eccentricity related measures (periphery, center).\n\n\n\n\n\n","category":"function"},{"location":"distance/#Erdos.eccentricity","page":"Distance","title":"Erdos.eccentricity","text":"eccentricity(g, v, distmx=weights(g))\n\nCalculates the eccentricity[ies] of a vertex v, An optional matrix of edge distances may be supplied.\n\nThe eccentricity of a vertex is the maximum shortest-path distance between it and all other vertices in the graph.\n\n\n\n\n\n","category":"function"},{"location":"distance/#Erdos.periphery-Tuple{Vector{T} where T}","page":"Distance","title":"Erdos.periphery","text":"periphery(g, distmx=weights(g))\nperiphery(all_ecc)\n\nReturns the set of all vertices whose eccentricity is equal to the graph's diameter (that is, the set of vertices with the largest eccentricity).\n\nEventually a vector all_ecc contain the eccentricity of each node can be passed as argument.\n\nSee eccentricities.\n\n\n\n\n\n","category":"method"},{"location":"distance/#Erdos.radius","page":"Distance","title":"Erdos.radius","text":"radius(g, distmx=weights(g))\n\nReturns the minimum distance between any two vertices in g. Distances  between two adjacent nodes are given by distmx.\n\nSee eccentricities, diameter.\n\n\n\n\n\n","category":"function"},{"location":"distance/#Erdos.BoundedMinkowskiCost-Tuple{AbstractVector{T} where T, AbstractVector{T} where T}","page":"Distance","title":"Erdos.BoundedMinkowskiCost","text":"Similar to MinkowskiCost, but ensures costs smaller than 2τ.\n\n\n\n\n\n","category":"method"},{"location":"distance/#Erdos.MinkowskiCost-Tuple{AbstractVector{T} where T, AbstractVector{T} where T}","page":"Distance","title":"Erdos.MinkowskiCost","text":"For labels μ₁ on the vertices of graph G₁ and labels μ₂ on the vertices of graph G₂, compute the p-norm cost of substituting vertex u ∈ G₁ by vertex v ∈ G₂.\n\n\n\n\n\n","category":"method"},{"location":"distance/#Erdos.edit_distance-Tuple{AGraphOrDiGraph, AGraphOrDiGraph}","page":"Distance","title":"Erdos.edit_distance","text":"edit_distance(G₁, G₂;\n       insert_cost::Function=v->1.0,\n       delete_cost::Function=u->1.0,\n       subst_cost::Function=(u,v)->0.5,\n       heuristic::Function=DefaultEditHeuristic)\n\nComputes the edit distance between graphs G₁ and G₂.\n\nReturns the minimum edit cost and edit path to transform graph G₁ into graph G₂. An edit path consists of a sequence of pairs of vertices (u,v) ∈ [0,|G₁|] × [0,|G₂|] representing vertex operations:\n\n(0,v): insertion of vertex v ∈ G₂\n(u,0): deletion of vertex u ∈ G₁\n(u>0,v>0): substitution of vertex u ∈ G₁ by vertex v ∈ G₂\n\nBy default, the algorithm uses constant operation costs. The user can provide classical Minkowski costs computed from vertex labels μ₁ (for G₁) and μ₂ (for G₂) in order to further guide the search, for example:\n\nedit_distance(G₁, G₂, subst_cost=MinkowskiCost(μ₁, μ₂))\n\nA custom heuristic can be provided to the A* search in case the default heuristic is not satisfactory. Performance tips: ––––––––-\n\nGiven two graphs G₁  G₂, edit_distance(G₁, G₂) is faster to\n\ncompute than edit_distance(G₂, G₁). Consider swapping the arguments if involved costs are symmetric.\n\nThe use of simple Minkowski costs can improve performance considerably.\nExploit vertex attributes when designing operation costs.\n\nFor further details, please refer to:\n\nRIESEN, K., 2015. Structural Pattern Recognition with Graph Edit Distance: Approximation Algorithms and Applications. (Chapter 2)\n\nAuthor: Júlio Hoffimann Mendes (juliohm@stanford.edu)\n\n\n\n\n\n","category":"method"},{"location":"spanningtrees/#Spanning-Trees","page":"Spanning Trees","title":"Spanning Trees","text":"","category":"section"},{"location":"spanningtrees/","page":"Spanning Trees","title":"Spanning Trees","text":"Modules = [Erdos]\nPages   = [ \"spanningtrees/spanningtrees.jl\",\n            \"spanningtrees/kruskal.jl\"]\nPrivate = false","category":"page"},{"location":"spanningtrees/#Erdos.count_spanning_trees-Tuple{AGraph}","page":"Spanning Trees","title":"Erdos.count_spanning_trees","text":"count_spanning_trees(g::AGraph)\n\nReturns the number of spanning trees of g, computed through Kirchhoff's theorem. The return type is a float, since the number can be very large.\n\n\n\n\n\n","category":"method"},{"location":"spanningtrees/#Erdos.minimum_spanning_tree-Union{Tuple{AGraph}, Tuple{T}, Tuple{AGraph, AbstractMatrix{T}}} where T<:Real","page":"Spanning Trees","title":"Erdos.minimum_spanning_tree","text":"minimum_spanning_tree{T<:Real}(\n    g, distmx::AbstractMatrix{T} = weights(g)\n)\n\nPerforms Kruskal's algorithm on a connected, undirected graph g, having adjacency matrix distmx, and computes minimum spanning tree. Returns a Vector{KruskalHeapEntry}, that contains the containing edges and its weights.\n\n\n\n\n\n","category":"method"},{"location":"network_interface/#network_interface","page":"Property Interface for Networks","title":"Network Types and Interface","text":"","category":"section"},{"location":"network_interface/","page":"Property Interface for Networks","title":"Property Interface for Networks","text":"Networks in Erdos are graphs with the additional capability of storing properties associated to vertices, edges, and to the graph itself. Edge and vertex properties are nothing else than edge and vertex maps with a name associated to them. Erdos defines some interface methods and their convenient short form equivalents to work with networks and properties.","category":"page"},{"location":"network_interface/","page":"Property Interface for Networks","title":"Property Interface for Networks","text":"julia> using Erdos\n\njulia> g = Network(10, 20) # create erdos-renyi random network\n\njulia> add_edge!(g, 1, 2); # add edge (1, 2) if it doesn't exists\n\njulia> eprop!(g, \"w\", e -> rand()) # add edge property named \"w\"\nNetwork(10, 20) with [] graph, [] vertex, [\"w\"] edge properties\n\njulia> vprop!(g, \"x\", v -> [1,1]) # add vertex property named \"x\"\nNetwork(10, 20) with [] graph, [\"x\"] vertex, [\"w\"] edge properties\n\njulia> eprop(g, 1, 2, \"w\")\n0.8959648919973169\n\njulia> writenetwork(\"mygraph.graphml\")  # save graph and properties in .graphml format","category":"page"},{"location":"network_interface/#Property-Interface","page":"Property Interface for Networks","title":"Property Interface","text":"","category":"section"},{"location":"network_interface/","page":"Property Interface for Networks","title":"Property Interface for Networks","text":"Modules = [Erdos]\nPages   = [\"core/interface_network.jl\"]\nOrder   = [:function]\nPrivate = false","category":"page"},{"location":"network_interface/#Erdos.add_edge_property!-Tuple{ANetOrDiNet, AbstractString, AEdgeMap}","page":"Property Interface for Networks","title":"Erdos.add_edge_property!","text":"add_edge_property!(g, name, T)\nadd_edge_property!(g, name, emap)\n\nAdd the edge property  name to g.\n\nIf a type T is given as an input, an edge map with valtype T is created and stored into g.\n\nAs an alternative, an existing edge map emap can be stored into g.\n\neprop! is the short form of this function.\n\nExample\n\ng = random_regular_graph(10, 3, Network)\n\nadd_edge_property!(g, \"weight\", Float64)\n# or equivalently\neprop!(g, \"weight\", Float64)\n\n\n\n\n\n","category":"method"},{"location":"network_interface/#Erdos.add_vertex_property!-Tuple{ANetOrDiNet, AbstractString, AVertexMap}","page":"Property Interface for Networks","title":"Erdos.add_vertex_property!","text":"add_vertex_property!(g, name, T)\nadd_vertex_property!(g, name, vmap)\n\nAdd the vertex property  name to g.\n\nIf a type T is given as an input, a vertex map with valtype T is created and stored into g.\n\nAs an alternative, an existing vertex map vmap can be stored into g.\n\nvprop! is the short form of this function.\n\n\n\n\n\n","category":"method"},{"location":"network_interface/#Erdos.edge_property-Tuple{ANetOrDiNet, AbstractString}","page":"Property Interface for Networks","title":"Erdos.edge_property","text":"edge_property(g, name)\n\nReturn an edge map corresponding to property name of edges in g.\n\nedge_property(g)\n\nReturns a dictionary with elements property_name => edge_map.\n\nedge_property(g, e)\nedge_property(g, u, v)\n\nReturns a dictionary of the form name => val containing all the properties associated to edge e.\n\nedge_property(g, e, name)\nedge_property(g, u, v, name)\n\nEquivalent to edge_property(g, e)[name]\n\neprop is the short form of this function.\n\n\n\n\n\n","category":"method"},{"location":"network_interface/#Erdos.eprop","page":"Property Interface for Networks","title":"Erdos.eprop","text":"See edge_property\n\n\n\n\n\n","category":"function"},{"location":"network_interface/#Erdos.eprop!","page":"Property Interface for Networks","title":"Erdos.eprop!","text":"See add_edge_property!\n\n\n\n\n\n","category":"function"},{"location":"network_interface/#Erdos.gprop","page":"Property Interface for Networks","title":"Erdos.gprop","text":"See graph_property\n\n\n\n\n\n","category":"function"},{"location":"network_interface/#Erdos.gprop!","page":"Property Interface for Networks","title":"Erdos.gprop!","text":"See set_graph_property!\n\n\n\n\n\n","category":"function"},{"location":"network_interface/#Erdos.graph_property-Tuple{ANetOrDiNet, AbstractString}","page":"Property Interface for Networks","title":"Erdos.graph_property","text":"graph_property(g, name)\n\nReturn the property name of g.\n\ngraph_property(g)\n\nReturns a dictionary with elements property_name => property_value\n\ngprop is the short form of this function.\n\n\n\n\n\n","category":"method"},{"location":"network_interface/#Erdos.has_edge_property-Tuple{ANetOrDiNet, AbstractString}","page":"Property Interface for Networks","title":"Erdos.has_edge_property","text":"has_edge_property(g, name)\nhas_edge_property(g, name, e)\n\nCheck if network  g has an edge property named name. The second method checks also if edge e has an assigned value for that property.\n\nhas_eprop is the short form of this function.\n\n\n\n\n\n","category":"method"},{"location":"network_interface/#Erdos.has_eprop","page":"Property Interface for Networks","title":"Erdos.has_eprop","text":"See has_edge_property\n\n\n\n\n\n","category":"function"},{"location":"network_interface/#Erdos.has_gprop","page":"Property Interface for Networks","title":"Erdos.has_gprop","text":"See has_graph_property\n\n\n\n\n\n","category":"function"},{"location":"network_interface/#Erdos.has_graph_property-Tuple{ANetOrDiNet, AbstractString}","page":"Property Interface for Networks","title":"Erdos.has_graph_property","text":"has_graph_property(g, name)\n\nCheck if network  g has a graph property named name.\n\nhas_gprop is the short form of this function.\n\n\n\n\n\n","category":"method"},{"location":"network_interface/#Erdos.has_vertex_property-Tuple{ANetOrDiNet, AbstractString}","page":"Property Interface for Networks","title":"Erdos.has_vertex_property","text":"has_vertex_property(g, name, v)\n\nCheck if network  g has a vertex property named name. The second method checks also if vertex v has an assigned value for that property.\n\nhas_vprop is the short form of this function.\n\n\n\n\n\n","category":"method"},{"location":"network_interface/#Erdos.has_vprop","page":"Property Interface for Networks","title":"Erdos.has_vprop","text":"See has_vertex_property\n\n\n\n\n\n","category":"function"},{"location":"network_interface/#Erdos.idx-Tuple{AIndexedEdge}","page":"Property Interface for Networks","title":"Erdos.idx","text":"idx(e::AIndexedEdge)\n\nReturns the index of edge e.\n\n\n\n\n\n","category":"method"},{"location":"network_interface/#Erdos.rem_edge_property!-Tuple{ANetOrDiNet, AbstractString}","page":"Property Interface for Networks","title":"Erdos.rem_edge_property!","text":"rem_edge_property!(g, name)\n\nRemove the edge property  name from g.\n\nrem_eprop! is the short form of this function.\n\n\n\n\n\n","category":"method"},{"location":"network_interface/#Erdos.rem_eprop!","page":"Property Interface for Networks","title":"Erdos.rem_eprop!","text":"See rem_edge_property!\n\n\n\n\n\n","category":"function"},{"location":"network_interface/#Erdos.rem_gprop!","page":"Property Interface for Networks","title":"Erdos.rem_gprop!","text":"See rem_graph_property!\n\n\n\n\n\n","category":"function"},{"location":"network_interface/#Erdos.rem_graph_property!-Tuple{ANetOrDiNet, AbstractString}","page":"Property Interface for Networks","title":"Erdos.rem_graph_property!","text":"rem_graph_property!(g, name)\n\nRemove the property name from g.\n\nrem_gprop! is the short form of this function.\n\n\n\n\n\n","category":"method"},{"location":"network_interface/#Erdos.rem_vertex_property!-Tuple{ANetOrDiNet, AbstractString}","page":"Property Interface for Networks","title":"Erdos.rem_vertex_property!","text":"rem_vertex_property!(g, name)\n\nRemove the vertex property  name from g.\n\nrem_vprop! is the short form of this function.\n\n\n\n\n\n","category":"method"},{"location":"network_interface/#Erdos.rem_vprop!","page":"Property Interface for Networks","title":"Erdos.rem_vprop!","text":"See rem_vertex_property!\n\n\n\n\n\n","category":"function"},{"location":"network_interface/#Erdos.set_graph_property!-Tuple{ANetOrDiNet, AbstractString, Any}","page":"Property Interface for Networks","title":"Erdos.set_graph_property!","text":"set_graph_property!(g, name, x)\n\nSet the property name to value x to g. Creates the property if it doesn't exist. gprop! can be conveniently used as a short form of this function.\n\nExample\n\ng = Network(10, 20)\nset_graph_property!(g, \"label\", \"My Network\")\n# or equivalently\ngprop!(g, \"label\", \"My Network\")\n\n\n\n\n\n","category":"method"},{"location":"network_interface/#Erdos.vertex_property-Tuple{ANetOrDiNet, AbstractString}","page":"Property Interface for Networks","title":"Erdos.vertex_property","text":"vertex_property(g, name)\n\nReturn an vertex map corresponding to property name of vertices in g.\n\nvertex_property(g)\n\nReturns a dictionary with elements property_name => vertex_map.\n\nvertex_property(g, v)\n\nReturns a dictionary of the form name => val containing all the properties associated to vertex v.\n\nvertex_property(g, v, name)\n\nEquivalent to vertex_property(g, v)[name].\n\nvprop is the short form for this function.\n\n\n\n\n\n","category":"method"},{"location":"network_interface/#Erdos.vprop","page":"Property Interface for Networks","title":"Erdos.vprop","text":"See vertex_property\n\n\n\n\n\n","category":"function"},{"location":"network_interface/#Erdos.vprop!","page":"Property Interface for Networks","title":"Erdos.vprop!","text":"See add_vertex_property!\n\n\n\n\n\n","category":"function"},{"location":"network_interface/#Defining-new-network-types","page":"Property Interface for Networks","title":"Defining new network types","text":"","category":"section"},{"location":"network_interface/","page":"Property Interface for Networks","title":"Property Interface for Networks","text":"In order to define a custom network type, e.g. MyNet <: ANetwork, the corresponding interface methods  have to be implemented. This is automatically done for custom network types having a props::PropertyStore member. Take a look at src/factory/network.jl and src/maps/property_store.jl for an example.","category":"page"},{"location":"flow/#Flow-and-Cut","page":"Flow and Cut","title":"Flow and Cut","text":"","category":"section"},{"location":"flow/","page":"Flow and Cut","title":"Flow and Cut","text":"Erdos.jl provides different algorithms for maximum flow and minimum cut computations.","category":"page"},{"location":"flow/","page":"Flow and Cut","title":"Flow and Cut","text":"Modules = [Erdos]\nPages   = [ \"flow/boykov_kolmogorov.jl\",\n            \"flow/dinic.jl\",\n            \"flow/edmonds_karp.jl\",\n            \"flow/maximum_flow.jl\",\n            \"flow/multiroute_flow.jl\",\n            \"flow/ext_multiroute_flow.jl\",\n            \"flow/push_relabel.jl\"]\nPrivate = false","category":"page"},{"location":"flow/#Erdos.BoykovKolmogorovAlgorithm","page":"Flow and Cut","title":"Erdos.BoykovKolmogorovAlgorithm","text":"Forces the maximum_flow function to use the Boykov-Kolmogorov algorithm.\n\n\n\n\n\n","category":"type"},{"location":"flow/#Erdos.DinicAlgorithm","page":"Flow and Cut","title":"Erdos.DinicAlgorithm","text":"Forces the maximum_flow function to use Dinic's algorithm.\n\n\n\n\n\n","category":"type"},{"location":"flow/#Erdos.EdmondsKarpAlgorithm","page":"Flow and Cut","title":"Erdos.EdmondsKarpAlgorithm","text":"Forces the maximum_flow function to use the Edmonds–Karp algorithm.\n\n\n\n\n\n","category":"type"},{"location":"flow/#Erdos.PushRelabelAlgorithm","page":"Flow and Cut","title":"Erdos.PushRelabelAlgorithm","text":"Forces the maximum_flow function to use the Push-Relabel algorithm.\n\n\n\n\n\n","category":"type"},{"location":"flow/#Erdos.maximum_flow-Union{Tuple{T}, Tuple{G}, Tuple{G, Any, Any}, Tuple{G, Any, Any, AbstractMatrix{T}}} where {G<:ADiGraph, T<:Number}","page":"Flow and Cut","title":"Erdos.maximum_flow","text":"maximum_flow{T<:Number}(\n                    g::ADiGraph,\n                    source::Int,\n                    target::Int,\n                    capacity_matrix::AbstractMatrix{T} =\n                        DefaultCapacity(g);\n                    algorithm::AbstractFlowAlgorithm  =\n                        PushRelabelAlgorithm(),\n                    restriction::T = zero(T)\n                )\n\nGeneric maximumflow function. The function defaults to the Push-Relabel (also called Preflow) algorithm. Alternatively, the algorithm to be used can also be specified through a keyword argument. A default capacity of 1 is assumed for each link if no capacity matrix is provided. If the restriction is bigger than 0, it is applied to capacitymatrix.\n\nAll algorithms return a tuple with\n\nthe maximum flow\nthe flow matrix\nthe labelling associated to the minimum cut\n\nAvailable algorithms are DinicAlgorithm, EdmondsKarpAlgorithm, BoykovKolmogorovAlgorithm and PushRelabelAlgorithm.\n\nTime complexity is O(V²√E) for the push relabel algorithm.\n\nUsage Example:\n\n\n# Create a flow-graph and a capacity matrix\ng = DiGraph(8)\nflow_edges = [\n    (1,2,10),(1,3,5),(1,4,15),(2,3,4),(2,5,9),\n    (2,6,15),(3,4,4),(3,6,8),(4,7,16),(5,6,15),\n    (5,8,10),(6,7,15),(6,8,10),(7,3,6),(7,8,10)\n]\ncapacity_matrix = zeros(Int, 8, 8)\nfor e in flow_edges\n    u, v, f = e\n    add_edge!(g, u, v)\n    capacity_matrix[u,v] = f\nend\n\n# Run default maximum_flow without the capacity_matrix (assumes capacity 1. on each edge).\nf, F, labels = maximum_flow(g, 1, 8)\n\n# Run Endmonds-Karp algorithm\nf, F, labels = maximum_flow(g,1,8,capacity_matrix,algorithm=EdmondsKarpAlgorithm())\n\n\n\n\n\n","category":"method"},{"location":"flow/#Erdos.minimum_cut-Tuple{ADiGraph, Integer, Integer, Vararg{Any, N} where N}","page":"Flow and Cut","title":"Erdos.minimum_cut","text":"minimum_cut(g, s, t, capacity_matrix=DefaultCapacity(); kws...)\n\nFinds the s-t cut of minimal weight according to the capacities matrix on the directed graph g. The solution is found through a maximal flow algorithm. See maximum_flow for the optional arguments.\n\nReturns a triple (f, cut, labels), where f is the weight of the cut, cut is a vector of the edges in the cut, and labels gives a partitioning of the vertices in two sets, according to the cut.\n\n\n\n\n\n","category":"method"},{"location":"flow/#Erdos.ExtendedMultirouteFlowAlgorithm","page":"Flow and Cut","title":"Erdos.ExtendedMultirouteFlowAlgorithm","text":"Forces the multiroute_flow function to use the Extended Multiroute Flow algorithm.\n\n\n\n\n\n","category":"type"},{"location":"flow/#Erdos.KishimotoAlgorithm","page":"Flow and Cut","title":"Erdos.KishimotoAlgorithm","text":"Forces the multiroute_flow function to use the Kishimoto algorithm.\n\n\n\n\n\n","category":"type"},{"location":"flow/#Erdos.multiroute_flow-Union{Tuple{R}, Tuple{T}, Tuple{ADiGraph, Int64, Int64}, Tuple{ADiGraph, Int64, Int64, AbstractMatrix{T}}} where {T<:Real, R<:Real}","page":"Flow and Cut","title":"Erdos.multiroute_flow","text":"The generic multiroute_flow function will output three kinds of results:\n\nWhen the number of routes is 0 or non-specified, the set of breaking points of\n\nthe multiroute flow is returned.\n\nWhen the input is limited to a set of breaking points and a route value k,\n\nonly the value of the k-route flow is returned\n\nOtherwise, a tuple with 1) the maximum flow and 2) the flow matrix. When the\n\nmax-flow subroutine is the Boykov-Kolmogorov algorithm, the associated mincut is returned as a third output.\n\nWhen the input is a network, it requires the following arguments:\n\nflow_graph::ADiGraph                   # the input graph\nsource::Int                           # the source vertex\ntarget::Int                           # the target vertex\ncapacity_matrix::AbstractMatrix{T}  # edge flow capacities with T<:Real\nflow_algorithm::AbstractFlowAlgorithm # keyword argument for flow algorithm\nmrf_algorithm::AbstractFlowAlgorithm  # keyword argument for multiroute flow algorithm\nroutes::R<:Real                       # keyword argument for the number of routes\n\nWhen the input is only the set of (breaking) points and the number of route, it requires the following arguments:\n\nbreakingpoints::Vector{Tuple{T, T, Int}},    # vector of breaking points\nroutes::R<:Real,                             # number of routes\n\nWhen the input is the set of (breaking) points, the number of routes, and the network descriptors, it requires the following arguments:\n\nbreakingpoints::Vector{Tuple{T1, T1, Int}} # vector of breaking points (T1<:Real)\nroutes::R<:Real                            # number of routes\nflow_graph::ADiGraph                        # the input graph\nsource::Int                                # the source vertex\ntarget::Int                                # the target vertex\ncapacity_matrix::AbstractMatrix{T2}      # optional edge flow capacities (T2<:Real)\nflow_algorithm::AbstractFlowAlgorithm      # keyword argument for algorithm\n\nThe function defaults to the Push-relabel (classical flow) and Kishimoto (multiroute) algorithms. Alternatively, the algorithms to be used can also be specified through  keyword arguments. A default capacity of 1 is assumed for each link if no capacity matrix is provided.\n\nThe mrf_algorithm keyword is inforced to Extended Multiroute Flow in the following cases:\n\nThe number of routes is non-integer\nThe number of routes is 0 or non-specified\n\nUsage Example :\n\n(please consult the  maxflow section for options about flowalgorithm and capacity_matrix)\n\n\n# Create a flow-graph and a capacity matrix\nflow_graph = DiGraph(8)\nflow_edges = [\n    (1, 2, 10), (1, 3, 5),  (1, 4, 15), (2, 3, 4),  (2, 5, 9),\n    (2, 6, 15), (3, 4, 4),  (3, 6, 8),  (4, 7, 16), (5, 6, 15),\n    (5, 8, 10), (6, 7, 15), (6, 8, 10), (7, 3, 6),  (7, 8, 10)\n]\ncapacity_matrix = zeros(Int, 8, 8)\nfor e in flow_edges\n    u, v, f = e\n    add_edge!(flow_graph, u, v)\n    capacity_matrix[u, v] = f\nend\n\n# Run default multiroute_flow with an integer number of routes = 2\nf, F = multiroute_flow(flow_graph, 1, 8, capacity_matrix, routes = 2)\n\n# Run default multiroute_flow with a noninteger number of routes = 1.5\nf, F = multiroute_flow(flow_graph, 1, 8, capacity_matrix, routes = 1.5)\n\n# Run default multiroute_flow for all the breaking points values\npoints = multiroute_flow(flow_graph, 1, 8, capacity_matrix)\n# Then run multiroute flow algorithm for any positive number of routes\nf, F = multiroute_flow(points, 1.5)\nf = multiroute_flow(points, 1.5, valueonly = true)\n\n# Run multiroute flow algorithm using Boykov-Kolmogorov algorithm as max_flow routine\nf, F, labels = multiroute_flow(flow_graph, 1, 8, capacity_matrix,\n               algorithm = BoykovKolmogorovAlgorithm(), routes = 2)\n\n\n\n\n\n\n","category":"method"},{"location":"connectivity/#Connectivity","page":"Connectivity","title":"Connectivity","text":"","category":"section"},{"location":"connectivity/","page":"Connectivity","title":"Connectivity","text":"Connectivity related methods.","category":"page"},{"location":"connectivity/","page":"Connectivity","title":"Connectivity","text":"Pages   = [\"connectivity.md\"]","category":"page"},{"location":"connectivity/","page":"Connectivity","title":"Connectivity","text":"Modules = [Erdos]\nPages   = [\"core/connectivity.jl\"]\nPrivate = false","category":"page"},{"location":"datasets/#Graphs-Datasets","page":"Graph Datasets","title":"Graphs Datasets","text":"","category":"section"},{"location":"datasets/","page":"Graph Datasets","title":"Graph Datasets","text":"The datasets folder contains real world graphs in the graph-tool format .gt, mostly collected by Tiago de Paula Peixoto. They are released under the GPLv3 license,","category":"page"},{"location":"datasets/","page":"Graph Datasets","title":"Graph Datasets","text":"They can be read with","category":"page"},{"location":"datasets/","page":"Graph Datasets","title":"Graph Datasets","text":"readgraph(s, G=Graph)","category":"page"},{"location":"datasets/","page":"Graph Datasets","title":"Graph Datasets","text":"where s is any of the symbols below and G is a (di)graph type. Here is a complete list of the graphs in the form","category":"page"},{"location":"datasets/","page":"Graph Datasets","title":"Graph Datasets","text":"s        |      N        |    E         |   directed | ....description....","category":"page"},{"location":"datasets/","page":"Graph Datasets","title":"Graph Datasets","text":"","category":"page"},{"location":"datasets/","page":"Graph Datasets","title":"Graph Datasets","text":":adjnoun        |      112    |      425    |      false |      Word adjacencies: adjacency network of common  adjectives and nouns in the novel David Copperfield by Charles Dickens. Please cite M. E. J. Newman, Phys. Rev. E 74, 036104 (2006). Retrieved from Mark Newman's website.","category":"page"},{"location":"datasets/","page":"Graph Datasets","title":"Graph Datasets","text":":as22july06     |     22963   |     48436   |     false  |    Internet: a symmetrized snapshot of the structure of the Internet at the level of autonomous systems, reconstructed from BGP tables posted by the University of Oregon Route Views Project. This snapshot was created by Mark Newman from data for July 22, 2006 and is not previously published. Retrieved from Mark Newman's website.","category":"page"},{"location":"datasets/","page":"Graph Datasets","title":"Graph Datasets","text":":astroph        |     16706   |     121251  |     false  |    Astrophysics collaborations: weighted network of coauthorships between scientists posting preprints on the Astrophysics E-Print Archive between Jan 1, 1995 and December 31, 1999. Please cite M. E. J. Newman, Proc. Natl. Acad. Sci. USA 98, 404-409 (2001). Retrieved from Mark Newman's website.","category":"page"},{"location":"datasets/","page":"Graph Datasets","title":"Graph Datasets","text":":celegansneural |      297    |      2359   |      true  |     Neural network: A directed, weighted network representing the neural network of C. Elegans. Data compiled by D. Watts and S. Strogatz and made available on the web here. Please cite D. J. Watts and S. H. Strogatz, Nature 393, 440-442 (1998). Original experimental data taken from J. G. White, E. Southgate, J. N. Thompson, and S. Brenner, Phil. Trans. R. Soc. London 314, 1-340 (1986). Retrieved from Mark Newman's website","category":"page"},{"location":"datasets/","page":"Graph Datasets","title":"Graph Datasets","text":":condmat        |     16726   |     47594   |     false  |    Condensed matter collaborations 1999: weighted network of coauthorships between scientists posting preprints on the Condensed Matter E-Print Archive between Jan 1, 1995 and December 31, 1999. Please cite M. E. J. Newman, The structure of scientific collaboration networks, Proc. Natl. Acad. Sci. USA 98, 404-409 (2001). Retrieved from Mark Newman's website","category":"page"},{"location":"datasets/","page":"Graph Datasets","title":"Graph Datasets","text":":condmat2003    |    31163    |    120029   |    false   |   Condensed matter collaborations 2003: updated network of coauthorships between scientists posting preprints on the Condensed Matter E-Print Archive. This version includes all preprints posted between Jan 1, 1995 and June 30, 2003. The largest component of this network, which contains 27519 scientists, has been used by several authors as a test-bed for community-finding algorithms for large networks; see for example J. Duch and A. Arenas, Phys. Rev. E 72, 027104 (2005). These data can be cited as M. E. J. Newman, Proc. Natl. Acad. Sci. USA 98, 404-409 (2001). Retrieved from Mark Newman's website.","category":"page"},{"location":"datasets/","page":"Graph Datasets","title":"Graph Datasets","text":":condmat2005    |    40421    |    175693   |    false   |   Condensed matter collaborations 2005: updated network of coauthorships between scientists posting preprints on the Condensed Matter E-Print Archive. This version includes all preprints posted between Jan 1, 1995 and March 31, 2005. Please cite M. E. J. Newman, Proc. Natl. Acad. Sci. USA 98, 404-409 (2001). Retrieved from Mark Newman's website.","category":"page"},{"location":"datasets/","page":"Graph Datasets","title":"Graph Datasets","text":":dolphins       |      62     |      159    |      false |    Dolphin social network: an undirected social network of frequent associations between 62 dolphins in a community living off Doubtful Sound, New Zealand. Please cite D. Lusseau, K. Schneider, O. J. Boisseau, P. Haase, E. Slooten, and S. M. Dawson, Behavioral Ecology and Sociobiology 54, 396-405 (2003). Retrieved from Mark Newman's website.","category":"page"},{"location":"datasets/","page":"Graph Datasets","title":"Graph Datasets","text":":emailenron     |     36692   |     183831  |     false  |    Enron email communication network covers all the email communication within a dataset of around half million emails. This data was originally made public, and posted to the web, by the Federal Energy Regulatory Commission during its investigation. Nodes of the network are email addresses and if an address i sent at least one email to address j, the graph contains an undirected edge from i to j. Note that non-Enron email addresses act as sinks and sources in the network as we only observe their communication with the Enron email addresses. The Enron email data was originally released by William Cohen at CMU. This version was retrieved from the SNAP database at http://snap.stanford.edu/data/email-Enron.html. Please cite: J. Leskovec, K. Lang, A. Dasgupta, M. Mahoney. Community Structure in Large Networks: Natural Cluster Sizes and the Absence of Large Well-Defined Clusters. Internet Mathematics 6(1) 29–123, 2009,  B. Klimmt, Y. Yang. Introducing the Enron corpus. CEAS conference, 2004.","category":"page"},{"location":"datasets/","page":"Graph Datasets","title":"Graph Datasets","text":":football       |      115    |      615    |      false |     American College football: network of American football games between Division IA colleges during regular season Fall 2000. Please cite M. Girvan and M. E. J. Newman, Proc. Natl. Acad. Sci. USA 99, 7821-7826 (2002), and T.S. Evans, \"Clique Graphs and Overlapping Communities\", J.Stat.Mech. (2010) P12037 [arXiv:1009.0638]. Retrieved from Mark Newman's website, with corrections by T. S. Evans, available here.","category":"page"},{"location":"datasets/","page":"Graph Datasets","title":"Graph Datasets","text":":hepth          |     8361    |     15751   |     false  |    High-energy theory collaborations: weighted network of coauthorships between scientists posting preprints on the High-Energy Theory E-Print Archive between Jan 1, 1995 and December 31, 1999. Please cite M. E. J. Newman, Proc. Natl. Acad. Sci. USA 98, 404-409 (2001). Retrieved from Mark Newman's website.","category":"page"},{"location":"datasets/","page":"Graph Datasets","title":"Graph Datasets","text":":karate         |      34     |      78     |      false |     Zachary's karate club: social network of friendships between 34 members of a karate club at a US university in the 1970s. Please cite W. W. Zachary, An information flow model for conflict and fission in small groups, Journal of Anthropological Research 33, 452-473 (1977). Retrieved from Mark Newman's website.","category":"page"},{"location":"datasets/","page":"Graph Datasets","title":"Graph Datasets","text":":lesmis         |      77     |      254    |      false |     Les Miserables: coappearance network of characters in the novel Les Miserables. Please cite D. E. Knuth, The Stanford GraphBase: A Platform for Combinatorial Computing, Addison-Wesley, Reading, MA (1993). Retrieved from Mark Newman's website.","category":"page"},{"location":"datasets/","page":"Graph Datasets","title":"Graph Datasets","text":":netscience     |      1589   |      2742   |      false |     Coauthorships in network science: coauthorship network of scientists working on network theory and experiment, as compiled by M. Newman in May 2006. A figure depicting the largest component of this network can be found here. These data can be cited as M. E. J. Newman, Phys. Rev. E 74, 036104 (2006). Retrieved from Mark Newman's website.","category":"page"},{"location":"datasets/","page":"Graph Datasets","title":"Graph Datasets","text":":pgpstrong2009  |    39796    |    301498   |    true    | Strongly connected component of the PGP web of trust circa November 2009. The full data is available at http://key-server.de/dump/. Please cite: Richters O, Peixoto TP (2011) Trust Transitivity in Social Networks. PLoS ONE 6(4): e18384. :doi:10.1371/journal.pone.0018384.","category":"page"},{"location":"datasets/","page":"Graph Datasets","title":"Graph Datasets","text":":polblogs       |      1490   |      19090  |      true  |     Political blogs: A directed network of hyperlinks between weblogs on US politics, recorded in 2005 by Adamic and Glance. Please cite L. A. Adamic and N. Glance, \"The political blogosphere and the 2004 US Election\", in Proceedings of the WWW-2005 Workshop on the Weblogging Ecosystem (2005). Retrieved from Mark Newman's website.","category":"page"},{"location":"datasets/","page":"Graph Datasets","title":"Graph Datasets","text":":polbooks       |      105    |      441    |      false |     Books about US politics: A network of books about US politics published around the time of the 2004 presidential election and sold by the online bookseller Amazon.com. Edges between books represent frequent copurchasing of books by the same buyers. The network was compiled by V. Krebs and is unpublished, but can found on Krebs' web site. Retrieved from Mark Newman's website.","category":"page"},{"location":"datasets/","page":"Graph Datasets","title":"Graph Datasets","text":":power          |      4941   |      6594   |      false |     Power grid: An undirected, unweighted network representing the topology of the Western States Power Grid of the United States. Data compiled by D. Watts and S. Strogatz and made available on the web here. Please cite D. J. Watts and S. H. Strogatz, Nature 393, 440-442 (1998). Retrieved from Mark Newman's website.","category":"page"},{"location":"datasets/","page":"Graph Datasets","title":"Graph Datasets","text":":serengetifoodweb |   161     |     592     |     true   |    Plant and mammal food web from the Serengeti savanna ecosystem in Tanzania. Please cite: Baskerville EB, Dobson AP, Bedford T, Allesina S, Anderson TM, et al. (2011) Spatial Guilds in the Serengeti Food Web Revealed by a Bayesian :doi:10.1371/journal.pcbi.1002321 Group Model. PLoS Comput Biol 7(12): e1002321","category":"page"},{"location":"dismantling/#Dismantling","page":"Dismantling","title":"Dismantling","text":"","category":"section"},{"location":"dismantling/","page":"Dismantling","title":"Dismantling","text":"Algorithms for network dismantling and influencer search.","category":"page"},{"location":"dismantling/","page":"Dismantling","title":"Dismantling","text":"Modules = [Erdos]\nPages   = [\"dismantling/ci.jl\"]\nPrivate = false","category":"page"},{"location":"dismantling/#Erdos.dismantle_ci-Tuple{AGraph, Integer, Integer}","page":"Dismantling","title":"Erdos.dismantle_ci","text":"dismantle_ci(g::AGraph, l::Integer, nrem; verbose=false)\n\nApplies the Collective Influence (CI) heuristic of Ref. [1]  with distance parameter l (tipically l=3,4). Removes a maximum of nrem vertices from g, trying to minimize the size of the maximum connected component of the resulting graph. It stops earlier if the maximum CI goes to zero.\n\nSet verbose to true for info printing in each iteration.\n\nReturns (gnew, vmap, remlist), where gnew is the reduced graph, vmap is a vertex map of the vertices of gnew to the old ones (see also rem_vertices!) and remlist contains the removed vertices by removal order.\n\nFor more fine grained control see dismantle_ci_init and dismantle_ci_oneiter!.\n\nUsage\n\ng = Graph(100, 1000)\nl=3\nnrem=10\ngnew, vmap, remlist = dismantle_ci(g, l, nrem)\n\n# or equivalently\ngnew, heap, lneigs = dismantle_ci_init(g, l)\n\nfor it=1:nrem\n    irem = dismantle_ci_oneiter!(gnew, heap, lneigs, l)\n    irem <= 0 && break\n    push!(remlist, irem)\n    println(\"Size Max Component: \", maximum(length, connected_components(g)))\nend\nvmap = rem_vertices!(gnew, remlist)\n\n[1] Morone F., Makse H. Influence maximization in complex networks through optimal percolation. Nature (2015)\n\n\n\n\n\n","category":"method"},{"location":"dismantling/#Erdos.dismantle_ci_init-Tuple{AGraph, Integer}","page":"Dismantling","title":"Erdos.dismantle_ci_init","text":"dismantle_ci_init(g, l)\n\nInitialization part of dismantle_ci algorithm. Returns (gnew, heap, lneigs).\n\n\n\n\n\n","category":"method"},{"location":"dismantling/#Erdos.dismantle_ci_oneiter!-Union{Tuple{T}, Tuple{AGraph, Any, Array{Vector{T}, 1}, Integer}} where T","page":"Dismantling","title":"Erdos.dismantle_ci_oneiter!","text":"dismantle_ci_oneiter!(g, heap, lneigs, l)\n\nOne step of dismantle_ci algorithm. To be called after dismantle_ci_init Returns the cleaned vertex if any (see clean_vertex!), -1 otherwise.\n\n\n\n\n\n","category":"method"},{"location":"graph_types/#Graph-Types-and-Constructors","page":"Graph Types","title":"Graph Types and Constructors","text":"","category":"section"},{"location":"graph_types/","page":"Graph Types","title":"Graph Types","text":"Erdos.jl defines a type hierarchy and associated methods for expressing a graph topology and implementing related algorithms. The ready to go graph types are the Graph type for undirected graphs and the DiGraph type for directed graphs. Custom types con be defined inheriting from the abstract types AGraph and ADiGraph. Graph types supporting the internal storages of edge/vertex properties are called networks in Erdos and are documeted here","category":"page"},{"location":"graph_types/#Abstract-Types","page":"Graph Types","title":"Abstract Types","text":"","category":"section"},{"location":"graph_types/","page":"Graph Types","title":"Graph Types","text":"AGraph\nADiGraph\nAGraphOrDiGraph\nAEdge","category":"page"},{"location":"graph_types/#Erdos.AGraph","page":"Graph Types","title":"Erdos.AGraph","text":"abstract type AGraph end\n\nAbstract undirected graph type\n\n\n\n\n\n","category":"type"},{"location":"graph_types/#Erdos.ADiGraph","page":"Graph Types","title":"Erdos.ADiGraph","text":"abstract ADiGraph\n\nAbstract directed graph type\n\n\n\n\n\n","category":"type"},{"location":"graph_types/#Erdos.AGraphOrDiGraph","page":"Graph Types","title":"Erdos.AGraphOrDiGraph","text":"const AGraphOrDiGraph = Union{AGraph, ADiGraph}\n\nUnion of AGraph and ADiGraph.\n\n\n\n\n\n","category":"type"},{"location":"graph_types/#Erdos.AEdge","page":"Graph Types","title":"Erdos.AEdge","text":"abstract type AEdge end\n\nAn abstract edge type.\n\n\n\n\n\n","category":"type"},{"location":"graph_types/#Graph-/-DiGraph-/-Edge","page":"Graph Types","title":"Graph / DiGraph / Edge","text":"","category":"section"},{"location":"graph_types/","page":"Graph Types","title":"Graph Types","text":"Graph\nDiGraph\nEdge","category":"page"},{"location":"graph_types/#Erdos.Graph","page":"Graph Types","title":"Erdos.Graph","text":"mutable struct Graph{T<:Integer} <: AGraph\n    ne::Int\n    fadjlist::Vector{Vector{T}}\nend\n\nA simple graph type based on an adjacency list.\n\nThe constructors\n\nGraph{T}(n=0)\nGraph(n=0) = Graph{Int}(n)\n\nreturn a Graph with n vertices and no edges.\n\nGraph{T}(adjmx::AbstractMatrix; upper=false, selfedges=true)\n\nConstruct a Graph{T} from the adjacency matrix adjmx, placing an edge in correspondence to each nonzero element of adjmx. If selfedges=false the diagonal elements of adjmx are ignored. If upper=true only the upper triangular part of adjmx is considered.\n\n\n\n\n\n","category":"type"},{"location":"graph_types/#Erdos.DiGraph","page":"Graph Types","title":"Erdos.DiGraph","text":"mutable struct DiGraph{T<:Integer} <: ADiGraph\n    ne::Int\n    fadjlist::Vector{Vector{T}}\n    badjlist::Vector{Vector{T}}\nend\n\nA simple digraph type based on two adjacency lists (forward and backward).\n\nDiGraph{T}(n=0)\nDiGraph(n=0) = DiGraph{Int}(n)\n\nConstruct a DiGraph with n vertices and no edges.\n\nDiGraph{T}(adjmx::AbstractMatrix; selfedges=true)\n\nConstruct a DiGraph{T} from the adjacency matrix adjmx, placing an edge in correspondence to each nonzero element of adjmx. If selfedges=false the diagonal elements of adjmx are ignored.\n\n\n\n\n\n","category":"type"},{"location":"graph_types/#Erdos.Edge","page":"Graph Types","title":"Erdos.Edge","text":"struct Edge\n    src::Int\n    dst::Int\nend\n\nA type representing an edge between two vertices of a graph.\n\n\n\n\n\n","category":"type"},{"location":"graph_types/#Defining-new-types","page":"Graph Types","title":"Defining new types","text":"","category":"section"},{"location":"graph_types/","page":"Graph Types","title":"Graph Types","text":"In order to define a custom graph type, e.g. MyGraph <: AGraph, some guarantee have to be respected and some methods have to be exposed. Take a look to the files in src/factory/ for some examples. Custom edges, e.g. MyEdge <: AEdge,  have to expose src(e) and dst(e) methods.","category":"page"},{"location":"graph_types/","page":"Graph Types","title":"Graph Types","text":"Guarantees:","category":"page"},{"location":"graph_types/","page":"Graph Types","title":"Graph Types","text":"vertices are integers in 1:nv(g)","category":"page"},{"location":"graph_types/","page":"Graph Types","title":"Graph Types","text":"Mandatory methods:","category":"page"},{"location":"graph_types/","page":"Graph Types","title":"Graph Types","text":"basic constructors: MyGraph(n), MyGraph())\nnv(g)\nne(g)\nout_neighbors(g, v)\nin_neighbors(g, v) #digraph\nedge(g, u, v)\nadd_edge!(g, u, v)\nrem_edge!(g, u, v)\nadd_vertex!(g)\npop_vertex!(g)\ngraphtype(g)\ndigraphtype(g)\nedgetype(g)\nvertextype(g)\nswap_vertices!(g, u, v)","category":"page"},{"location":"graph_types/","page":"Graph Types","title":"Graph Types","text":"Some methods have general fallbacks relying on the more foundamental API described above, but could probably made more efficient knowing the internal implementation of the graph.","category":"page"},{"location":"graph_types/","page":"Graph Types","title":"Graph Types","text":"Reccomended overrides:","category":"page"},{"location":"graph_types/","page":"Graph Types","title":"Graph Types","text":"in_adjlist(g) #digraph\nout_adjlist(g)\nhas_edge(g, u, v)\n==(g, h)\nout_edges(g, u)\nin_edges(g, u) # digraph\nrem_edge!(g, e)\ngraph(dg)\ndigraph(g)\nreverse!(g) #digraph\nunsafeaddedge!(g, u, v)\nrebuild!(g)\nrem_vertex!(g, v)","category":"page"},{"location":"network_types/#network_types","page":"Network Types","title":"Network Types and Interface","text":"","category":"section"},{"location":"network_types/","page":"Network Types","title":"Network Types","text":"Networks in Erdos.jl are graphs with additional ability to store properties associated to vertices, edges and the graph itself. The ready to go network types are the Network and DiNetwork types. Custom types con be defined inheriting from ANetwork and ADiNetwork abstract types.","category":"page"},{"location":"network_types/#Abstract-Types","page":"Network Types","title":"Abstract Types","text":"","category":"section"},{"location":"network_types/","page":"Network Types","title":"Network Types","text":"ANetwork\nADiNetwork\nAIndexedEdge","category":"page"},{"location":"network_types/#Erdos.ANetwork","page":"Network Types","title":"Erdos.ANetwork","text":"abstract type ANetwork <: AGraph end\n\nAn abstract graph with the additional possibility to attach properties to vertices and edges.\n\n\n\n\n\n","category":"type"},{"location":"network_types/#Erdos.ADiNetwork","page":"Network Types","title":"Erdos.ADiNetwork","text":"abstract type ADiNetwork <: ADiGraph end\n\nAn abstract directed graph with the additional possibility to attach properties to vertices and edges.\n\n\n\n\n\n","category":"type"},{"location":"network_types/#Erdos.AIndexedEdge","page":"Network Types","title":"Erdos.AIndexedEdge","text":"abstract type AIndexedEdge <: AEdge end\n\nEdge types with unique indexes, accessed by idx\n\n\n\n\n\n","category":"type"},{"location":"network_types/#Network-/-DiNetwork-/-IndexedEdge","page":"Network Types","title":"Network / DiNetwork / IndexedEdge","text":"","category":"section"},{"location":"network_types/","page":"Network Types","title":"Network Types","text":"Network\nDiNetwork\nIndexedEdge","category":"page"},{"location":"network_types/#Erdos.Network","page":"Network Types","title":"Erdos.Network","text":"mutable struct Network <: ANetwork\n    ne::Int\n    edge_index_range::Int\n    out_edges::Vector{Vector{Pair{Int,Int}}}  #unordered adjlist\n    epos::Vector{Pair{Int,Int}}    # position of the edge in out_edges\n    free_indexes::Vector{Int}       # indexes of deleted edges to be used up\n                                    # for new edges to avoid very large\n                                    # indexes, and unnecessary property map\n                                    # memory used\n    props::PropertyStore\nend\n\nA type representing a directed graph with indexed edges.\n\nNetwork(n=0)\n\nConstruct a Network with n vertices and no edges.\n\nNetwork(adjmx::AbstractMatrix; selfedges=true, upper=false)\n\nConstruct a Network from the adjacency matrix adjmx, placing an edge in correspondence to each nonzero element of adjmx. If selfedges=false the diagonal elements of adjmx are ignored. If upper=true only the upper triangular part of adjmx is considered.\n\n\n\n\n\n","category":"type"},{"location":"network_types/#Erdos.DiNetwork","page":"Network Types","title":"Erdos.DiNetwork","text":"mutable struct DiNetwork <: ADiNetwork\n    ne::Int\n    edge_index_range::Int\n    out_edges::Vector{Vector{Pair{Int,Int}}}  #unordered out_adjlist\n    in_edges::Vector{Vector{Pair{Int,Int}}}  #unordered in_adjlist\n\n    epos::Vector{Pair{Int,Int}}    # position of the edge in out_edges\n                                    # the first in the pair is the vertex\n                                    # with lower index\n\n    free_indexes::Vector{Int}       # indexes of deleted edges to be used up\n                                    # for new edges to avoid very large\n                                    # indexes, and unnecessary property map\n                                    # memory use\n    props::PropertyStore\nend\n\nA type representing an directed graph with indexed edges.\n\nDiNetwork(n=0)\n\nConstruct a DiNetwork with n vertices and no edges.\n\nDiNetwork(adjmx::AbstractMatrix; selfedges=true)\n\nConstruct a DiNetwork from the adjacency matrix adjmx. If selfedges=false the diagonal elements of adjmx are ignored.\n\n\n\n\n\n","category":"type"},{"location":"network_types/#Erdos.IndexedEdge","page":"Network Types","title":"Erdos.IndexedEdge","text":"struct IndexedEdge <: AIndexedEdge\n    src::Int\n    dst::Int\n    idx::Int\nend\n\nAn indexed edge type\n\nIndexedEdge(u, v) = IndexedEdge(u,v,-1)\n\nCreates an edge with invalid index.\n\n\n\n\n\n","category":"type"},{"location":"network_types/#Defining-new-network-types","page":"Network Types","title":"Defining new network types","text":"","category":"section"},{"location":"network_types/","page":"Network Types","title":"Network Types","text":"In order to define a custom network type, e.g. MyNet <: ANetwork, the corresponding methods in the preceding paragraph have to be implemented. This is automatically done for custom network types having a props::PropertyStore member. Take a look to src/factory/network.jl and src/maps/property_store.jl for an example.","category":"page"},{"location":"matching/#Matching","page":"Matching","title":"Matching","text":"","category":"section"},{"location":"matching/","page":"Matching","title":"Matching","text":"Algorithms for the optimal matching problems. Functionalities moved to  ErdosExtras.jl.","category":"page"},{"location":"centrality/#Centrality-Measures","page":"Centrality Measures","title":"Centrality Measures","text":"","category":"section"},{"location":"centrality/","page":"Centrality Measures","title":"Centrality Measures","text":"Centrality measures describe the importance of a vertex to the rest of the graph using some set of criteria. Centrality measures implemented in Erdos.jl include the following:","category":"page"},{"location":"centrality/","page":"Centrality Measures","title":"Centrality Measures","text":"Order = [:type, :function]\nPages   = [\"centrality.md\"]","category":"page"},{"location":"centrality/","page":"Centrality Measures","title":"Centrality Measures","text":"Modules = [Erdos]\nPages   = [\n            \"centrality/betweenness.jl\",\n            \"centrality/closeness.jl\",\n            \"centrality/degree.jl\",\n            \"centrality/katz.jl\",\n            \"centrality/pagerank.jl\",\n            \"centrality/kcore.jl\"\n            ]\nPrivate = false","category":"page"},{"location":"centrality/#Erdos.betweenness_centrality-Tuple{AGraphOrDiGraph}","page":"Centrality Measures","title":"Erdos.betweenness_centrality","text":"betweenness_centrality(g; normalize=true, endpoints=false, approx=-1)\n\nCalculates the betweenness centrality of the vertices of graph g.\n\nBetweenness centrality for vertex v is defined as:\n\nbc(v) = frac1mathcalN sum_s neq t neq v\n        fracsigma_st(v)sigma_st\n\nwhere sigma _st sigma_st is the total number of shortest paths from node s to node t and sigma_st(v) is the number of those paths that pass through v.\n\nIf endpoints=true, endpoints are included in the shortest path count.\n\nIf normalize=true, the betweenness values are normalized by the total number of possible distinct paths between all pairs in the graph. For an undirected graph, this number if ((n-1)*(n-2))/2 and for a directed graph, (n-1)*(n-2) where n is the number of vertices in the graph.\n\nIf  an integer argument approx > 0 is given, returns an approximation of the betweenness centrality of each vertex of the graph involving approx randomly chosen vertices.\n\nReferences\n\n[1] Brandes 2001 & Brandes 2008\n\n\n\n\n\n","category":"method"},{"location":"centrality/#Erdos.closeness_centrality-Tuple{AGraphOrDiGraph}","page":"Centrality Measures","title":"Erdos.closeness_centrality","text":"Calculates the closeness centrality of the graph g.\n\n\n\n\n\n","category":"method"},{"location":"centrality/#Erdos.degree_centrality-Tuple{AGraphOrDiGraph}","page":"Centrality Measures","title":"Erdos.degree_centrality","text":"Calculates the degree centrality of the graph g, with optional (default) normalization.\n\n\n\n\n\n","category":"method"},{"location":"centrality/#Erdos.in_degree_centrality-Tuple{AGraphOrDiGraph}","page":"Centrality Measures","title":"Erdos.in_degree_centrality","text":"Calculates the degree centrality of the graph g, with optional (default) normalization.\n\n\n\n\n\n","category":"method"},{"location":"centrality/#Erdos.out_degree_centrality-Tuple{AGraphOrDiGraph}","page":"Centrality Measures","title":"Erdos.out_degree_centrality","text":"Calculates the degree centrality of the graph g, with optional (default) normalization.\n\n\n\n\n\n","category":"method"},{"location":"centrality/#Erdos.katz_centrality","page":"Centrality Measures","title":"Erdos.katz_centrality","text":"Calculates the Katz centrality of the graph g.\n\n\n\n\n\n","category":"function"},{"location":"centrality/#Erdos.pagerank","page":"Centrality Measures","title":"Erdos.pagerank","text":"pagerank(g::ADiGraph, α=0.85, n=100, ϵ = 1.0e-6)\n\nCalculates the PageRank of the graph g. Can optionally specify a different damping factor (α), number of iterations (n), and convergence threshold (ϵ). If convergence is not reached within n iterations, an error will be returned.\n\n\n\n\n\n","category":"function"},{"location":"centrality/#Erdos.cores-Tuple{AGraph}","page":"Centrality Measures","title":"Erdos.cores","text":"cores(g)\n\nReturns a vector deg such that if deg[v]=k then the vertex v belongs to the k-core of g and not to the k+1-core.\n\nSee also kcore.\n\n\n\n\n\n","category":"method"},{"location":"centrality/#Erdos.kcore-Tuple{AGraph, Integer}","page":"Centrality Measures","title":"Erdos.kcore","text":"kcore(g, k) -> (gnew, vmap)\n\nReturns the k-core  of g along with a vertex map associating the mutated vertex indexes to the old ones (as in rem_vertices!).\n\nSee also cores\n\n\n\n\n\n","category":"method"},{"location":"core/#Basic-Interface","page":"Basic Interface","title":"Basic Interface","text":"","category":"section"},{"location":"core/","page":"Basic Interface","title":"Basic Interface","text":"Erdos.jl defines the following basic  functionalities:","category":"page"},{"location":"core/","page":"Basic Interface","title":"Basic Interface","text":"nv\nne\nadd_vertex!\nadd_vertices!\nrem_vertex!\npop_vertex!\nrem_vertices!\nhas_edge\nsrc\ndst\nedge\nadd_edge!\nunsafe_add_edge!\nrebuild!\nrem_edge!\ndegree\nin_degree\nout_degree\nneighbors\nin_neighbors\nout_neighbors\nall_neighbors","category":"page"},{"location":"core/#Erdos.nv","page":"Basic Interface","title":"Erdos.nv","text":"nv(g)\n\nThe number of vertices in g.\n\n\n\n\n\n","category":"function"},{"location":"core/#Erdos.ne","page":"Basic Interface","title":"Erdos.ne","text":"ne(g)\n\nThe number of edges in g.\n\nTime Complexity: O(1)\n\n\n\n\n\n","category":"function"},{"location":"core/#Erdos.add_vertex!","page":"Basic Interface","title":"Erdos.add_vertex!","text":"add_vertex!(g)\n\nAdd a new vertex to the graph g.\n\n\n\n\n\n","category":"function"},{"location":"core/#Erdos.add_vertices!","page":"Basic Interface","title":"Erdos.add_vertices!","text":"add_vertices!(g, n)\n\nAdd n new vertices to the graph g. Returns the final number of vertices.\n\n\n\n\n\n","category":"function"},{"location":"core/#Erdos.rem_vertex!","page":"Basic Interface","title":"Erdos.rem_vertex!","text":"rem_vertex!(g, v)\n\nRemove the vertex v from graph g. It will change the label of the last vertex of the old graph to v.\n\nSee also rem_vertices!.\n\n\n\n\n\n","category":"function"},{"location":"core/#Erdos.pop_vertex!","page":"Basic Interface","title":"Erdos.pop_vertex!","text":"pop_vertex!(g)\n\nRemove the last vertex of g. Equivalent to rem_vertex!(g, nv(g)).\n\n\n\n\n\n","category":"function"},{"location":"core/#Erdos.rem_vertices!","page":"Basic Interface","title":"Erdos.rem_vertices!","text":"rem_vertices!(g, vs)\nrem_vertices!(g, v1, v2, ....)\n\nRemove the vertices in vs from graph g.\n\nSome vertices of g may be reindexed during the removal. To keep track of the reindexing, a vertex map is returned, associating vertices with changed indexes to their old indexes.\n\n\n\n\n\n","category":"function"},{"location":"core/#Erdos.has_edge","page":"Basic Interface","title":"Erdos.has_edge","text":"has_edge(g, e)\nhas_edge(g, u, v)\n\nReturns true if the graph g has an edge e (from u to v).\n\n\n\n\n\n","category":"function"},{"location":"core/#Erdos.src","page":"Basic Interface","title":"Erdos.src","text":"src(e)\n\nReturns the source of an edge.\n\n\n\n\n\n","category":"function"},{"location":"core/#Erdos.dst","page":"Basic Interface","title":"Erdos.dst","text":"dst(e)\n\nReturns the destination of an edge.\n\n\n\n\n\n","category":"function"},{"location":"core/#Erdos.edge","page":"Basic Interface","title":"Erdos.edge","text":"edge(g, u, v)\n\nReturns an edge from 'u' to 'v'. The edge doesn't necessarily exists in g.\n\n\n\n\n\n","category":"function"},{"location":"core/#Erdos.add_edge!","page":"Basic Interface","title":"Erdos.add_edge!","text":"add_edge!(g, e) -> (ok, new_edge)\n\nAdd to g the edge e.\n\nadd_edge!(g, u, v) -> (ok, new_edge)\n\nAdd to g an edge from u to v.\n\nok=false if add fails (e.g. if vertices are not in the graph or the edge is already present) and true otherwise. new_edge is the descriptor of the new edge.\n\n\n\n\n\n","category":"function"},{"location":"core/#Erdos.unsafe_add_edge!","page":"Basic Interface","title":"Erdos.unsafe_add_edge!","text":"unsafe_add_edge!(g, u, v)\n\nPossibly faster and unsafer version of add_edge!, which doesn't guarantee some graph invariant properties.\n\nFor example, some graph types (e.g. Graph) assume sorted adjacency lists as members. In this case order is not preserved while inserting new edges, resulting in a faster construction of the graph. As a consequence though, some functions such has_edge(g, u, v) could give incorrect results.\n\nTo restore the correct behaviour, call rebuild!(g) after the last call to unsafe_add_edge!.\n\n\n\n\n\n","category":"function"},{"location":"core/#Erdos.rebuild!","page":"Basic Interface","title":"Erdos.rebuild!","text":"rebuild!(g)\n\nCheck and restore the structure of g, which could be corrupted by the use of unsafe functions (e. g. unsafe_add_edge!)\n\n\n\n\n\n","category":"function"},{"location":"core/#Erdos.rem_edge!","page":"Basic Interface","title":"Erdos.rem_edge!","text":"rem_edge!(g, e)\n\nRemove the edge e.\n\nrem_edge!(g, u, v)\n\nRemove the edge from u to v.\n\nReturns false if edge removal fails (e.g., if the edge does not exist) and true otherwise.\n\n\n\n\n\n","category":"function"},{"location":"core/#Erdos.degree","page":"Basic Interface","title":"Erdos.degree","text":"degree(g, v)\n\nReturn the number of edges  from the vertex v.\n\n\n\n\n\n","category":"function"},{"location":"core/#Erdos.in_degree","page":"Basic Interface","title":"Erdos.in_degree","text":"in_degree(g, v)\n\nReturns the number of edges which start at vertex v.\n\n\n\n\n\n","category":"function"},{"location":"core/#Erdos.out_degree","page":"Basic Interface","title":"Erdos.out_degree","text":"out_degree(g, v)\n\nReturns the number of edges which end at vertex v.\n\n\n\n\n\n","category":"function"},{"location":"core/#Erdos.neighbors","page":"Basic Interface","title":"Erdos.neighbors","text":"neighbors(g, v)\n\nReturns a list of all neighbors from vertex v in g.\n\nFor directed graph, this is equivalent to out_neighbors(g, v).\n\nNOTE: it may return a reference, not a copy. Do not modify result.\n\n\n\n\n\n","category":"function"},{"location":"core/#Erdos.in_neighbors","page":"Basic Interface","title":"Erdos.in_neighbors","text":"in_neighbors(g, v)\n\nReturns an iterable to all neighbors connected to vertex v by an incoming edge.\n\nNOTE: it may return a reference, not a copy. Do not modify result.\n\n\n\n\n\n","category":"function"},{"location":"core/#Erdos.out_neighbors","page":"Basic Interface","title":"Erdos.out_neighbors","text":"out_neighbors(g::AGraphOrDiGraph, v)\n\nReturns an iterable to all neighbors connected to vertex v by an outgoing edge.\n\nNOTE: it may return a reference, not a copy. Do not modify result.\n\n\n\n\n\n","category":"function"},{"location":"core/#Erdos.all_neighbors","page":"Basic Interface","title":"Erdos.all_neighbors","text":"all_neighbors(g, v)\n\nIterates over all distinct in/out neighbors of vertex v in g.\n\n\n\n\n\n","category":"function"},{"location":"core/","page":"Basic Interface","title":"Basic Interface","text":"edges\nin_edges\nout_edges\nall_edges\nswap_vertices!\nhas_vertex\nis_directed\nreverse\nreverse!\nadjacency_list\nclean_vertex!","category":"page"},{"location":"core/#Erdos.edges","page":"Basic Interface","title":"Erdos.edges","text":"edges(g, v)\n\nReturns an iterator to the edges in g coming from vertex v. v == src(e) for each returned edge e.\n\nIt is equivalent to out_edges.\n\nFor digraphs, use all_edges to iterate over both in and out edges.\n\n\n\n\n\n","category":"function"},{"location":"core/#Erdos.in_edges","page":"Basic Interface","title":"Erdos.in_edges","text":"in_edges(g, v)\n\nReturns an iterator to the edges in g going to vertex v. v == dst(e) for each returned edge e.\n\n\n\n\n\n","category":"function"},{"location":"core/#Erdos.out_edges","page":"Basic Interface","title":"Erdos.out_edges","text":"out_edges(g, v)\n\nReturns an iterator to the edges in g coming from vertex v. v == src(e) for each returned edge e.\n\n\n\n\n\n","category":"function"},{"location":"core/#Erdos.all_edges","page":"Basic Interface","title":"Erdos.all_edges","text":"all_edges(g, v)\n\nIterates over all in and out edges of vertex v in g.\n\n\n\n\n\n","category":"function"},{"location":"core/#Erdos.swap_vertices!","page":"Basic Interface","title":"Erdos.swap_vertices!","text":"swap_vertices!(g, u, v)\n\nSwap the labels of vertices u and v. In the new graph all old neighbors of vertex u will be neighbors of v and viceversa.\n\n\n\n\n\n","category":"function"},{"location":"core/#Erdos.has_vertex","page":"Basic Interface","title":"Erdos.has_vertex","text":"has_vertex(g, v)\n\nReturn true if v is a vertex of g.\n\n\n\n\n\n","category":"function"},{"location":"core/#Erdos.is_directed","page":"Basic Interface","title":"Erdos.is_directed","text":"is_directed(g)\n\nCheck if g a graph with directed edges.\n\n\n\n\n\n","category":"function"},{"location":"core/#Base.reverse","page":"Basic Interface","title":"Base.reverse","text":"reverse(e)\n\nReturns an edge with swapped src(e) and dst(e).\n\n\n\n\n\nreverse(g::ADiGraph)\n\nProduces a graph where all edges are reversed from the original.\n\n\n\n\n\n","category":"function"},{"location":"core/#Base.reverse!","page":"Basic Interface","title":"Base.reverse!","text":"reverse!(g::DiGraph)\n\nIn-place reverse (modifies the original graph).\n\n\n\n\n\n","category":"function"},{"location":"core/#Erdos.adjacency_list","page":"Basic Interface","title":"Erdos.adjacency_list","text":"adjacency_list(g::AGraph)\nadjacency_list(g::ADiGraph, dir=:out)\n\nReturns the adjacency list a of a graph (a vector of vector of ints). The i-th element of the adjacency list is a vector containing the neighbors of i in g.\n\nFor directed graphs a second optional argument can be specified (:out or :in). The neighbors in the returned adjacency list are considered accordingly as those related through outgoing or incoming edges.\n\nThe elements of  a[i] have the same order as in the iterator (out_/in_)neighbors(g,i).\n\nAttention: For some graph types it returns a reference, not a copy, therefore the returned object should not be modified.\n\n\n\n\n\n","category":"function"},{"location":"core/#Erdos.clean_vertex!","page":"Basic Interface","title":"Erdos.clean_vertex!","text":"clean_vertex!(g, v)\n\nRemove all incident edges on vertex v in g.\n\n\n\n\n\n","category":"function"},{"location":"core/","page":"Basic Interface","title":"Basic Interface","text":"density\nvertices\nhas_self_loops\nnum_self_loops\nis_graphical\ngraph\ndigraph\nedgetype\nvertextype\ngraphtype\ndigraphtype","category":"page"},{"location":"core/#Erdos.density","page":"Basic Interface","title":"Erdos.density","text":"density(g)\n\nDensity is defined as the ratio of the number of actual edges to the number of possible edges. This is v v-1 for directed graphs and (v v-1)  2 for undirected graphs.\n\n\n\n\n\n","category":"function"},{"location":"core/#Erdos.vertices","page":"Basic Interface","title":"Erdos.vertices","text":"vertices(g)\n\nReturns an iterator to the vertices of a graph (i.e. 1:nv(g))\n\n\n\n\n\n","category":"function"},{"location":"core/#Erdos.has_self_loops","page":"Basic Interface","title":"Erdos.has_self_loops","text":"has_self_loops(g)\n\nReturns true if g has any self loops.\n\n\n\n\n\n","category":"function"},{"location":"core/#Erdos.num_self_loops","page":"Basic Interface","title":"Erdos.num_self_loops","text":"num_self_loops(g)\n\nReturns the number of self loops in g.\n\n\n\n\n\n","category":"function"},{"location":"core/#Erdos.is_graphical","page":"Basic Interface","title":"Erdos.is_graphical","text":"is_graphical(degs::Vector{Int})\n\nCheck whether the degree sequence degs is graphical, according to Erdös-Gallai condition.\n\nTime complexity: O(length(degs)^2)\n\n\n\n\n\n","category":"function"},{"location":"core/#Erdos.graph","page":"Basic Interface","title":"Erdos.graph","text":"graph{G<:AGraph}(n, edgelist::Vector{Tuple{Int,Int}},\n    G = Graph)\n\nBuild a graph with n vertices, of type G, and given edgelist.\n\n\n\n\n\ngraph(s::Symbol, G = Graph)\n\nCreates a notorious graph s of type G. Admissible values for s are:\n\ns graph type\n:bull A bull graph.\n:chvatal A Chvátal graph.\n:cubical A Platonic cubical graph.\n:desargues A Desarguesgraph.\n:diamond A diamond graph.\n:dodecahedral A Platonic dodecahedral  graph.\n:frucht A Frucht graph.\n:heawood A Heawood graph.\n:house A graph mimicing the classic outline of a house.\n:housex A house graph, with two edges crossing the bottom square.\n:icosahedral A Platonic icosahedral   graph.\n:krackhardtkite A Krackhardt-Kite social network  graph.\n:moebiuskantor A Möbius-Kantor graph.\n:octahedral A Platonic octahedral graph.\n:pappus A Pappus graph.\n:petersen A Petersen graph.\n:sedgewickmaze A simple maze graph used in Sedgewick's Algorithms in C++: Graph  Algorithms (3rd ed.)\n:tetrahedral A Platonic tetrahedral  graph.\n:truncatedcube A skeleton of the truncated cube graph.\n:truncatedtetrahedron A skeleton of the truncated tetrahedron  graph.\n:tutte A Tutte graph.\n\nA collection of real world graphs is available through the readgraph function.\n\n\n\n\n\n","category":"function"},{"location":"core/#Erdos.digraph","page":"Basic Interface","title":"Erdos.digraph","text":"digraph{G<:AGraph}(n, edgelist::Vector{Tuple{Int,Int}},\n    G = Graph)\n\nBuild a digraph with n vertices, type G, and given edgelist.\n\n\n\n\n\ndigraph(s::Symbol, G = DiGraph)\n\nCreates a notorious digraph s of type G. Admissible values for s are:\n\ns graph type\n:truncatedtetrahedron A skeleton of the truncated tetrahedron digraph.\n\n\n\n\n\n","category":"function"},{"location":"core/#Erdos.edgetype","page":"Basic Interface","title":"Erdos.edgetype","text":"edgetype(g)\nedgetype(G)\n\nReturns the type of edges of graph g (or graph type G), i. e. the element type returned of the iterator edges(g).\n\n\n\n\n\n","category":"function"},{"location":"core/#Erdos.vertextype","page":"Basic Interface","title":"Erdos.vertextype","text":"vertextype(g)\nvertextype(G)\n\nReturns the integer type of vertices of graph g (or graph type G).\n\n\n\n\n\n","category":"function"},{"location":"core/#Erdos.graphtype","page":"Basic Interface","title":"Erdos.graphtype","text":"graphtype{G<:AGraphOrDiGraph}(::Type{G})\n\nThe graph type corresponding to G. If G<:AGraph returns G, if G<:ADiGraph returns a type H<:AGraph.\n\n\n\n\n\n","category":"function"},{"location":"core/#Erdos.digraphtype","page":"Basic Interface","title":"Erdos.digraphtype","text":"digraphtype{G<:AGraphOrDiGraph}(::Type{G})\n\nThe digraph type corresponding to G. If G<:ADiGraph returns G, if G<:AGraph returns a type H<:ADiGraph.\n\n\n\n\n\n","category":"function"},{"location":"randomgraphs/#Random-Graphs-Generators","page":"Random Graphs","title":"Random Graphs Generators","text":"","category":"section"},{"location":"randomgraphs/","page":"Random Graphs","title":"Random Graphs","text":"Erdos.jl implements some common random graph generators:","category":"page"},{"location":"randomgraphs/","page":"Random Graphs","title":"Random Graphs","text":"Modules = [Erdos]\nPages   = [ \"generators/randgraphs.jl\"]\nPrivate = false","category":"page"},{"location":"randomgraphs/#Erdos.barabasi_albert!-Tuple{AGraphOrDiGraph, Int64, Int64}","page":"Random Graphs","title":"Erdos.barabasi_albert!","text":"barabasi_albert!(g, n::Int, k::Int; seed::Int = -1)\n\nGrows the graph g according to Barabási–Albert process into a graph with n vertices. At each step a new vertex is attached by preferential attachment to k different vertices already present in the graph.\n\nSee also barabasi_albert.\n\n\n\n\n\n","category":"method"},{"location":"randomgraphs/#Erdos.barabasi_albert-Union{Tuple{Int64, Int64}, Tuple{G}, Tuple{Int64, Int64, Type{G}}} where G<:AGraphOrDiGraph","page":"Random Graphs","title":"Erdos.barabasi_albert","text":"barabasi_albert(n, k, G=Graph; seed=-1)\nbarabasi_albert(n, n0, k, G=Graph; seed=-1)\n\nCreates a random graph of type G with n vertices according to Barabási–Albert model. It is grown by adding new vertices to an initial graph with n0 vertices (n0=k if not specified). Each new vertex is attached with k edges to k different vertices already present in the system by preferential attachment. The initial graph is empty by default.\n\nUndirected graphs are created by default. Directed graphs can be created passing a directed graph type as last argument (e.g. DiGraph).\n\nSee also barabasi_albert! for growing a given graph.\n\n\n\n\n\n","category":"method"},{"location":"randomgraphs/#Erdos.erdos_renyi-Union{Tuple{G}, Tuple{Int64, Real}, Tuple{Int64, Real, Type{G}}} where G<:AGraphOrDiGraph","page":"Random Graphs","title":"Erdos.erdos_renyi","text":"erdos_renyi(n::Int, p::Real, G=Graph; seed=-1)\nerdos_renyi(n::Int, m::Int, G=Graph; seed=-1)\n\nCreates an Erdős–Rényi random graph of type G with n vertices. Edges are added between pairs of vertices with probability p in the first method. In the second method m edges are randomly chosen insted.\n\nUndirected graphs are created by default. Directed graphs can be created passing a directed graph type as last argument (e.g. DiGraph)\n\nNote also that Erdős–Rényi graphs may be generated quickly using erdos_renyi(n, ne) or the  Graph(nv, ne) constructor, which randomly select ne edges among all the potential edges.\n\n\n\n\n\n","category":"method"},{"location":"randomgraphs/#Erdos.random_configuration_model-Union{Tuple{G}, Tuple{Int64, Vector{Int64}}, Tuple{Int64, Vector{Int64}, Type{G}}} where G<:AGraph","page":"Random Graphs","title":"Erdos.random_configuration_model","text":"random_configuration_model(n::Int, k::Vector{Int}, G=Graph; seed=-1, check_graphical=false)\n\nCreates a random undirected graph according to the configuraton model. It contains n vertices, the vertex i having degree k[i].\n\nDefining c = mean(k), it allocates an array of nc Ints, and takes approximately nc^2 time.\n\nIf check_graphical=true makes sure that k is a graphical sequence (see is_graphical).\n\nG is the resulting graph type.\n\n\n\n\n\n","category":"method"},{"location":"randomgraphs/#Erdos.random_regular_digraph-Union{Tuple{Int64, Int64}, Tuple{G}, Tuple{Int64, Int64, Type{G}}} where G<:ADiGraph","page":"Random Graphs","title":"Erdos.random_regular_digraph","text":"random_regular_digraph(n::Int, k::Int; dir::Symbol=:out, seed=-1)\n\nCreates a random directed regular graph with n vertices, each with degree k. The degree (in or out) can be specified using dir=:in or dir=:out. The default is dir=:out.\n\nFor directed graphs, allocates an n \times n sparse matrix of boolean as an adjacency matrix and uses that to generate the directed graph.\n\n\n\n\n\n","category":"method"},{"location":"randomgraphs/#Erdos.random_regular_graph-Union{Tuple{Int64, Int64}, Tuple{G}, Tuple{Int64, Int64, Type{G}}} where G<:AGraph","page":"Random Graphs","title":"Erdos.random_regular_graph","text":"random_regular_graph(n::Int, k::Int, G=Graph; seed=-1)\n\nCreates a random undirected regular graph with n vertices, each with degree k.\n\nFor undirected graphs, allocates an array of nk Ints, and takes approximately nk^2 time. For k  n2, generates a graph of degree n-k-1 and returns its complement.\n\nG is the resulting graph type.\n\n\n\n\n\n","category":"method"},{"location":"randomgraphs/#Erdos.static_fitness_model-Union{Tuple{G}, Tuple{T}, Tuple{Int64, Vector{T}}, Tuple{Int64, Vector{T}, Type{G}}} where {T<:Real, G<:AGraph}","page":"Random Graphs","title":"Erdos.static_fitness_model","text":"static_fitness_model(m, fitness, G=Graph; seed=-1)\nstatic_fitness_model(m, fitness_out, fitness_in, G=DiGraph; seed=-1)\n\nGenerates a random graph with length(fitness) nodes and m edges, in which the probability of the existence of edge (i, j) is proportional to fitness[i]*fitness[j]. Time complexity is O(|V| + |E| log |E|).\n\nIn and out fitness have to be supplied for generating directed graphs.\n\nReference:\n\nGoh K-I, Kahng B, Kim D: Universal behaviour of load distribution\n\nin scale-free networks. Phys Rev Lett 87(27):278701, 2001.\n\n\n\n\n\n","category":"method"},{"location":"randomgraphs/#Erdos.static_scale_free-Union{Tuple{Int64, Int64, Float64}, Tuple{G}, Tuple{Int64, Int64, Float64, Type{G}}} where G<:AGraph","page":"Random Graphs","title":"Erdos.static_scale_free","text":"function static_scale_free(n, m, α, G=Graph;\n        seed=-1, finite_size_correction=true)\n\nGenerates a random graph with n vertices, m edges and expected power-law degree distribution with exponent α. finite_size_correction determines whether to use the finite size correction proposed by Cho et al. This generator calls internally the static_fitness_model function. Time complexity is O(|V| + |E| log |E|).\n\nfunction static_scale_free(n, m, α_out, α_in, G=DiGraph;\n        seed=-1, finite_size_correction=true)\n\nGenerates a random digraph\n\nReferences:\n\nGoh K-I, Kahng B, Kim D: Universal behaviour of load distribution in scale-free networks. Phys Rev Lett 87(27):278701, 2001.\nChung F and Lu L: Connected components in a random graph with given degree sequences. Annals of Combinatorics 6, 125-145, 2002.\nCho YS, Kim JS, Park J, Kahng B, Kim D: Percolation transitions in scale-free networks under the Achlioptas process. Phys Rev Lett 103:135702, 2009.\n\n\n\n\n\n","category":"method"},{"location":"randomgraphs/#Erdos.stochastic_block_model-Union{Tuple{G}, Tuple{T}, Tuple{Matrix{T}, Vector{Int64}}, Tuple{Matrix{T}, Vector{Int64}, Type{G}}} where {T<:Real, G<:AGraph}","page":"Random Graphs","title":"Erdos.stochastic_block_model","text":"stochastic_block_model(c::Matrix{Float64}, n::Vector{Int}; seed::Int = -1)\nstochastic_block_model(cin::Float64, coff::Float64, n::Vector{Int}; seed::Int = -1)\n\nReturns a Graph generated according to the Stochastic Block Model (SBM).\n\nc[a,b] : Mean number of neighbors of a vertex in block a belonging to block b.            Only the upper triangular part is considered, since the lower traingular is            determined by cba = cab * nanb. n[a] : Number of vertices in block a\n\nThe second form samples from a SBM with c[a,a]=cin, and c[a,b]=coff.\n\nFor a dynamic version of the SBM see the StochasticBlockModel type and related functions.\n\n\n\n\n\n","category":"method"},{"location":"randomgraphs/#Erdos.watts_strogatz-Union{Tuple{G}, Tuple{Int64, Int64, Real}, Tuple{Int64, Int64, Real, Type{G}}} where G<:AGraphOrDiGraph","page":"Random Graphs","title":"Erdos.watts_strogatz","text":"watts_strogatz(n, k, β, G=Graph; seed=-1)\n\nCreates a Watts-Strogatz small model random graph with n vertices, each with degree k. Edges are randomized per the model based on probability β.\n\nUndirected graphs are created by default. Directed graphs can be created passing a directed graph type as last argument (e.g. DiGraph).\n\n\n\n\n\n","category":"method"},{"location":"community/#Community-Structures","page":"Community Structures","title":"Community Structures","text":"","category":"section"},{"location":"community/","page":"Community Structures","title":"Community Structures","text":"Erdos.jl contains many algorithm to detect and analyze community structures in graphs.","category":"page"},{"location":"community/","page":"Community Structures","title":"Community Structures","text":"Modules = [Erdos]\nPages   = [\"community/clustering.jl\",\n            \"community/core-periphery.jl\",\n            \"community/modularity.jl\",\n            \"community/cliques.jl\",\n            \"community/detection.jl\"]\nPrivate = false","category":"page"},{"location":"community/#Erdos.global_clustering_coefficient-Tuple{AGraphOrDiGraph}","page":"Community Structures","title":"Erdos.global_clustering_coefficient","text":"global_clustering_coefficient(g)\n\nComputes the global clustering coefficient.\n\n\n\n\n\n","category":"method"},{"location":"community/#Erdos.local_clustering","page":"Community Structures","title":"Erdos.local_clustering","text":"local_clustering(g, vlist = vertices(g))\n\nReturns two vectors, respectively containing  the first and second result of local_clustering_coefficients(g, v) for each v in vlist.\n\n\n\n\n\n","category":"function"},{"location":"community/#Erdos.local_clustering-Tuple{AGraphOrDiGraph, Integer}","page":"Community Structures","title":"Erdos.local_clustering","text":"local_clustering(g, v)\n\nReturns a tuple (a,b), where a is the number of triangles in the neighborhood of v and b is the maximum number of possible triangles. It is related to the local clustering coefficient  by r=a/b.\n\n\n\n\n\n","category":"method"},{"location":"community/#Erdos.local_clustering_coefficient","page":"Community Structures","title":"Erdos.local_clustering_coefficient","text":"local_clustering_coefficient(g, vlist = vertices(g))\n\nReturns a vector containing  the local clustering coefficients for vertices vlist.\n\n\n\n\n\n","category":"function"},{"location":"community/#Erdos.local_clustering_coefficient-Tuple{AGraphOrDiGraph, Integer}","page":"Community Structures","title":"Erdos.local_clustering_coefficient","text":"local_clustering_coefficient(g, v)\n\nComputes the local clustering coefficient for node v.\n\n\n\n\n\n","category":"method"},{"location":"community/#Erdos.triangles","page":"Community Structures","title":"Erdos.triangles","text":"triangles(g, vlist = vertices(g))\n\nReturns a vector containing the number of triangles for vertices vlist.\n\n\n\n\n\n","category":"function"},{"location":"community/#Erdos.triangles-Tuple{AGraphOrDiGraph, Integer}","page":"Community Structures","title":"Erdos.triangles","text":"triangles(g, v)\n\nReturns the number of triangles in the neighborhood for node v.\n\n\n\n\n\n","category":"method"},{"location":"community/#Erdos.core_periphery_deg-Tuple{AGraph}","page":"Community Structures","title":"Erdos.core_periphery_deg","text":"core_periphery_deg(g)\n\nA simple degree-based core-periphery detection algorithm (see Lip). Returns the vertex assignments (1 for core and 2 for periphery).\n\n\n\n\n\n","category":"method"},{"location":"community/#Erdos.modularity-Tuple{AGraph, Any}","page":"Community Structures","title":"Erdos.modularity","text":"modularity(g, c)\n\nComputes Newman's modularity Q for graph g given the partitioning c.\n\n\n\n\n\n","category":"method"},{"location":"community/#Erdos.maximal_cliques-Tuple{AGraph}","page":"Community Structures","title":"Erdos.maximal_cliques","text":"Finds all maximal cliques of an undirected graph.\n\njulia> using Erdos\njulia> g = Graph(3)\njulia> add_edge!(g, 1, 2)\njulia> add_edge!(g, 2, 3)\njulia> maximal_cliques(g)\n2-element Array{Array{Int64,N},1}:\n [2,3]\n [2,1]\n\n\n\n\n\n","category":"method"},{"location":"community/#Erdos.community_detection_bethe","page":"Community Structures","title":"Erdos.community_detection_bethe","text":"community_detection_bethe(g::AGraph, k=-1; kmax=15)\n\nCommunity detection using the spectral properties of the Bethe Hessian matrix associated to g (see Saade et al.). k is the number of communities to detect. If omitted or if k < 1 the optimal number of communities will be automatically selected. In this case the maximum number of detectable communities is given by kmax. Returns a vector containing the vertex assignments.\n\n\n\n\n\n","category":"function"},{"location":"community/#Erdos.community_detection_nback-Tuple{AGraph, Integer}","page":"Community Structures","title":"Erdos.community_detection_nback","text":"community_detection_nback(g, k)\n\nCommunity detection using the spectral properties of the non-backtracking matrix of graph g (see Krzakala et al.). k is the number of communities to detect.\n\nSee also community_detection_bethe for a related community ddetection algorithm.\n\nReturns a vector with the vertex assignments in the communities.\n\n\n\n\n\n","category":"method"},{"location":"community/#Erdos.label_propagation-Tuple{AGraphOrDiGraph}","page":"Community Structures","title":"Erdos.label_propagation","text":"label_propagation(g; maxiter=1000)\n\nCommunity detection using the label propagation algorithm (see Raghavan et al.). g is the input Graph, maxiter is the  maximum number of iterations. Returns a vertex assignments and the convergence history\n\n\n\n\n\n","category":"method"},{"location":"community/#Erdos.nonbacktrack_embedding-Tuple{AGraph, Int64}","page":"Community Structures","title":"Erdos.nonbacktrack_embedding","text":"nonbacktrack_embedding(g::AGraph, k::Int)\n\nSpectral embedding of the non-backtracking matrix of g (see Krzakala et al.).\n\n`g`: imput Graph\n`k`: number of dimensions in which to embed\n\nReturns  a matrix ϕ where ϕ[:,i] are the coordinates for vertex i.\n\nNote:  does not explicitly construct the nonbacktracking_matrix. See nonbacktracking_matrix for details.\n\n\n\n\n\n","category":"method"},{"location":"traversals/#Path-and-Traversal","page":"Traversals","title":"Path and Traversal","text":"","category":"section"},{"location":"traversals/","page":"Traversals","title":"Traversals","text":"Erdos.jl provides several traversal and shortest-path algorithms, along with various utility functions. Where appropriate, edge distances may be passed in as a matrix of real number values.","category":"page"},{"location":"traversals/","page":"Traversals","title":"Traversals","text":"Edge distances for most traversals may be passed in as a sparse or dense matrix of  values, indexed by [src,dst] vertices. That is, distmx[2,4] = 2.5 assigns the distance 2.5 to the (directed) edge connecting vertex 2 and vertex 4. Note that also for undirected graphs distmx[4,2] has to be set.","category":"page"},{"location":"traversals/","page":"Traversals","title":"Traversals","text":"Any graph traversal  will traverse an edge only if it is present in the graph. When a distance matrix is passed in,","category":"page"},{"location":"traversals/","page":"Traversals","title":"Traversals","text":"distance values for undefined edges will be ignored, and\nany unassigned values (in sparse distance matrices), for edges that are present in the graph, will be assumed to take the default value of 1.0.\nany zero values (in sparse/dense distance matrices), for edges that are present in the graph, will instead have an implicit edge cost of 1.0.","category":"page"},{"location":"traversals/#Graph-Traversal","page":"Traversals","title":"Graph Traversal","text":"","category":"section"},{"location":"traversals/","page":"Traversals","title":"Traversals","text":"Graph traversal refers to a process that traverses vertices of a graph following certain order (starting from user-input sources). This package implements three traversal schemes:","category":"page"},{"location":"traversals/","page":"Traversals","title":"Traversals","text":"BreadthFirst,\nDepthFirst, and\nMaximumAdjacency.","category":"page"},{"location":"traversals/","page":"Traversals","title":"Traversals","text":"<!–- TODO separate the 3 in different paragraphs? –>","category":"page"},{"location":"traversals/","page":"Traversals","title":"Traversals","text":"Modules = [Erdos]\nOrder = [:type, :function]\nPages   = [ \"traversals/bfs.jl\",\n            \"traversals/dfs.jl\",\n            \"traversals/maxadjvisit.jl\",\n            \"traversals/graphvisit.jl\"\n          ]\n\nPrivate = false","category":"page"},{"location":"traversals/#Erdos.bfs_tree-Tuple{AGraphOrDiGraph, Integer}","page":"Traversals","title":"Erdos.bfs_tree","text":"bfs_tree(g, s[; dir=:out])\n\nProvide a breadth-first traversal of the graph g starting with source vertex s, and return a directed acyclic graph of vertices in the order they were discovered. If dir is specified, use the corresponding edge direction (:in and :out are acceptable values).\n\n\n\n\n\n","category":"method"},{"location":"traversals/#Erdos.gdistances!-Tuple{AGraphOrDiGraph, Any, Any}","page":"Traversals","title":"Erdos.gdistances!","text":"gdistances!(g, source, dists; sort_alg=QuickSort)\n\nFill dists with the geodesic distances of vertices in g from source vertex (or collection of vertices) source. dists should be a vector of length nv(g)  filled with typemax(T). Return dists.\n\nFor vertices in disconnected components the default distance is typemax(T).\n\nAn optional sorting algorithm may be specified (see Performance section).\n\nPerformance\n\ngdistances uses QuickSort internally for its default sorting algorithm, since it performs the best of the algorithms built into Julia Base. However, passing a RadixSort (available via SortingAlgorithms.jl) will provide significant performance improvements on larger graphs.\n\n\n\n\n\n","category":"method"},{"location":"traversals/#Erdos.gdistances-Tuple{AGraphOrDiGraph, Any}","page":"Traversals","title":"Erdos.gdistances","text":"gdistances(g, source; sort_alg=QuickSort)\n\nReturn a vector filled with the geodesic distances of vertices in  g from source. If source is a collection of vertices each element should be unique. For vertices in disconnected components the default distance is typemax(T).\n\nAn optional sorting algorithm may be specified (see Performance section).\n\nPerformance\n\ngdistances uses QuickSort internally for its default sorting algorithm, since it performs the best of the algorithms built into Julia Base. However, passing a RadixSort (available via SortingAlgorithms.jl) will provide significant performance improvements on larger graphs.\n\n\n\n\n\n","category":"method"},{"location":"traversals/#Erdos.has_path-Tuple{AGraphOrDiGraph, Integer, Integer}","page":"Traversals","title":"Erdos.has_path","text":"has_path(g::AbstractGraph, u, v; exclude_vertices=Vector())\n\nReturn true if there is a path from u to v in g (while avoiding vertices in exclude_vertices) or u == v. Return false if there is no such path or if u or v is in excluded_vertices. \n\n\n\n\n\n","category":"method"},{"location":"traversals/#Erdos.dfs_tree-Tuple{AGraphOrDiGraph, Integer}","page":"Traversals","title":"Erdos.dfs_tree","text":"dfs_tree(g, s)\n\nReturn an ordered vector of vertices representing a directed acylic graph based on depth-first traversal of the graph g starting with source vertex s.\n\n\n\n\n\n","category":"method"},{"location":"traversals/#Erdos.has_cycles-Tuple{AGraph}","page":"Traversals","title":"Erdos.has_cycles","text":"has_cycles(g)\n\nReturn true if graph g contains a cycle.\n\nImplementation Notes\n\nUses DFS.\n\n\n\n\n\n","category":"method"},{"location":"traversals/#Erdos.topological_sort_by_dfs-Tuple{ADiGraph}","page":"Traversals","title":"Erdos.topological_sort_by_dfs","text":"topological_sort_by_dfs(g)\n\nReturn a toplogical sort of a directed graph g as a vector of vertices in topological order.\n\n\n\n\n\n","category":"method"},{"location":"traversals/#Erdos.maximum_adjacency_visit-Union{Tuple{T}, Tuple{AGraphOrDiGraph, AEdgeMap{T}}, Tuple{AGraphOrDiGraph, AEdgeMap{T}, Bool}, Tuple{AGraphOrDiGraph, AEdgeMap{T}, Bool, IO}} where T<:Real","page":"Traversals","title":"Erdos.maximum_adjacency_visit","text":"maximum_adjacency_visit(g[, distmx][, log][, io])\n\nReturn the vertices in g traversed by maximum adjacency search. An optional distmx matrix may be specified; if omitted, edge distances are assumed to be 1. If log (default false) is true, visitor events will be printed to io, which defaults to STDOUT; otherwise, no event information will be displayed.\n\n\n\n\n\n","category":"method"},{"location":"traversals/#Erdos.minimum_cut-Union{Tuple{AGraphOrDiGraph}, Tuple{T}, Tuple{AGraphOrDiGraph, AEdgeMap{T}}} where T<:Real","page":"Traversals","title":"Erdos.minimum_cut","text":"minimum_cut(g, distmx=weights(g))\n\nReturn a tuple (parity, bestcut), where parity is a vector of integer values that determines the partition in g (1 or 2) and bestcut is the weight of the cut that makes this partition. An optional distmx matrix may be specified; if omitted, edge distances are assumed to be 1.\n\n\n\n\n\n","category":"method"},{"location":"traversals/#Random-walks","page":"Traversals","title":"Random walks","text":"","category":"section"},{"location":"traversals/","page":"Traversals","title":"Traversals","text":"Erdos includes uniform random walks and self avoiding walks:","category":"page"},{"location":"traversals/","page":"Traversals","title":"Traversals","text":"Modules = [Erdos]\nOrder = [:type, :function]\nPages   = [ \"traversals/randomwalks.jl\"]\nPrivate = false","category":"page"},{"location":"traversals/#Erdos.nonbacktracking_randomwalk-Tuple{AGraph, Integer, Integer}","page":"Traversals","title":"Erdos.nonbacktracking_randomwalk","text":"nonbacktracking_randomwalk(g, s, niter)\n\nPerform a non-backtracking random walk on directed graph g starting at vertex s and continuing for a maximum of niter steps. Return a vector of vertices visited in order.\n\n\n\n\n\n","category":"method"},{"location":"traversals/#Erdos.randomwalk-Tuple{AGraphOrDiGraph, Integer, Integer}","page":"Traversals","title":"Erdos.randomwalk","text":"randomwalk(g, s, niter)\n\nPerform a random walk on graph g starting at vertex s and continuing for a maximum of niter steps. Return a vector of vertices visited in order.\n\n\n\n\n\n","category":"method"},{"location":"traversals/#Erdos.self_avoiding_randomwalk-Tuple{AGraphOrDiGraph, Integer, Integer}","page":"Traversals","title":"Erdos.self_avoiding_randomwalk","text":"self_avoiding_randomwalk(g, s, niter)\n\nPerform a self-avoiding walk on graph g starting at vertex s and continuing for a maximum of niter steps. Return a vector of vertices visited in order.\n\n\n\n\n\n","category":"method"},{"location":"traversals/#Connectivity-/-Bipartiteness","page":"Traversals","title":"Connectivity / Bipartiteness","text":"","category":"section"},{"location":"traversals/","page":"Traversals","title":"Traversals","text":"Graph connectivity functions are defined on both undirected and directed graphs:","category":"page"},{"location":"traversals/","page":"Traversals","title":"Traversals","text":"Modules = [Erdos]\nOrder = [:type, :function]\nPages   = [ \"traversals/connectivity.jl\"]\nPrivate = false","category":"page"},{"location":"traversals/#Erdos.attracting_components-Tuple{ADiGraph}","page":"Traversals","title":"Erdos.attracting_components","text":"attracting_components(g)\n\nReturn a vector of vectors of integers representing lists of attracting components in the directed graph g.\n\nThe attracting components are a subset of the strongly connected components in which the components do not have any leaving edges.\n\nExamples\n\njulia> g = SimpleDiGraph([0 1 0 0 0; 0 0 1 0 0; 1 0 0 1 0; 0 0 0 0 1; 0 0 0 1 0])\n{5, 6} directed simple Int64 graph\n\njulia> strongly_connected_components(g)\n2-element Array{Array{Int64,1},1}:\n [4, 5]\n [1, 2, 3]\n\njulia> attracting_components(g)\n1-element Array{Array{Int64,1},1}:\n [4, 5]\n\n\n\n\n\n","category":"method"},{"location":"traversals/#Erdos.condensation-Union{Tuple{G}, Tuple{T}, Tuple{G, Array{Vector{T}, 1}}} where {T<:Integer, G<:ADiGraph}","page":"Traversals","title":"Erdos.condensation","text":"condensation(g[, scc])\n\nReturn the condensation graph of the strongly connected components scc in the directed graph g. If scc is missing, generate the strongly connected components first.\n\nExamples\n\njulia> g = DiGraph([0 1 0 0 0; 0 0 1 0 0; 1 0 0 1 0; 0 0 0 0 1; 0 0 0 1 0])\n{5, 6} directed simple Int64 graph\n\njulia> strongly_connected_components(g)\n2-element Array{Array{Int64,1},1}:\n [4, 5]\n [1, 2, 3]\n\njulia> foreach(println, edges(condensation(g)))\nEdge 2 => 1\n\n\n\n\n\n","category":"method"},{"location":"traversals/#Erdos.connected_components-Tuple{AGraphOrDiGraph}","page":"Traversals","title":"Erdos.connected_components","text":"connected_components(g)\n\nReturn the connected components of an undirected graph g as a vector of components, with each element a vector of vertices belonging to the component.\n\nFor directed graphs, see strongly_connected_components and weakly_connected_components.\n\nExamples\n\njulia> g = Graph([0 1 0; 1 0 1; 0 1 0]);\n\njulia> connected_components(g)\n1-element Array{Array{Int64,1},1}:\n [1, 2, 3]\n\njulia> g = Graph([0 1 0 0 0; 1 0 1 0 0; 0 1 0 0 0; 0 0 0 0 1; 0 0 0 1 0]);\n\njulia> connected_components(g)\n2-element Array{Array{Int64,1},1}:\n [1, 2, 3]\n [4, 5]\n\n\n\n\n\n","category":"method"},{"location":"traversals/#Erdos.is_connected-Tuple{AGraphOrDiGraph}","page":"Traversals","title":"Erdos.is_connected","text":"is_connected(g)\n\nReturn true if graph g is connected. For directed graphs, return true if graph g is weakly connected.\n\nExamples\n\njulia> g = Graph([0 1 0; 1 0 1; 0 1 0]);\n\njulia> is_connected(g)\ntrue\n\njulia> g = Graph([0 1 0 0 0; 1 0 1 0 0; 0 1 0 0 0; 0 0 0 0 1; 0 0 0 1 0]);\n\njulia> is_connected(g)\nfalse\n\njulia> g = DiGraph([0 1 0; 0 0 1; 1 0 0]);\n\njulia> is_connected(g)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"traversals/#Erdos.is_strongly_connected-Tuple{ADiGraph}","page":"Traversals","title":"Erdos.is_strongly_connected","text":"is_strongly_connected(g)\n\nReturn true if directed graph g is strongly connected.\n\nExamples\n\njulia> g = DiGraph([0 1 0; 0 0 1; 1 0 0]);\n\njulia> is_strongly_connected(g)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"traversals/#Erdos.is_weakly_connected-Tuple{Any}","page":"Traversals","title":"Erdos.is_weakly_connected","text":"is_weakly_connected(g)\n\nReturn true if the graph g is weakly connected. If g is undirected, this function is equivalent to is_connected(g).\n\nExamples\n\njulia> g = DiGraph([0 1 0; 0 0 1; 1 0 0]);\n\njulia> is_weakly_connected(g)\ntrue\n\njulia> g = DiGraph([0 1 0; 1 0 1; 0 0 0]);\n\njulia> is_connected(g)\ntrue\n\njulia> is_strongly_connected(g)\nfalse\n\njulia> is_weakly_connected(g)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"traversals/#Erdos.neighborhood","page":"Traversals","title":"Erdos.neighborhood","text":"neighborhood(g, v, d, distmx=weights(g); dir=:out)\n\nReturn a vector of each vertex in g at a geodesic distance less than or equal to d, where distances may be specified by distmx. \n\nOptional Arguments\n\ndir=:out: If g is directed, this argument specifies the edge direction\n\nwith respect to v of the edges to be considered. Possible values: :in or :out.\n\nExamples\n\njulia> g = DiGraph([0 1 0 0 0; 0 0 1 0 0; 1 0 0 1 0; 0 0 0 0 1; 0 0 0 1 0]);\n\njulia> neighborhood(g, 1, 2)\n3-element Array{Int64,1}:\n 1\n 2\n 3\n\njulia> neighborhood(g, 1, 3)\n4-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n\njulia> neighborhood(g, 1, 3, [0 1 0 0 0; 0 0 1 0 0; 1 0 0 0.25 0; 0 0 0 0 0.25; 0 0 0 0.25 0])\n5-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n 5\n\n\n\n\n\n","category":"function"},{"location":"traversals/#Erdos.period-Tuple{ADiGraph}","page":"Traversals","title":"Erdos.period","text":"period(g)\n\nReturn the (common) period for all vertices in a strongly connected directed graph. Will throw an error if the graph is not strongly connected.\n\nExamples\n\njulia> g = DiGraph([0 1 0; 0 0 1; 1 0 0]);\n\njulia> period(g)\n3\n\n\n\n\n\n","category":"method"},{"location":"traversals/#Erdos.strongly_connected_components-Tuple{ADiGraph}","page":"Traversals","title":"Erdos.strongly_connected_components","text":"strongly_connected_components(g)\n\nCompute the strongly connected components of a directed graph g.\n\nReturn an array of arrays, each of which is the entire connected component.\n\nImplementation Notes\n\nThe order of the components is not part of the API contract.\n\nExamples\n\njulia> g = DiGraph([0 1 0; 1 0 1; 0 0 0]);\n\njulia> strongly_connected_components(g)\n2-element Array{Array{Int64,1},1}:\n [3]\n [1, 2]\n\n\n\n\n\n","category":"method"},{"location":"traversals/#Erdos.weakly_connected_components-Tuple{Any}","page":"Traversals","title":"Erdos.weakly_connected_components","text":"weakly_connected_components(g)\n\nReturn the weakly connected components of the graph g. This is equivalent to the connected components of the undirected equivalent of g. For undirected graphs this is equivalent to the connected_components of g.\n\nExamples\n\njulia> g = DiGraph([0 1 0; 1 0 1; 0 0 0]);\n\njulia> weakly_connected_components(g)\n1-element Array{Array{Int64,1},1}:\n [1, 2, 3]\n\n\n\n\n\n","category":"method"},{"location":"maps/#Edge-and-Vertex-Maps","page":"Edge And Vertex Maps","title":"Edge and Vertex Maps","text":"","category":"section"},{"location":"maps/","page":"Edge And Vertex Maps","title":"Edge And Vertex Maps","text":"Arbitrary values can be associated to a graph's vertices and edges, and handed over to method's that necessitate them, thanks to the edge maps and vertex maps interfaces. Also, edge and vector maps can be internally stored in network types and accessed through the property interface.","category":"page"},{"location":"maps/","page":"Edge And Vertex Maps","title":"Edge And Vertex Maps","text":"Example usage:","category":"page"},{"location":"maps/","page":"Edge And Vertex Maps","title":"Edge And Vertex Maps","text":"# create a graph\ng = erdos_renyi(10,0.1)\n\n\n# assign random weights to each edge\nweights = EdgeMap(g, e -> rand())\n\nfor e in edges(g)\n   # access map value\n   w = weights[e]\n   # or \n   i, j = e\n   w = weights[i,j]\n   .....\nend","category":"page"},{"location":"maps/#Edge-Maps","page":"Edge And Vertex Maps","title":"Edge Maps","text":"","category":"section"},{"location":"maps/","page":"Edge And Vertex Maps","title":"Edge And Vertex Maps","text":"Modules = [Erdos]\nPages   = [ \"maps/edgemap.jl\"]\nPrivate = false","category":"page"},{"location":"maps/#Erdos.ConstEdgeMap","page":"Edge And Vertex Maps","title":"Erdos.ConstEdgeMap","text":"struct ConstEdgeMap{T} <: SimpleEdgeMap{T}\n    val::T\nend\n\nA type representing a constant vector map. Any attempt to change the internal value, e.g. emap[u,v] = 4, will fail silently.\n\n\n\n\n\n","category":"type"},{"location":"maps/#Erdos.EdgeMap","page":"Edge And Vertex Maps","title":"Erdos.EdgeMap","text":"mutable struct EdgeMap{G <: AGraphOrDiGraph, T, D} <: AEdgeMap{T}\n    g::G\n    vtype::Type{T}\n    data::D\nend\n\nType implementing an edge map. The underlying container data can be a dictionary, a matrix or a vector (for graphs with indexed edges).\n\nEdgeMap{T}(g, ::Type{T})\n\nReturns a map that associates values of type T to the vertices of  graph g. The underlying storage structures is chosen accordingly.\n\nEdgeMap(g, data)\n\nConstruct a EdgeMap with data as underlying storage. The storage type can be a matrix or an associative edg => val type or a vector for graph with indexed edges.\n\nEdgeMap(g, f)\n\nConstruct an edge map with value f(e) for each e in edges(g).\n\n\n\n\n\n","category":"type"},{"location":"maps/#Erdos.edgemap2adjlist-Tuple{AEdgeMap}","page":"Edge And Vertex Maps","title":"Erdos.edgemap2adjlist","text":"edgemap2adjlist(emap)\n\nReturns a vector of vectors containing the values of the edge map emap on graph g following the same ordering of adjacency_list(g).\n\n\n\n\n\n","category":"method"},{"location":"maps/#Erdos.weights-Tuple{AGraphOrDiGraph}","page":"Edge And Vertex Maps","title":"Erdos.weights","text":"weights(g)\n\nReturns an edge map containing the \"weights\" associated to edges. For simple graphs, the return value is ConstEdgeMap(g, 1). For networks, returns the \"weights\" edge property if defined, otherwise the constant map.\n\nNotice that the edge map returned by weights is the default value for the edge weights used in many flow and  distance on graph algorithms.\n\n\n\n\n\n","category":"method"},{"location":"maps/#Vertex-Maps","page":"Edge And Vertex Maps","title":"Vertex Maps","text":"","category":"section"},{"location":"maps/","page":"Edge And Vertex Maps","title":"Edge And Vertex Maps","text":"Any AbstractVector{T} or Dict{Int,T} can be used as a vertex map.","category":"page"},{"location":"maps/","page":"Edge And Vertex Maps","title":"Edge And Vertex Maps","text":"Modules = [Erdos]\nPages   = [ \"maps/vertexmap.jl\"]\nPrivate = false","category":"page"},{"location":"maps/#Erdos.ConstVertexMap","page":"Edge And Vertex Maps","title":"Erdos.ConstVertexMap","text":"struct ConstVertexMap{T} <: AVertexMap{T}\n    val::T\nend\n\nA type representing a constant vector map. Any attempt to change the internal value, e.g. vm[1] = 4, will fail silently.\n\n\n\n\n\n","category":"type"},{"location":"maps/#Erdos.VertexMap","page":"Edge And Vertex Maps","title":"Erdos.VertexMap","text":"mutable struct VertexMap{G <: AGraphOrDiGraph, T, D} <: AVertexMap{T}\n    g::G\n    vtype::Type{T}\n    data::D\nend\n\nType implementing a vertex map. The underlying container data can be a dictionary or a vector.\n\nVertexMap{T}(g, ::Type{T})\n\nReturns a map that associates values of type T to the vertices of  graph g.  The underlying storage structures is chosen accordingly.\n\nVertexMap(g, data)\n\nConstruct a VertexMap with data as underlying storage.\n\nVertexMap(g, f)\n\nConstruct a vertex map with value f(u) for u in 1:nv(g).\n\n\n\n\n\n","category":"type"},{"location":"maps/#PropertyStore","page":"Edge And Vertex Maps","title":"PropertyStore","text":"","category":"section"},{"location":"maps/","page":"Edge And Vertex Maps","title":"Edge And Vertex Maps","text":"Modules = [Erdos]\nPages   = [ \"maps/property_store.jl\"]\nPrivate = false","category":"page"},{"location":"maps/#Erdos.PropertyStore","page":"Edge And Vertex Maps","title":"Erdos.PropertyStore","text":"mutable struct PropertyStore\n    gmaps::Dict{String, Any}\n    emaps::Dict{String,AEdgeMap}\n    vmaps::Dict{String,AVertexMap}\nend\n\nA type storing properties associated to networks.\n\n\n\n\n\n","category":"type"},{"location":"operators/#Operators","page":"Operators","title":"Operators","text":"","category":"section"},{"location":"operators/","page":"Operators","title":"Operators","text":"Erdos.jl implements the following graph operators:","category":"page"},{"location":"operators/","page":"Operators","title":"Operators","text":"Pages   = [\"operators.md\"]","category":"page"},{"location":"operators/","page":"Operators","title":"Operators","text":"Modules = [Erdos]\nPages   = [\"operators/operators.jl\"]\nPrivate = false","category":"page"},{"location":"operators/#Base.intersect-Union{Tuple{T}, Tuple{T, T}} where T<:AGraphOrDiGraph","page":"Operators","title":"Base.intersect","text":"intersect(g, h)\n\nProduces a graph with edges that are only in both graph g and graph h.\n\nNote that this function may produce a graph with 0-degree vertices.\n\n\n\n\n\n","category":"method"},{"location":"operators/#Base.join-Tuple{AGraph, AGraph}","page":"Operators","title":"Base.join","text":"join(g, h)\n\nMerges graphs g and h using blockdiag and then adds all the edges between  the vertices in g and those in h.\n\n\n\n\n\n","category":"method"},{"location":"operators/#Base.union-Union{Tuple{T}, Tuple{T, T}} where T<:AGraphOrDiGraph","page":"Operators","title":"Base.union","text":"union(g, h)\n\nMerges graphs g and h by taking the set union of all vertices and edges.\n\n\n\n\n\n","category":"method"},{"location":"operators/#Erdos.cartesian_product-Union{Tuple{G}, Tuple{G, G}} where G<:AGraphOrDiGraph","page":"Operators","title":"Erdos.cartesian_product","text":"cartesian_product(g, h)\n\nReturns the (cartesian product)[https://en.wikipedia.org/wiki/Cartesianproductof_graphs] of g and h\n\n\n\n\n\n","category":"method"},{"location":"operators/#Erdos.complement-Tuple{T} where T<:AGraph","page":"Operators","title":"Erdos.complement","text":"complement(g)\n\nProduces the graph complement of a graph.\n\n\n\n\n\n","category":"method"},{"location":"operators/#Erdos.complete!-Tuple{ADiGraph}","page":"Operators","title":"Erdos.complete!","text":"complete!(g::ADiGraph)\n\nFor each edge (u, v) in g, adds to g its reverse, i.e. (v, u).\n\n\n\n\n\n","category":"method"},{"location":"operators/#Erdos.complete-Tuple{ADiGraph}","page":"Operators","title":"Erdos.complete","text":"complete(g::ADiGraph)\n\nReturns a digraph containing both the edges (u, v) of g and their reverse (v, u). See also complete!.\n\n\n\n\n\n","category":"method"},{"location":"operators/#Erdos.contract!-Tuple{AGraphOrDiGraph, AbstractVector{T} where T}","page":"Operators","title":"Erdos.contract!","text":"contract!(g, vs)\ncontract!(g, v1, v2, ....)\n\nMerge the vertices in vs into a unique vertex.\n\n\n\n\n\n","category":"method"},{"location":"operators/#Erdos.crosspath-Union{Tuple{G}, Tuple{G, Any}} where G<:AGraph","page":"Operators","title":"Erdos.crosspath","text":"crosspath(g::AGraph, n::Integer)\n\nReplicate n times g and connect each vertex with its copies in a path.\n\n\n\n\n\n","category":"method"},{"location":"operators/#Erdos.difference-Union{Tuple{G}, Tuple{T}, Tuple{G, T}} where {T<:AGraphOrDiGraph, G<:AGraphOrDiGraph}","page":"Operators","title":"Erdos.difference","text":"difference(g, h)\n\nProduces a graph with all the edges in graph g that are not in graph h.\n\nNote that this function may produce a graph with 0-degree vertices.\n\n\n\n\n\n","category":"method"},{"location":"operators/#Erdos.egonet-Tuple{AGraphOrDiGraph, Integer, Integer}","page":"Operators","title":"Erdos.egonet","text":"egonet(g, v::Int, d::Int; dir=:out)\n\nReturns the subgraph of g induced by the neighbors of v up to distance d. If g is a DiGraph the dir optional argument specifies the edge direction the edge direction with respect to v (i.e. :in or :out) to be considered. This is equivalent to subgraph(g, neighborhood(g, v, d, dir=dir))[1].\n\n\n\n\n\n","category":"method"},{"location":"operators/#Erdos.subgraph-Union{Tuple{V}, Tuple{G}, Tuple{G, AbstractVector{V}}} where {G<:AGraphOrDiGraph, V<:Integer}","page":"Operators","title":"Erdos.subgraph","text":"subgraph(g, vlist) -> sg, vlist\nsubgraph(g, elist) -> sg, vlist\n\nReturns the subgraph of g induced by the vertices in  vlist or by the edges in elist, along with vlist itself (a newly created vector for the second method).\n\nThe returned graph has length(vlist) vertices, with the new vertex i corresponding to the vertex of the original graph in the i-th position of vlist.\n\nFor easy subgraph creation also g[vlist] or g[elist] can be used.\n\nIf g is a network, vector and edge properties won't be converved sg. You can preserve properties using the subnetwork method.\n\nUsage Examples:\n\ng = CompleteGraph(10)\nsg, vlist = subgraph(g, 5:8)\n@assert g[5:8] == sg\n@assert nv(sg) == 4\n@assert ne(sg) == 6\n@assert vm[4] == 8\n\nsg, vlist = subgraph(g, [2,8,3,4])\n@asssert sg == g[[2,8,3,4]]\n\nelist = [Edge(1,2), Edge(3,4), Edge(4,8)]\nsg, vlist = subgraph(g, elist)\n@asssert sg == g[elist]\n\n\n\n\n\n","category":"method"},{"location":"operators/#Erdos.subnetwork-Union{Tuple{V}, Tuple{G}, Tuple{G, AbstractVector{V}}} where {G<:ANetOrDiNet, V<:Integer}","page":"Operators","title":"Erdos.subnetwork","text":"subnetwork(g, vlist) -> sg, vlist\nsubnetwork(g, elist) -> sg, vlist\n\nEquivalent to subgraph but preserves vertex and edge properties when g is a network.\n\n\n\n\n\n","category":"method"},{"location":"operators/#Erdos.symmetric_difference-Union{Tuple{T}, Tuple{T, T}} where T<:AGraphOrDiGraph","page":"Operators","title":"Erdos.symmetric_difference","text":"symmetric_difference(g, h)\n\nProduces a graph with edges from graph g that do not exist in graph h, and vice versa.\n\nNote that this function may produce a graph with 0-degree vertices.\n\n\n\n\n\n","category":"method"},{"location":"operators/#Erdos.tensor_product-Union{Tuple{G}, Tuple{G, G}} where G<:AGraphOrDiGraph","page":"Operators","title":"Erdos.tensor_product","text":"tensor_product(g, h)\n\nReturns the (tensor product)[https://en.wikipedia.org/wiki/Tensorproductof_graphs] of g and h\n\n\n\n\n\n","category":"method"},{"location":"shortestpaths/#Shortest-Path-Algorithms","page":"Shortest Paths","title":"Shortest-Path Algorithms","text":"","category":"section"},{"location":"shortestpaths/","page":"Shortest Paths","title":"Shortest Paths","text":"Erdos implements several classical algorithms for finding the shortest paths between one or more vertex and any other vertex in the graphs. For all algorithms the following holds:","category":"page"},{"location":"shortestpaths/","page":"Shortest Paths","title":"Shortest Paths","text":"the distance from a vertex to itself is always 0;\nthe distance between two vertices with no connecting paths is always Inf.","category":"page"},{"location":"shortestpaths/","page":"Shortest Paths","title":"Shortest Paths","text":"The shortest_paths method provides easy access to the default algorithm.","category":"page"},{"location":"shortestpaths/","page":"Shortest Paths","title":"Shortest Paths","text":"shortest_paths\na_star\ndijkstra_shortest_paths\nbellman_ford_shortest_paths\nfloyd_warshall_shortest_paths","category":"page"},{"location":"shortestpaths/#Erdos.shortest_paths","page":"Shortest Paths","title":"Erdos.shortest_paths","text":"shortest_paths(g, x...; kws...)\n\nComputes shortest paths using Dijkstra's algorithm. See dijkstra_shortest_paths.\n\n\n\n\n\n","category":"function"},{"location":"shortestpaths/#Erdos.a_star","page":"Shortest Paths","title":"Erdos.a_star","text":"a_star(g, s, t, distmx=weights(g), heuristic = n->0)\n\nComputes the shortest path between vertices s and t using the A* search algorithm. An optional heuristic function and edge distance matrix may be supplied. Returns an empty path if there are no such paths.\n\n\n\n\n\n","category":"function"},{"location":"shortestpaths/#Erdos.dijkstra_shortest_paths","page":"Shortest Paths","title":"Erdos.dijkstra_shortest_paths","text":"dijkstra_shortest_paths(g, s, distmx=weights(g); allpaths=false)\ndijkstra_shortest_paths(g, sources, distmx=weights(g); allpaths=false)\n\nPerforms Dijkstra's algorithm on a graph, computing shortest distances between a source vertex s (or a vector sources)  and all other veritces. Returns a DijkstraState that contains various traversal information.\n\nWith allpaths=true, returns a DijkstraState that keeps track of all predecessors of a given vertex.\n\n\n\n\n\n","category":"function"},{"location":"shortestpaths/#Erdos.bellman_ford_shortest_paths","page":"Shortest Paths","title":"Erdos.bellman_ford_shortest_paths","text":"bellman_ford_shortest_paths(g, s, distmx=weights(g))\nbellman_ford_shortest_paths(g, sources, distmx=weights(g))\n\nUses the Bellman-Ford algorithm to compute shortest paths of all vertices of a g from a source vertex s (or a set of source vertices sources). Returns a BellmanFordState with relevant traversal information.\n\n\n\n\n\n","category":"function"},{"location":"shortestpaths/#Erdos.floyd_warshall_shortest_paths","page":"Shortest Paths","title":"Erdos.floyd_warshall_shortest_paths","text":"floyd_warshall_shortest_paths(g, distmx=weights(g))\n\nUses the Floyd-Warshall algorithm to compute shortest paths between all pairs of vertices in graph g. Returns a FloydWarshallState with relevant traversal information, each is a vertex-indexed vector of vectors containing the metric for each vertex in the graph.\n\nNote that this algorithm may return a large amount of data (it will allocate on the order of O(nv^2)).\n\n\n\n\n\n","category":"function"},{"location":"shortestpaths/#Path-discovery-/-enumeration","page":"Shortest Paths","title":"Path discovery / enumeration","text":"","category":"section"},{"location":"shortestpaths/","page":"Shortest Paths","title":"Shortest Paths","text":"enumerate_paths","category":"page"},{"location":"shortestpaths/#Erdos.enumerate_paths","page":"Shortest Paths","title":"Erdos.enumerate_paths","text":"enumerate_paths(state::AbstractPathState)\nenumerate_paths(state::AbstractPathState, dest)\n\nGiven a path state state of type AbstractPathState (see below), returns a vector (indexed by vertex) of the paths between the source vertex used to compute the path state and a destination vertex v, a set of destination vertices vs, or the entire graph. For multiple destination vertices, each path is represented by a vector of vertices on the path between the source and the destination. Nonexistent paths will be indicated by an empty vector. For single destinations, the path is represented by a single vector of vertices, and will be length 0 if the path does not exist.\n\nFor Floyd-Warshall path states, please note that the output is a bit different, since this algorithm calculates all shortest paths for all pairs of vertices: enumerate_paths(state) will return a vector (indexed by source vertex) of vectors (indexed by destination vertex) of paths. enumerate_paths(state, v) will return a vector (indexed by destination vertex) of paths from source v to all other vertices. In addition, enumerate_paths(state, v, d) will return a vector representing the path from vertex v to vertex d.\n\n\n\n\n\n","category":"function"},{"location":"shortestpaths/","page":"Shortest Paths","title":"Shortest Paths","text":"For Floyd-Warshall path states, please note that the output is a bit different, since this algorithm calculates all shortest paths for all pairs of vertices: enumerate_paths(state) will return a vector (indexed by source vertex) of vectors (indexed by destination vertex) of paths. enumerate_paths(state, v) will return a vector (indexed by destination vertex) of paths from source v to all other vertices. In addition, enumerate_paths(state, v, d) will return a vector representing the path from vertex v to vertex d.","category":"page"},{"location":"shortestpaths/#Path-States","page":"Shortest Paths","title":"Path States","text":"","category":"section"},{"location":"shortestpaths/","page":"Shortest Paths","title":"Shortest Paths","text":"The floyd_warshall_shortest_paths, bellman_ford_shortest_paths, dijkstra_shortest_paths, and dijkstra_predecessor_and_distance functions return a state that contains various information about the graph learned during traversal. The three state types have the following common information, accessible via the type:","category":"page"},{"location":"shortestpaths/","page":"Shortest Paths","title":"Shortest Paths","text":".dists Holds a vector of distances computed, indexed by source vertex.","category":"page"},{"location":"shortestpaths/","page":"Shortest Paths","title":"Shortest Paths","text":".parents Holds a vector of parents of each source vertex. The parent of a source vertex is always 0.","category":"page"},{"location":"shortestpaths/","page":"Shortest Paths","title":"Shortest Paths","text":"In addition, the dijkstra_predecessor_and_distance function stores the following information:","category":"page"},{"location":"shortestpaths/","page":"Shortest Paths","title":"Shortest Paths","text":".predecessors Holds a vector, indexed by vertex, of all the predecessors discovered during shortest-path calculations. This keeps track of all parents when there are multiple shortest paths available from the source.","category":"page"},{"location":"shortestpaths/","page":"Shortest Paths","title":"Shortest Paths","text":".pathcounts Holds a vector, indexed by vertex, of the path counts discovered during traversal. This equals the length of each subvector in the .predecessors output above.","category":"page"},{"location":"deterministicgraphs/#Deterministic-Graph-Generators","page":"Deterministic Graphs","title":"Deterministic Graph Generators","text":"","category":"section"},{"location":"deterministicgraphs/","page":"Deterministic Graphs","title":"Deterministic Graphs","text":"Order = [:type, :function]\nPages = [ \"generators/staticgraphs.jl\",\n           \"generators/smallgraphs.jl\",\n           \"generators/euclideangraphs.jl\"\n        ]","category":"page"},{"location":"deterministicgraphs/#Static-Graphs","page":"Deterministic Graphs","title":"Static Graphs","text":"","category":"section"},{"location":"deterministicgraphs/","page":"Deterministic Graphs","title":"Deterministic Graphs","text":"Erdos.jl implements a collection of classic graph generators:","category":"page"},{"location":"deterministicgraphs/","page":"Deterministic Graphs","title":"Deterministic Graphs","text":"Modules = [Erdos]\nPages   = [ \"generators/staticgraphs.jl\"]\nPrivate = false","category":"page"},{"location":"deterministicgraphs/#Erdos.BinaryTree-Union{Tuple{Int64}, Tuple{G}, Tuple{Int64, Type{G}}} where G<:AGraph","page":"Deterministic Graphs","title":"Erdos.BinaryTree","text":"BinaryTree(levels, G=Graph)\n\nCreates a binary tree with k-levels vertices are numbered 1:2^levels-1\n\n\n\n\n\n","category":"method"},{"location":"deterministicgraphs/#Erdos.CliqueGraph-Union{Tuple{G}, Tuple{Integer, Integer}, Tuple{Integer, Integer, Type{G}}} where G<:AGraph","page":"Deterministic Graphs","title":"Erdos.CliqueGraph","text":"CliqueGraph(k, n, G=Graph)\n\nThis function generates a graph with n k-cliques connected circularly by n edges.\n\n\n\n\n\n","category":"method"},{"location":"deterministicgraphs/#Erdos.CompleteBipartiteGraph-Union{Tuple{G}, Tuple{Integer, Integer}, Tuple{Integer, Integer, Type{G}}} where G<:AGraph","page":"Deterministic Graphs","title":"Erdos.CompleteBipartiteGraph","text":"CompleteBipartiteGraph(n1, n2, G = Graph)\n\nCreates a complete bipartite graph with n1+n2 vertices. It has edges connecting each pair of vertices in the two sets.\n\n\n\n\n\n","category":"method"},{"location":"deterministicgraphs/#Erdos.CompleteDiGraph-Union{Tuple{Integer}, Tuple{G}, Tuple{Integer, Type{G}}} where G<:ADiGraph","page":"Deterministic Graphs","title":"Erdos.CompleteDiGraph","text":"CompleteDiGraph(n, G = DiGraph)\n\nCreates a complete digraph with n vertices. A complete digraph has edges connecting each pair of vertices (both an ingoing and outgoing edge).\n\n\n\n\n\n","category":"method"},{"location":"deterministicgraphs/#Erdos.CompleteGraph-Union{Tuple{Integer}, Tuple{G}, Tuple{Integer, Type{G}}} where G<:AGraph","page":"Deterministic Graphs","title":"Erdos.CompleteGraph","text":"CompleteGraph(n, G = Graph)\n\nCreates a complete graph of type G with n vertices. A complete graph has edges connecting each pair of vertices.\n\n\n\n\n\n","category":"method"},{"location":"deterministicgraphs/#Erdos.CycleDiGraph-Union{Tuple{Integer}, Tuple{G}, Tuple{Integer, Type{G}}} where G<:ADiGraph","page":"Deterministic Graphs","title":"Erdos.CycleDiGraph","text":"Creates a cycle digraph with n vertices. A cycle digraph is a closed path digraph.\n\n\n\n\n\n","category":"method"},{"location":"deterministicgraphs/#Erdos.CycleGraph-Union{Tuple{Integer}, Tuple{G}, Tuple{Integer, Type{G}}} where G<:AGraph","page":"Deterministic Graphs","title":"Erdos.CycleGraph","text":"CycleGraph(n, G=Graph)\n\nCreates a cycle graph with n vertices. A cycle graph is a closed path graph.\n\n\n\n\n\n","category":"method"},{"location":"deterministicgraphs/#Erdos.DoubleBinaryTree-Union{Tuple{Int64}, Tuple{G}, Tuple{Int64, Type{G}}} where G<:AGraph","page":"Deterministic Graphs","title":"Erdos.DoubleBinaryTree","text":"DoubleBinaryTree(levels, G=Graph)\n\nCreate a double complete binary tree with k-levels used as an example for spectral clustering by Guattery and Miller 1998.\n\n\n\n\n\n","category":"method"},{"location":"deterministicgraphs/#Erdos.Grid-Union{Tuple{AbstractVector{T}}, Tuple{G}, Tuple{T}, Tuple{AbstractVector{T}, Type{G}}} where {T<:Integer, G<:AGraph}","page":"Deterministic Graphs","title":"Erdos.Grid","text":"Grid(dims::AbstractVector, G=Graph; periodic=false)\n\nCreates a d-dimensional cubic lattice, with d=length(dims) and length  dims[i] in dimension i. If periodic=true the resulting lattice will have periodic boundary condition in each dimension.\n\n\n\n\n\n","category":"method"},{"location":"deterministicgraphs/#Erdos.PathDiGraph-Union{Tuple{Integer}, Tuple{G}, Tuple{Integer, Type{G}}} where G<:ADiGraph","page":"Deterministic Graphs","title":"Erdos.PathDiGraph","text":"PathDiGraph(n, G = DiGraph)\n\nCreates a path digraph with n vertices. A path graph connects each successive vertex by a single directed edge.\n\n\n\n\n\n","category":"method"},{"location":"deterministicgraphs/#Erdos.PathGraph-Union{Tuple{Integer}, Tuple{G}, Tuple{Integer, Type{G}}} where G<:AGraph","page":"Deterministic Graphs","title":"Erdos.PathGraph","text":"PathGraph(n, G = Graph)\n\nCreates a path graph with n vertices. A path graph connects each successive vertex by a single edge.\n\n\n\n\n\n","category":"method"},{"location":"deterministicgraphs/#Erdos.RoachGraph-Union{Tuple{Int64}, Tuple{G}, Tuple{Int64, Type{G}}} where G<:AGraph","page":"Deterministic Graphs","title":"Erdos.RoachGraph","text":"The Roach Graph from Guattery and Miller 1998\n\n\n\n\n\n","category":"method"},{"location":"deterministicgraphs/#Erdos.StarDiGraph-Union{Tuple{Integer}, Tuple{G}, Tuple{Integer, Type{G}}} where G<:ADiGraph","page":"Deterministic Graphs","title":"Erdos.StarDiGraph","text":"Creates a star digraph with n vertices. A star digraph has a central vertex with directed edges to every other vertex.\n\n\n\n\n\n","category":"method"},{"location":"deterministicgraphs/#Erdos.StarGraph-Union{Tuple{Integer}, Tuple{G}, Tuple{Integer, Type{G}}} where G<:AGraph","page":"Deterministic Graphs","title":"Erdos.StarGraph","text":"StarGraph(n, G = Graph)\n\nCreates a star graph with n vertices. A star graph has a central vertex with edges to each other vertex.\n\n\n\n\n\n","category":"method"},{"location":"deterministicgraphs/#Erdos.WheelDiGraph-Union{Tuple{Integer}, Tuple{G}, Tuple{Integer, Type{G}}} where G<:ADiGraph","page":"Deterministic Graphs","title":"Erdos.WheelDiGraph","text":"Creates a wheel digraph with n vertices. A wheel graph is a star digraph with the outer vertices connected via a closed path graph.\n\n\n\n\n\n","category":"method"},{"location":"deterministicgraphs/#Erdos.WheelGraph-Union{Tuple{Integer}, Tuple{G}, Tuple{Integer, Type{G}}} where G<:AGraph","page":"Deterministic Graphs","title":"Erdos.WheelGraph","text":"WheelGraph(n, G=Graph)\n\nCreates a wheel graph with n vertices. A wheel graph is a star graph with the outer vertices connected via a closed path graph.\n\n\n\n\n\n","category":"method"},{"location":"deterministicgraphs/#Small-Graphs","page":"Deterministic Graphs","title":"Small Graphs","text":"","category":"section"},{"location":"deterministicgraphs/","page":"Deterministic Graphs","title":"Deterministic Graphs","text":"Other classical graphs can be generated by the following function:","category":"page"},{"location":"deterministicgraphs/","page":"Deterministic Graphs","title":"Deterministic Graphs","text":"Modules = [Erdos]\nPages   = [ \"generators/smallgraphs.jl\"]\nPrivate = false","category":"page"},{"location":"deterministicgraphs/#Erdos.digraph-Union{Tuple{G}, Tuple{Int64, Vector{Tuple{Int64, Int64}}}, Tuple{Int64, Vector{Tuple{Int64, Int64}}, Type{G}}} where G<:ADiGraph","page":"Deterministic Graphs","title":"Erdos.digraph","text":"digraph{G<:AGraph}(n, edgelist::Vector{Tuple{Int,Int}},\n    G = Graph)\n\nBuild a digraph with n vertices, type G, and given edgelist.\n\n\n\n\n\n","category":"method"},{"location":"deterministicgraphs/#Erdos.digraph-Union{Tuple{Symbol}, Tuple{G}, Tuple{Symbol, Type{G}}} where G<:ADiGraph","page":"Deterministic Graphs","title":"Erdos.digraph","text":"digraph(s::Symbol, G = DiGraph)\n\nCreates a notorious digraph s of type G. Admissible values for s are:\n\ns graph type\n:truncatedtetrahedron A skeleton of the truncated tetrahedron digraph.\n\n\n\n\n\n","category":"method"},{"location":"deterministicgraphs/#Erdos.graph-Union{Tuple{G}, Tuple{Int64, Vector{Tuple{Int64, Int64}}}, Tuple{Int64, Vector{Tuple{Int64, Int64}}, Type{G}}} where G<:AGraph","page":"Deterministic Graphs","title":"Erdos.graph","text":"graph{G<:AGraph}(n, edgelist::Vector{Tuple{Int,Int}},\n    G = Graph)\n\nBuild a graph with n vertices, of type G, and given edgelist.\n\n\n\n\n\n","category":"method"},{"location":"deterministicgraphs/#Erdos.graph-Union{Tuple{Symbol}, Tuple{G}, Tuple{Symbol, Type{G}}} where G<:AGraph","page":"Deterministic Graphs","title":"Erdos.graph","text":"graph(s::Symbol, G = Graph)\n\nCreates a notorious graph s of type G. Admissible values for s are:\n\ns graph type\n:bull A bull graph.\n:chvatal A Chvátal graph.\n:cubical A Platonic cubical graph.\n:desargues A Desarguesgraph.\n:diamond A diamond graph.\n:dodecahedral A Platonic dodecahedral  graph.\n:frucht A Frucht graph.\n:heawood A Heawood graph.\n:house A graph mimicing the classic outline of a house.\n:housex A house graph, with two edges crossing the bottom square.\n:icosahedral A Platonic icosahedral   graph.\n:krackhardtkite A Krackhardt-Kite social network  graph.\n:moebiuskantor A Möbius-Kantor graph.\n:octahedral A Platonic octahedral graph.\n:pappus A Pappus graph.\n:petersen A Petersen graph.\n:sedgewickmaze A simple maze graph used in Sedgewick's Algorithms in C++: Graph  Algorithms (3rd ed.)\n:tetrahedral A Platonic tetrahedral  graph.\n:truncatedcube A skeleton of the truncated cube graph.\n:truncatedtetrahedron A skeleton of the truncated tetrahedron  graph.\n:tutte A Tutte graph.\n\nA collection of real world graphs is available through the readgraph function.\n\n\n\n\n\n","category":"method"},{"location":"deterministicgraphs/#Euclidean-Graphs","page":"Deterministic Graphs","title":"Euclidean Graphs","text":"","category":"section"},{"location":"deterministicgraphs/","page":"Deterministic Graphs","title":"Deterministic Graphs","text":"Generation of random and static graphs embedded in Euclidean space.","category":"page"},{"location":"deterministicgraphs/","page":"Deterministic Graphs","title":"Deterministic Graphs","text":"Modules = [Erdos]\nPages   = [ \"generators/euclideangraphs.jl\"]\nPrivate = false","category":"page"},{"location":"deterministicgraphs/#Erdos.euclidean_graph-Union{Tuple{Matrix{T} where T}, Tuple{G}, Tuple{Matrix{T} where T, Type{G}}} where G<:AGraph","page":"Deterministic Graphs","title":"Erdos.euclidean_graph","text":"euclidean_graph(points::Matrix, G; L=1., p=2., cutoff=Inf, bc=:periodic)\n\nGiven the d×N matrix points builds an Euclidean graph of N vertices according to the following procedure.\n\nDefining the d-dimensional vectors x[i] = points[:,i], an edge between vertices i and j is inserted if norm(x[i]-x[j], p) < cutoff. In case of negative cutoff instead every edge is inserted. For p=2 we have the standard Euclidean distance. Set bc=:periodic to impose periodic boundary conditions in the box 0L^d. Set bc=:open for open boundary condition. In this case the keyword argument L will be ignored.\n\nReturns a graph and Dict containing the distance on each edge.\n\n\n\n\n\n","category":"method"},{"location":"indexbase/#Erdos","page":"Erdos","title":"Erdos","text":"","category":"section"},{"location":"indexbase/","page":"Erdos","title":"Erdos","text":"Erdos is a graph library written in Julia. Installation is straightforward:","category":"page"},{"location":"indexbase/","page":"Erdos","title":"Erdos","text":"julia> Pkg.add(\"Erdos\")","category":"page"},{"location":"indexbase/","page":"Erdos","title":"Erdos","text":"Erdos defines two abstract graph types, AGraph and ADiGraph, from which all concrete undirected and directed graph types are derived.","category":"page"},{"location":"indexbase/","page":"Erdos","title":"Erdos","text":"Two concrete graph types, Graph and Network, and two digraph types, DiGraph and DiNetwork are implemented. In all these types the graph topology is represented internally as an adjacency list for each vertex. (Di)Networks come with some additional features over (Di)Graphs:","category":"page"},{"location":"indexbase/","page":"Erdos","title":"Erdos","text":"each edge has a unique index;\nvertex/edge maps (also called properties) can be stored internally.","category":"page"},{"location":"indexbase/","page":"Erdos","title":"Erdos","text":"All graphs in Erdos have 1:n indexed vertices, where n is the number of vertices. Multi-edges are not allowed. Self-edges are experimentally supported. Provided this constraints, new graph types can be easily introduced just defining a few basic methods.","category":"page"},{"location":"indexbase/#Basic-examples","page":"Erdos","title":"Basic examples","text":"","category":"section"},{"location":"indexbase/#Constructors","page":"Erdos","title":"Constructors","text":"","category":"section"},{"location":"indexbase/","page":"Erdos","title":"Erdos","text":"Build your first graph using the basic constructors.","category":"page"},{"location":"indexbase/","page":"Erdos","title":"Erdos","text":"julia> using Erdos\n\njulia> g = CompleteGraph(100)\nGraph{Int64}(100, 4950)\n\njulia> g = Network(10, 30) # a random graph with 10 vertex and 30 edges\nNetwork(10, 30)\n\njulia> g = Graph{Int32}(100)\nGraph{Int32}(100, 0)\n\njulia> g = DiGraph()\nDiGraph{Int64}(0, 0)\n\njulia> g = erdos_renyi(10,30)\nGraph{Int64}(10, 30)\n\njulia> g = random_regular_graph(10,3,seed=17)\nGraph{Int64}(10, 15).","category":"page"},{"location":"indexbase/","page":"Erdos","title":"Erdos","text":"The default graph and digraph types are Graph{Int} and DiGraph{Int}. Use  the Graph{Int32} type to save memory if working with very large graphs.","category":"page"},{"location":"indexbase/#Queries","page":"Erdos","title":"Queries","text":"","category":"section"},{"location":"indexbase/","page":"Erdos","title":"Erdos","text":"julia> g = CompleteBipartiteGraph(5,10)\nGraph{Int64}(15, 50)\n\njulia> is_bipartite(g)\ntrue\n\njulia> nv(g) # number of vertices\n15\n\njulia> ne(g) #number of edges\n50\n\njulia> has_edge(g,1,2)\nfalse\n\njulia> has_edge(g,1,6)\ntrue\n\njulia> degree(g,1)\n10","category":"page"},{"location":"indexbase/#Modifiers:","page":"Erdos","title":"Modifiers:","text":"","category":"section"},{"location":"indexbase/","page":"Erdos","title":"Erdos","text":"julia> g=DiGraph(10)\nDiGraph{Int64}(10, 0)\n\njulia> add_edge!(g,1,2)\ntrue\n\njulia> g\nDiGraph{Int64}(10, 1)\n\n# trying to add an edge between non-existen vertices results in a\n# (silent) failure\njulia> add_edge!(g,1,11)\nfalse\n\n# has the addition of an already existent edge\njulia> add_edge!(g,1,2)\nfalse\n\njulia> add_edge!(g,2,1)\ntrue\n\njulia> rem_edge!(g,2,1)\ntrue\n\n# returns the index of the vertex\njulia> add_vertex!(g)\n11\n\n# vertex removal will cause the switch of the last index\n# with the removed one, to keep the indexes continuity.\njulia> rem_vertex!(g,1)\ntrue\n\njulia> rem_vertex!(g,12)\nfalse","category":"page"},{"location":"indexbase/#Iterators","page":"Erdos","title":"Iterators","text":"","category":"section"},{"location":"indexbase/","page":"Erdos","title":"Erdos","text":"julia> g = Graph(10,20) #erdos renyi random graph with 10 vertices and 20 edges\nGraph{Int64}(10, 20)\n\njulia> numedges = 0;\n\n# iterate over all edges\njulia> for e in edges(g)\n           i, j = src(e), dst(e) # source and destination of an edge\n           @assert i <= j  # default for undirected graphs\n           numedge += 1\n       end\n\njulia> ne(g) == numedge\ntrue\n\njulia> k=0;\n\njulia> for i in neighbors(g,1)\n           @assert has_edge(g, 1, i);\n           k += 1\n       end\n\njulia> degree(g, 1) == k\ntrue","category":"page"},{"location":"indexbase/#I/O","page":"Erdos","title":"I/O","text":"","category":"section"},{"location":"indexbase/","page":"Erdos","title":"Erdos","text":"Erdos supports many standard graph formats. Here is an example with Pajek's .net format:","category":"page"},{"location":"indexbase/","page":"Erdos","title":"Erdos","text":"julia> g = DiGraph(10,20)\nDiGraph{Int64}(10, 20)\n\njulia> writegraph(\"test.net\", g)\n1\n\njulia> h = readgraph(\"test.net\")\nDiGraph{Int64}(10, 20)\n\njulia> g == h\ntrue","category":"page"},{"location":"indexbase/#Datasets","page":"Erdos","title":"Datasets","text":"","category":"section"},{"location":"indexbase/","page":"Erdos","title":"Erdos","text":"A collection of real world graphs is available through readgraph:","category":"page"},{"location":"indexbase/","page":"Erdos","title":"Erdos","text":"julia> g = readgraph(:karate)\nGraph{Int64}(34, 78)\n\njulia> g = readgraph(:condmat,Graph{UInt32})\nGraph{UInt32}(16726, 47594)","category":"page"},{"location":"indexbase/#Ready-to-explore","page":"Erdos","title":"Ready to explore","text":"","category":"section"},{"location":"#Erdos","page":"Getting Started","title":"Erdos","text":"","category":"section"},{"location":"","page":"Getting Started","title":"Getting Started","text":"Erdos is a graph library written in Julia. Installation is straightforward:","category":"page"},{"location":"","page":"Getting Started","title":"Getting Started","text":"julia> Pkg.add(\"Erdos\")","category":"page"},{"location":"","page":"Getting Started","title":"Getting Started","text":"Erdos defines two abstract graph types, AGraph and ADiGraph, from which all concrete undirected and directed graph types are derived.","category":"page"},{"location":"","page":"Getting Started","title":"Getting Started","text":"Two concrete graph types, Graph and Network, and two digraph types, DiGraph and DiNetwork are implemented. In all these types the graph topology is represented internally as an adjacency list for each vertex. (Di)Networks come with some additional features over (Di)Graphs:","category":"page"},{"location":"","page":"Getting Started","title":"Getting Started","text":"each edge has a unique index;\nvertex/edge maps (also called properties) can be stored internally.","category":"page"},{"location":"","page":"Getting Started","title":"Getting Started","text":"All graphs in Erdos have 1:n indexed vertices, where n is the number of vertices. Multi-edges are not allowed. Self-edges are experimentally supported. Provided this constraints, new graph types can be easily introduced just defining a few basic methods.","category":"page"},{"location":"#Basic-examples","page":"Getting Started","title":"Basic examples","text":"","category":"section"},{"location":"#Constructors","page":"Getting Started","title":"Constructors","text":"","category":"section"},{"location":"","page":"Getting Started","title":"Getting Started","text":"Build your first graph using the basic constructors.","category":"page"},{"location":"","page":"Getting Started","title":"Getting Started","text":"julia> using Erdos\n\njulia> g = CompleteGraph(100)\nGraph{Int64}(100, 4950)\n\njulia> g = Network(10, 30) # a random graph with 10 vertex and 30 edges\nNetwork(10, 30)\n\njulia> g = Graph{Int32}(100)\nGraph{Int32}(100, 0)\n\njulia> g = DiGraph()\nDiGraph{Int64}(0, 0)\n\njulia> g = erdos_renyi(10,30)\nGraph{Int64}(10, 30)\n\njulia> g = random_regular_graph(10,3,seed=17)\nGraph{Int64}(10, 15).","category":"page"},{"location":"","page":"Getting Started","title":"Getting Started","text":"The default graph and digraph types are Graph{Int} and DiGraph{Int}. Use  the Graph{Int32} type to save memory if working with very large graphs.","category":"page"},{"location":"#Queries","page":"Getting Started","title":"Queries","text":"","category":"section"},{"location":"","page":"Getting Started","title":"Getting Started","text":"julia> g = CompleteBipartiteGraph(5,10)\nGraph{Int64}(15, 50)\n\njulia> is_bipartite(g)\ntrue\n\njulia> nv(g) # number of vertices\n15\n\njulia> ne(g) #number of edges\n50\n\njulia> has_edge(g,1,2)\nfalse\n\njulia> has_edge(g,1,6)\ntrue\n\njulia> degree(g,1)\n10","category":"page"},{"location":"#Modifiers:","page":"Getting Started","title":"Modifiers:","text":"","category":"section"},{"location":"","page":"Getting Started","title":"Getting Started","text":"julia> g=DiGraph(10)\nDiGraph{Int64}(10, 0)\n\njulia> add_edge!(g,1,2)\ntrue\n\njulia> g\nDiGraph{Int64}(10, 1)\n\n# trying to add an edge between non-existen vertices results in a\n# (silent) failure\njulia> add_edge!(g,1,11)\nfalse\n\n# has the addition of an already existent edge\njulia> add_edge!(g,1,2)\nfalse\n\njulia> add_edge!(g,2,1)\ntrue\n\njulia> rem_edge!(g,2,1)\ntrue\n\n# returns the index of the vertex\njulia> add_vertex!(g)\n11\n\n# vertex removal will cause the switch of the last index\n# with the removed one, to keep the indexes continuity.\njulia> rem_vertex!(g,1)\ntrue\n\njulia> rem_vertex!(g,12)\nfalse","category":"page"},{"location":"#Iterators","page":"Getting Started","title":"Iterators","text":"","category":"section"},{"location":"","page":"Getting Started","title":"Getting Started","text":"julia> g = Graph(10,20) #erdos renyi random graph with 10 vertices and 20 edges\nGraph{Int64}(10, 20)\n\njulia> numedges = 0;\n\n# iterate over all edges\njulia> for e in edges(g)\n           i, j = src(e), dst(e) # source and destination of an edge\n           @assert i <= j  # default for undirected graphs\n           numedge += 1\n       end\n\njulia> ne(g) == numedge\ntrue\n\njulia> k=0;\n\njulia> for i in neighbors(g,1)\n           @assert has_edge(g, 1, i);\n           k += 1\n       end\n\njulia> degree(g, 1) == k\ntrue","category":"page"},{"location":"#I/O","page":"Getting Started","title":"I/O","text":"","category":"section"},{"location":"","page":"Getting Started","title":"Getting Started","text":"Erdos supports many standard graph formats. Here is an example with Pajek's .net format:","category":"page"},{"location":"","page":"Getting Started","title":"Getting Started","text":"julia> g = DiGraph(10,20)\nDiGraph{Int64}(10, 20)\n\njulia> writegraph(\"test.net\", g)\n1\n\njulia> h = readgraph(\"test.net\")\nDiGraph{Int64}(10, 20)\n\njulia> g == h\ntrue","category":"page"},{"location":"#Datasets","page":"Getting Started","title":"Datasets","text":"","category":"section"},{"location":"","page":"Getting Started","title":"Getting Started","text":"A collection of real world graphs is available through readgraph:","category":"page"},{"location":"","page":"Getting Started","title":"Getting Started","text":"julia> g = readgraph(:karate)\nGraph{Int64}(34, 78)\n\njulia> g = readgraph(:condmat,Graph{UInt32})\nGraph{UInt32}(16726, 47594)","category":"page"},{"location":"#Ready-to-explore","page":"Getting Started","title":"Ready to explore","text":"","category":"section"},{"location":"","page":"Getting Started","title":"Getting Started","text":"Refer to the documentation to explore all the features of Erdos. Here is a comprehensive list of the implemente algorithms. (EE) denotes algorithms in the companion package ErdosExtras.","category":"page"},{"location":"","page":"Getting Started","title":"Getting Started","text":"core functions: vertices and edges addition and removal, degree (in/out/all), neighbors (in/out/all)\nmaps dictionary like types to store properties associated to vertices and edges\nnetworks store vertex/edge/graph properties (maps) inside the graph itself\nconnectivity: strongly- and weakly-connected components, bipartite checks, condensation, attracting components, neighborhood, k-core\noperators: complement, reverse, reverse!, union, join, intersect, difference, symmetric difference, blockdiag, induced subgraphs, products (cartesian/scalar)\nshortest paths: Dijkstra, Dijkstra with predecessors, Bellman-Ford, Floyd-Warshall, A*\ngraph datasets: A collection of real world graphs (e.g. Zachary's karate club)\ngraph generators: notorious graphs, euclidean graphs and random graphs (Erdős–Rényi, Watts-Strogatz, random regular, arbitrary degree sequence, stochastic block model)\nI/O formats: graphml, gml, gexf, dot, net, gt. For some of these formats vertex/edge/graph properties can be read and written.\ncentrality: betweenness, closeness, degree, pagerank, Katz\ntraversal operations: cycle detection, BFS and DFS DAGs, BFS and DFS traversals with visitors, DFS topological sort, maximum adjacency / minimum cut, multiple random walks\nflow operations: maximum flow, minimum s-t cut\nmatching: minimum weight matching on arbitrary graphs (EE), minimum b-matching (EE)\ntravelling salesman problem: a TSP solver based on linear programming (EE)\ndismantling: collective influencer heuristic\nclique enumeration: maximal cliques\nlinear algebra / spectral graph theory: adjacency matrix, Laplacian matrix, non-backtracking matrix\ncommunity: modularity, community detection, core-periphery, clustering coefficients\ndistance within graphs: eccentricity, diameter, periphery, radius, center\ndistance between graphs: spectraldistance, editdistance","category":"page"},{"location":"#Licence-and-Credits","page":"Getting Started","title":"Licence and Credits","text":"","category":"section"},{"location":"","page":"Getting Started","title":"Getting Started","text":"Erdos is released under MIT License. Graphs stored in the datasets directory are released under GPLv3 License.","category":"page"},{"location":"","page":"Getting Started","title":"Getting Started","text":"Huge credit goes to the contributors of LightGraphs.jl, from which this library is derived. Also thanks to Tiago de Paula Peixoto and his Python library graph-tool for inspiration and for the graphs in datasets.","category":"page"}]
}
